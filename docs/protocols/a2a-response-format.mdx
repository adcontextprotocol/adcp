---
sidebar_position: 3.5
title: A2A Response Format
description: Canonical structure for AdCP responses transmitted over A2A protocol
keywords: [A2A response format, artifacts, DataPart, response structure, canonical format]
---

# A2A Response Format

This document defines the **canonical structure** for AdCP responses transmitted over the A2A protocol.

## Required Structure

### Final Responses (status: "completed")

**AdCP responses over A2A MUST:**
- Include at least one `DataPart` (kind: 'data') containing the task response payload
- Use single artifact with multiple parts (not multiple artifacts)
- Use the last `DataPart` as authoritative when multiple data parts exist
- NOT wrap AdCP payloads in custom framework objects (no `{ response: {...} }` wrappers)

**Recommended pattern:**

```json
{
  "status": "completed",
  "taskId": "task_123",
  "contextId": "ctx_456",
  "artifacts": [{
    "name": "task_result",
    "parts": [
      {
        "kind": "text",
        "text": "Found 12 video products perfect for pet food campaigns"
      },
      {
        "kind": "data",
        "data": {
          "products": [...],
          "total": 12
        }
      }
    ]
  }]
}
```

- **TextPart** (kind: 'text'): Human-readable summary - **recommended** but optional
- **DataPart** (kind: 'data'): Structured AdCP response payload - **required**
- **FilePart** (kind: 'file'): Optional file references (previews, reports)

**Multiple artifacts:** Only for fundamentally distinct deliverables (e.g., creative asset + separate trafficking report). Rare in AdCP - prefer single artifact with multiple parts.

### Interim Responses (working, submitted, input-required)

**CRITICAL**: Interim status responses (before task completion) do NOT require AdCP-structured payloads.

```json
{
  "status": "working",
  "taskId": "task_123",
  "contextId": "ctx_456",
  "artifacts": [{
    "parts": [
      {
        "kind": "text",
        "text": "Processing your request. Analyzing 50,000 inventory records..."
      }
    ]
  }]
}
```

**Interim response rules:**
- **TextPart** is sufficient - no DataPart required
- Status update only - not a task result
- Optional progress indicators (percentage, ETA)
- No AdCP schema validation required

**When final status is reached** (`status: "completed"` or `status: "failed"`), then DataPart with AdCP payload becomes required.

### Framework Wrappers (NOT PERMITTED)

**CRITICAL**: DataPart content MUST be the direct AdCP response payload, not wrapped in framework-specific objects.

```json
// ❌ WRONG - Wrapped in custom object
{
  "kind": "data",
  "data": {
    "response": {           // ← Framework wrapper
      "products": [...]
    }
  }
}

// ✅ CORRECT - Direct AdCP payload
{
  "kind": "data",
  "data": {
    "products": [...]       // ← Direct schema-compliant response
  }
}
```

**Why this matters:**
- Breaks schema validation (clients expect `products` at root, not `response.products`)
- Adds unnecessary nesting layer
- Violates protocol-agnostic design (wrapper is framework-specific)
- Complicates client extraction code

**If your implementation adds wrappers**, this is a bug that should be fixed in the framework layer, not worked around in client code.

## Canonical Client Behavior

This section defines EXACTLY how clients MUST extract AdCP responses from A2A protocol responses.

### Quick Reference

| Status | DataPart Required? | Schema Validation? | Returns |
|--------|-------------------|-------------------|---------|
| `working` | ❌ No | ❌ No | `{ status, taskId, message }` |
| `submitted` | ❌ No | ❌ No | `{ status, taskId, message }` |
| `input-required` | ❌ No | ❌ No | `{ status, taskId, message }` |
| `completed` | ✅ Yes | ✅ Yes | `{ status, taskId, message, data }` |
| `failed` | ✅ Yes | ✅ Yes | `{ status, taskId, message, data }` |

**Key Insight**: Interim statuses are status updates. Final statuses contain AdCP task results.

### Rule 1: Status-Based Handling

Clients MUST branch on `status` field to determine whether AdCP payload extraction is required:

```javascript
function handleA2aResponse(response) {
  const status = response.status;

  // INTERIM STATUSES - No AdCP extraction
  if (['working', 'submitted', 'input-required'].includes(status)) {
    return {
      status: status,
      taskId: response.taskId,
      contextId: response.contextId,
      message: extractTextPart(response),
      // No data field - this is a status update, not a result
    };
  }

  // FINAL STATUSES - Extract AdCP payload
  if (['completed', 'failed'].includes(status)) {
    return {
      status: status,
      taskId: response.taskId,
      contextId: response.contextId,
      message: extractTextPart(response),
      data: extractDataPart(response),  // AdCP payload
    };
  }

  throw new Error(`Unknown A2A status: ${status}`);
}
```

**Critical**: Clients MUST NOT attempt to extract DataPart or validate against AdCP schemas for interim statuses.

### Rule 2: Data Part Extraction (Final Responses Only)

When status is `completed` or `failed`, extract the last DataPart:

```javascript
function extractDataPart(response) {
  const dataParts = response.artifacts?.[0]?.parts
    ?.filter(p => p.kind === 'data') || [];

  if (dataParts.length === 0) {
    throw new Error('Final response (completed/failed) missing required DataPart');
  }

  // Use LAST data part as authoritative
  const lastDataPart = dataParts[dataParts.length - 1];
  const payload = lastDataPart.data;

  // CRITICAL: Payload MUST be direct AdCP response
  // If wrapper detected, reject the response
  if (payload.response !== undefined && typeof payload.response === 'object') {
    throw new Error(
      'Invalid response format: DataPart contains wrapper object. ' +
      'Expected direct AdCP payload (e.g., {products: [...]}) ' +
      'but received {response: {products: [...]}}. ' +
      'This is a server-side bug that must be fixed.'
    );
  }

  return payload;
}
```

### Rule 3: Text Part Extraction (All Responses)

TextPart is optional but recommended in all responses:

```javascript
function extractTextPart(response) {
  const textPart = response.artifacts?.[0]?.parts
    ?.find(p => p.kind === 'text');

  return textPart?.text || null;
}
```

### Rule 4: Schema Validation

Schema validation MUST only occur for final responses:

```javascript
function validateResponse(response, taskName) {
  const status = response.status;

  // SKIP VALIDATION for interim responses
  if (['working', 'submitted', 'input-required'].includes(status)) {
    return; // No validation - these are status updates
  }

  // VALIDATE final responses only
  if (['completed', 'failed'].includes(status)) {
    const data = extractDataPart(response);
    const schema = loadSchema(`${taskName}-response.json`);

    if (!validateAgainstSchema(data, schema)) {
      throw new Error(
        `Response payload does not match ${taskName} schema. ` +
        `Ensure DataPart contains direct AdCP response structure.`
      );
    }
  }
}
```

### Complete Example

Putting it all together:

```javascript
async function executeTask(taskName, params) {
  const response = await a2aClient.send({
    task: taskName,
    params: params
  });

  // 1. Status-based handling
  const result = handleA2aResponse(response);

  // 2. Validate if final response
  if (result.data) {
    validateResponse(response, taskName);
  }

  return result;
}

// Usage
const result = await executeTask('get_products', {
  brief: 'CTV inventory in California'
});

if (result.status === 'working') {
  console.log('Still processing:', result.message);
  // No result.data available yet
} else if (result.status === 'completed') {
  console.log('Success:', result.message);
  console.log('Products:', result.data.products); // AdCP payload
}
```

## Last Data Part Authority Pattern

<details>
<summary><strong>Why this pattern?</strong></summary>

During streaming operations, intermediate responses may include old progress data:

```json
// Working status with progress
{
  "status": "working",
  "artifacts": [{
    "parts": [
      {"kind": "text", "text": "Searching inventory..."},
      {"kind": "data", "data": {"progress": 25}}
    ]
  }]
}

// Completed - last data part is authoritative
{
  "status": "completed",
  "artifacts": [{
    "parts": [
      {"kind": "text", "text": "Found 12 products"},
      {"kind": "data", "data": {"progress": 25}},           // Old
      {"kind": "data", "data": {"products": [...], "total": 12}}  // ← Authoritative
    ]
  }]
}
```

**Note:** This is an AdCP-specific convention, not required by A2A protocol. Document this in your Agent Card when serving non-AdCP clients.
</details>

## Test Cases

### ✅ Correct Behavior

```javascript
// Test 1: Working status - no DataPart extraction
const workingResponse = {
  status: 'working',
  taskId: 'task_123',
  artifacts: [{
    parts: [
      { kind: 'text', text: 'Processing...' }
    ]
  }]
};

const result1 = handleA2aResponse(workingResponse);
assert(result1.data === undefined, 'Working status should not have data');
assert(result1.message === 'Processing...', 'Should extract message');

// Test 2: Completed status - extract DataPart
const completedResponse = {
  status: 'completed',
  taskId: 'task_123',
  artifacts: [{
    parts: [
      { kind: 'text', text: 'Found 3 products' },
      { kind: 'data', data: { products: [...] } }
    ]
  }]
};

const result2 = handleA2aResponse(completedResponse);
assert(result2.data !== undefined, 'Completed status must have data');
assert(Array.isArray(result2.data.products), 'Data should be direct AdCP payload');

// Test 3: Wrapper detection
const wrappedResponse = {
  status: 'completed',
  taskId: 'task_123',
  artifacts: [{
    parts: [
      { kind: 'data', data: { response: { products: [...] } } }
    ]
  }]
};

assert.throws(() => {
  extractDataPart(wrappedResponse);
}, /Invalid response format.*wrapper/);
```

### ❌ Incorrect Behavior (Common Mistakes)

```javascript
// WRONG: Extracting DataPart from interim status
function badHandleWorking(response) {
  // ❌ This tries to extract data from working status
  const data = extractDataPart(response); // Will throw!
  return { status: 'working', data };
}

// WRONG: Validating interim responses
function badValidation(response) {
  // ❌ This validates all responses, including interim
  validateResponse(response, 'get_products'); // Fails on working!
}

// WRONG: Not checking for wrappers
function badExtraction(response) {
  const payload = response.artifacts[0].parts[0].data;
  // ❌ Returns { response: { products: [...] } } instead of { products: [...] }
  return payload; // Client receives wrong structure!
}

// WRONG: Accessing nested response field
function badClientUsage(result) {
  // ❌ Client code shouldn't need to do this
  const products = result.data.response.products;
  // Should be: result.data.products
}
```

## Error Handling

### Task-Level Errors (Partial Failures)

Task executed but couldn't complete fully. Use `errors` array in DataPart with `status: "completed"`:

```json
{
  "status": "completed",
  "taskId": "task_123",
  "artifacts": [{
    "parts": [
      {
        "kind": "text",
        "text": "Signal discovery completed with partial results"
      },
      {
        "kind": "data",
        "data": {
          "signals": [...],
          "errors": [{
            "code": "NO_DATA_IN_REGION",
            "message": "No signal data available for Australia",
            "field": "deliver_to.countries[1]",
            "details": {
              "requested_country": "AU",
              "available_countries": ["US", "CA", "GB"]
            }
          }]
        }
      }
    ]
  }]
}
```

**When to use errors array:**
- Platform authorization issues (`PLATFORM_UNAUTHORIZED`)
- Partial data availability
- Validation issues in subset of data

### Protocol-Level Errors (Fatal)

Task couldn't execute. Use `status: "failed"` with message:

```json
{
  "taskId": "task_456",
  "status": "failed",
  "message": {
    "parts": [{
      "kind": "text",
      "text": "Authentication failed: Invalid or expired API token"
    }]
  }
}
```

**When to use status: failed:**
- Authentication failures (invalid credentials, expired tokens)
- Invalid request parameters (malformed JSON, missing required fields)
- Resource not found (unknown taskId, expired context)
- System errors (database unavailable, internal service failure)

## Status Mapping

AdCP uses A2A's TaskState enum directly:

| A2A Status | AdCP Usage | Response Structure |
|------------|------------|-------------------|
| `completed` | Task finished successfully | Data in `DataPart`, optional errors array |
| `failed` | Fatal error preventing completion | Text message explaining failure |
| `input-required` | Need user input/approval | Data + text explaining what's needed |
| `working` | Processing (< 120s) | Optional progress data |
| `submitted` | Long-running (hours/days) | Minimal data, use webhooks/polling |

## Webhook Payloads

Async operations (`status: "submitted"`) deliver the same artifact structure in webhooks:

```json
POST /webhook-endpoint
{
  "taskId": "task_123",
  "status": "completed",
  "timestamp": "2025-01-22T10:30:00Z",
  "artifacts": [{
    "parts": [
      {"kind": "text", "text": "Media buy approved and live"},
      {"kind": "data", "data": {
        "media_buy_id": "mb_456",
        "packages": [...],
        "creative_deadline": "2025-01-30T23:59:59Z"
      }}
    ]
  }]
}
```

Extract AdCP data using the same last-DataPart pattern. **For webhook authentication, retry patterns, and security**, see [Core Concepts - Webhook Reliability](/docs/protocols/core-concepts#webhook-reliability).

## File Parts in Responses

Creative operations MAY include file references:

```json
{
  "status": "completed",
  "artifacts": [{
    "parts": [
      {"kind": "text", "text": "Creative uploaded and preview generated"},
      {"kind": "data", "data": {
        "creative_id": "cr_789",
        "format_id": {
          "agent_url": "https://creatives.adcontextprotocol.org",
          "id": "video_standard_30s"
        },
        "status": "ready"
      }},
      {"kind": "file", "uri": "https://cdn.example.com/cr_789/preview.mp4", "name": "preview.mp4", "mimeType": "video/mp4"}
    ]
  }]
}
```

**File part usage:** Preview URLs, generated assets, trafficking reports. **Not for** raw AdCP response data (always use DataPart).

## Retry and Idempotency

### TaskId-Based Deduplication

A2A's `taskId` enables retry detection. Agents SHOULD:
- Return cached response if `taskId` matches a completed operation (within TTL window)
- Reject duplicate `taskId` submission if operation is still in progress

```json
// Duplicate taskId during active operation
{
  "taskId": "task_123",
  "status": "failed",
  "message": {
    "parts": [{
      "kind": "text",
      "text": "Task 'task_123' is already in progress. Use tasks/get to check status."
    }]
  }
}
```

## Examples

<details>
<summary><strong>Product Discovery Success</strong></summary>

```json
{
  "status": "completed",
  "taskId": "task_001",
  "contextId": "ctx_abc",
  "artifacts": [{
    "name": "product_catalog",
    "parts": [
      {
        "kind": "text",
        "text": "Found 8 CTV products targeting sports fans under $50 CPM"
      },
      {
        "kind": "data",
        "data": {
          "products": [
            {
              "product_id": "ctv_sports_premium",
              "name": "Premium Sports CTV"
            }
            // ... 7 more products
          ]
        }
      }
    ]
  }]
}
```
</details>

<details>
<summary><strong>Media Buy with Approval Required</strong></summary>

```json
{
  "status": "input-required",
  "taskId": "task_002",
  "contextId": "ctx_def",
  "artifacts": [{
    "name": "approval_request",
    "parts": [
      {
        "kind": "text",
        "text": "Media buy exceeds auto-approval limit ($100K). Please approve to proceed."
      },
      {
        "kind": "data",
        "data": {
          "media_buy_id": "mb_pending_456",
          "buyer_ref": "nike_q1_campaign_2024",
          "packages": [
            {
              "package_id": "pkg_pending_001",
              "buyer_ref": "nike_ctv_package",
              "status": "pending_approval"
            },
            {
              "package_id": "pkg_pending_002",
              "buyer_ref": "nike_audio_package",
              "status": "pending_approval"
            }
          ],
          "creative_deadline": "2025-02-01T23:59:59Z"
        }
      }
    ]
  }]
}
```
</details>

<details>
<summary><strong>Signal Discovery with Partial Failure</strong></summary>

```json
{
  "status": "completed",
  "taskId": "task_003",
  "contextId": "ctx_ghi",
  "artifacts": [{
    "name": "signal_results",
    "parts": [
      {
        "kind": "text",
        "text": "Found 3 signals for luxury automotive. Note: No data available for Australia region."
      },
      {
        "kind": "data",
        "data": {
          "signals": [
            {
              "signal_id": "lux_auto_us",
              "name": "Luxury Auto Intenders - US",
              "reach": 2500000
            }
          ],
          "total": 3,
          "errors": [{
            "code": "NO_DATA_IN_REGION",
            "message": "No signal data available for requested region: Australia",
            "field": "deliver_to.countries[1]",
            "details": {
              "requested_country": "AU",
              "available_countries": ["US", "CA", "GB"]
            }
          }]
        }
      }
    ]
  }]
}
```
</details>

<details>
<summary><strong>Platform Authorization Issue (Task-Level Error)</strong></summary>

Platform/operation-specific authorization failures are task-level errors:

```json
{
  "status": "completed",
  "taskId": "task_004",
  "contextId": "ctx_jkl",
  "artifacts": [{
    "name": "signal_activation_result",
    "parts": [
      {
        "kind": "text",
        "text": "Signal activation failed: Account not authorized for Peer39 data on PubMatic"
      },
      {
        "kind": "data",
        "data": {
          "errors": [{
            "code": "PLATFORM_UNAUTHORIZED",
            "message": "Account 'brand-456-pm' not authorized for Peer39 data on PubMatic. Contact your PubMatic account manager to enable access.",
            "details": {
              "platform": "pubmatic",
              "account_id": "brand-456-pm",
              "data_provider": "peer39"
            }
          }]
        }
      }
    ]
  }]
}
```
</details>

<details>
<summary><strong>Protocol-Level Failure (Fatal)</strong></summary>

Authentication failures are protocol-level errors:

```json
{
  "taskId": "task_005",
  "status": "failed",
  "message": {
    "parts": [{
      "kind": "text",
      "text": "Authentication failed: Invalid or expired API token. Please refresh your credentials and retry."
    }]
  }
}
```
</details>

## Implementation Checklist

When implementing A2A responses for AdCP:

**Final Responses (status: "completed" or "failed"):**
- [ ] **Always include status field** from TaskState enum
- [ ] **Include at least one DataPart** with AdCP response payload (even if empty: `{"products": []}`)
- [ ] **Include TextPart** with human-readable message (recommended for UX)
- [ ] **Use single artifact with multiple parts** (not multiple artifacts)
- [ ] **Use last DataPart as authoritative** if multiple exist
- [ ] **Never nest AdCP data in custom wrappers** (no `{ response: {...} }` objects)
- [ ] **DataPart content MUST match AdCP schemas** (validate against schema registry)

**Interim Responses (status: "working", "submitted", "input-required"):**
- [ ] **TextPart is sufficient** - no DataPart required for interim status
- [ ] **No AdCP schema validation needed** for interim responses
- [ ] **Optional progress indicators** (percentage, ETA, status message)

**Error Handling:**
- [ ] **Use `status: "failed"` for protocol errors only** (auth, invalid params, system errors)
- [ ] **Use `errors` array for task failures** (platform auth, partial data) with `status: "completed"`

**General:**
- [ ] **Include taskId and contextId** for tracking
- [ ] **Follow discriminated union patterns** for task responses (check schemas)
- [ ] **Deliver same structure in webhooks** as synchronous responses
- [ ] **Support taskId-based deduplication** for retry detection

## See Also

- [A2A Guide](/docs/protocols/a2a-guide) - Complete A2A integration guide
- [Core Concepts](/docs/protocols/core-concepts) - Status handling patterns
- [Error Handling](/docs/protocols/error-handling) - Fatal vs non-fatal errors
- [Protocol Comparison](/docs/protocols/protocol-comparison) - MCP vs A2A differences
