---
title: Task Management
sidebar_position: 6
---

# Task Management

AdCP provides unified task management for tracking all async operations across media-buy and signals domains. This enables state reconciliation, progress monitoring, and webhook integration for long-running operations.

## Overview

AdCP operations may complete immediately (~1 second), take processing time (~60 seconds), or require extended execution (minutes to days). Task management provides visibility and control over these async operations regardless of their domain or complexity.

**Core Tasks:**
- **[`tasks/list`](#taskslist)** - List and filter async operations for state reconciliation  
- **[`tasks/get`](#tasksget)** - Poll specific tasks for status, progress, and results

**Key Features:**
- **Cross-Domain Coverage**: Works for both media-buy and signals operations
- **State Reconciliation**: Prevents lost or orphaned operations
- **Webhook Integration**: Optional push notifications for completion
- **Progress Tracking**: Real-time status updates for active operations
- **Error Recovery**: Detailed error information and retry guidance

## Task Status Lifecycle

All AdCP operations follow a consistent status progression:

### Status Definitions

| Status | Description | Duration | Client Action |
|--------|-------------|----------|---------------|
| `submitted` | Queued for long-running execution | Hours to days | Poll periodically or wait for webhook |
| `working` | Actively processing | < 120 seconds | Poll frequently (5-10s intervals) |
| `input-required` | Paused, waiting for user input | Until input provided | Read message, provide clarification |
| `completed` | Successfully finished | Final | Process results, stop polling |
| `failed` | Failed due to error | Final | Handle error, potentially retry |
| `canceled` | Canceled by user | Final | Clean up, stop polling |
| `rejected` | Rejected before starting | Final | Review rejection reason |
| `auth-required` | Needs authentication | Until auth provided | Provide credentials |
| `unknown` | Indeterminate state | Variable | Check again or escalate |

### Status Transitions

```mermaid
graph LR
    A[Request] --> B[submitted]
    A --> C[working]
    A --> D[completed]
    
    B --> C
    B --> E[input-required]
    B --> F[failed]
    B --> G[canceled]
    
    C --> D
    C --> F
    C --> E
    
    E --> C
    E --> G
```

**Immediate Completion**: Simple operations may skip to `completed` without intermediate states.

**Working vs Submitted**: `working` indicates active processing with completion expected within 120 seconds, while `submitted` indicates queued execution that may take much longer.

## tasks/list

List and filter async tasks across your account to enable state reconciliation and operation tracking.

**Response Time**: ~1 second (simple database lookup)

**Request Schema**: [`https://adcontextprotocol.org/schemas/v2/core/tasks-list-request.json`](https://adcontextprotocol.org/schemas/v2/core/tasks-list-request.json)
**Response Schema**: [`https://adcontextprotocol.org/schemas/v2/core/tasks-list-response.json`](https://adcontextprotocol.org/schemas/v2/core/tasks-list-response.json)

### Request Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `filters` | object | No | Filter criteria for querying tasks |
| `sort` | object | No | Sorting parameters |
| `pagination` | object | No | Pagination controls |
| `include_history` | boolean | No | Include full conversation history for each task (default: false) |

### Filtering Options

#### Status and Type Filtering
```json
{
  "filters": {
    "status": "submitted",
    "statuses": ["submitted", "working", "input-required"],
    "task_type": "create_media_buy",
    "task_types": ["create_media_buy", "activate_signal"]
  }
}
```

#### Domain-Specific Filtering
```json
{
  "filters": {
    "domain": "media-buy",           // Filter by domain
    "domains": ["media-buy", "signals"],
    "task_types": [
      "create_media_buy",
      "update_media_buy", 
      "sync_creatives",
      "activate_signal",
      "get_signals"
    ]
  }
}
```

#### Date and Context Filtering
```json
{
  "filters": {
    "created_after": "2025-01-01T00:00:00Z",
    "created_before": "2025-01-31T23:59:59Z",
    "updated_after": "2025-01-20T00:00:00Z",
    "context_contains": "nike_q1_2025",
    "task_ids": ["task_456", "task_789"],
    "has_webhook": true
  }
}
```

### Response Structure

```json
{
  "message": "Found 27 tasks matching your criteria. 15 are pending and may need attention.",
  "context_id": "ctx-123",
  "query_summary": {
    "total_matching": 27,
    "returned": 20,
    "domain_breakdown": {
      "media-buy": 18,
      "signals": 9
    },
    "status_breakdown": {
      "submitted": 12,
      "working": 3,
      "completed": 8,
      "failed": 4
    }
  },
  "tasks": [
    {
      "task_id": "task_456",
      "task_type": "create_media_buy",
      "domain": "media-buy",
      "status": "submitted",
      "created_at": "2025-01-22T10:00:00Z",
      "updated_at": "2025-01-22T10:00:00Z",
      "message": "Media buy requires manual approval for $150K campaign",
      "has_webhook": true
    },
    {
      "task_id": "task_789",
      "task_type": "activate_signal",
      "domain": "signals",
      "status": "completed",
      "created_at": "2025-01-22T09:45:00Z",
      "completed_at": "2025-01-22T09:46:00Z",
      "message": "Signal sent successfully to 3 endpoints",
      "has_webhook": false
    }
  ],
  "pagination": {
    "limit": 20,
    "offset": 0,
    "has_more": true,
    "next_offset": 20
  }
}
```

### Common Use Cases

#### State Reconciliation
Find all pending operations across domains:
```json
{
  "filters": {
    "statuses": ["submitted", "working", "input-required"]
  },
  "sort": {
    "field": "created_at",
    "direction": "asc"
  }
}
```

#### Domain-Specific Monitoring
Track only media-buy operations:
```json
{
  "filters": {
    "domain": "media-buy",
    "statuses": ["submitted", "working"]
  }
}
```

#### Operations Needing Attention
```json
{
  "filters": {
    "statuses": ["input-required", "failed"],
    "updated_before": "2025-01-20T00:00:00Z"  // Old stuck tasks
  }
}
```

#### Lost Connection Recovery
Recover from lost task submissions by examining conversation history:
```json
{
  "filters": {
    "created_after": "2025-01-22T10:00:00Z"
  },
  "include_history": true
}
```

Then check `history[0].data` to see original requests and identify your lost task:
```javascript
tasks.tasks.forEach(task => {
  const originalRequest = task.history?.[0]?.data;
  if (originalRequest?.buyer_ref === "nike_q1_2025") {
    console.log(`Found my lost task: ${task.task_id}`);
  }
});
```

## tasks/get

Poll a specific task by ID to check status, progress, and retrieve results when complete.

**Response Time**: ~1 second (simple database lookup)

**Request Schema**: [`https://adcontextprotocol.org/schemas/v2/core/tasks-get-request.json`](https://adcontextprotocol.org/schemas/v2/core/tasks-get-request.json)
**Response Schema**: [`https://adcontextprotocol.org/schemas/v2/core/tasks-get-response.json`](https://adcontextprotocol.org/schemas/v2/core/tasks-get-response.json)

### Request Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `task_id` | string | Yes | Unique identifier of the task to retrieve |
| `include_history` | boolean | No | Include full conversation history for this task (default: false) |

### Response Structure

#### Basic Task Information
```json
{
  "message": "Media buy creation is 75% complete. Currently validating inventory availability.",
  "context_id": "ctx-123",
  "task_id": "task_456",
  "task_type": "create_media_buy",
  "domain": "media-buy",
  "status": "working",
  "created_at": "2025-01-22T10:00:00Z",
  "updated_at": "2025-01-22T10:15:00Z",
}
```

#### Progress Information
```json
{
  "progress": {
    "percentage": 75,
    "current_step": "validating_inventory_availability",
    "total_steps": 4,
    "step_number": 3
  }
}
```

#### Task with Conversation History
```json
{
  "status": "completed",
  "completed_at": "2025-01-22T10:25:00Z",
  "history": [
    {
      "timestamp": "2025-01-22T10:00:00Z",
      "type": "request",
      "data": {
        "buyer_ref": "nike_q1_2025",
        "brief": "Premium CTV inventory for Nike campaign"
      }
    },
    {
      "timestamp": "2025-01-22T10:25:00Z",
      "type": "response",
      "data": {
        "media_buy_id": "mb_987654321",
        "packages": [{ "package_id": "pkg_abc123" }]
      }
    }
  ]
}
```

#### Failed Task Errors
```json
{
  "status": "failed",
  "completed_at": "2025-01-22T10:20:00Z",
  "error": {
    "code": "insufficient_inventory",
    "message": "Requested targeting yielded 0 available impressions",
    "details": {
      "domain": "media-buy",
      "operation": "create_media_buy",
      "specific_context": {}
    }
  }
}
```

### Polling Patterns

#### Basic Polling Loop
```javascript
async function pollTask(taskId) {
  while (true) {
    const response = await session.call('tasks/get', { 
      task_id: taskId
    });
    
    switch (response.status) {
      case 'completed':
        return response; // Get full result from history if needed
        
      case 'failed':
        throw new Error(`Task failed: ${response.error.message}`);
        
      case 'input-required':
        const input = await promptUser(response.message);
        // Continue conversation with same context_id
        return await handleUserInput(response.context_id, input);
        
      case 'working':
        console.log(`Progress: ${response.progress?.percentage || 0}%`);
        await sleep(5000); // Poll working tasks frequently
        break;
        
      case 'submitted':
        console.log(`Task queued for long-running execution`);
        await sleep(60000); // Poll submitted tasks less frequently
        break;
    }
  }
}
```

#### Smart Polling with Domain Awareness
```javascript
async function smartPollTask(taskId) {
  let pollInterval = 2000;
  const maxInterval = 60000;
  
  while (true) {
    const response = await session.call('tasks/get', { task_id: taskId });
    
    if (['completed', 'failed', 'canceled'].includes(response.status)) {
      return response;
    }
    
    // Adjust polling based on domain and status
    if (response.status === 'working') {
      pollInterval = response.domain === 'signals' ? 2000 : 5000;
    } else if (response.status === 'submitted') {
      pollInterval = response.domain === 'media-buy' ? 60000 : 30000;
    }
    
    await sleep(Math.min(pollInterval, maxInterval));
  }
}
```

## Protocol Integration

Task management works consistently across all AdCP protocols.

### MCP Integration

```javascript
// List tasks
const taskList = await session.call('tasks/list', {
  filters: { statuses: ['submitted', 'working'] }
});

// Poll specific task
const taskStatus = await session.call('tasks/get', {
  task_id: 'task_456'
});
```

### A2A Integration

#### Natural Language
```javascript
await a2a.send({
  message: {
    parts: [{
      kind: "text",
      text: "Show me all pending media buy tasks from the last week"
    }]
  }
});
```

#### Explicit Skill Invocation
```javascript
await a2a.send({
  message: {
    parts: [{
      kind: "data",
      data: {
        skill: "tasks/list",
        parameters: {
          filters: {
            domain: "media-buy",
            statuses: ["submitted", "working"],
            created_after: "2025-01-15T00:00:00Z"
          }
        }
      }
    }]
  }
});
```

## Push Notification Integration

Both MCP and A2A use HTTP webhooks to deliver async task updates. Instead of polling, you provide a webhook URL and the server POSTs status changes directly to you.

| Protocol | Spec Status | Configuration | Envelope | Data Location |
|----------|-------------|---------------|----------|---------------|
| **MCP** | AdCP specifies this | `pushNotificationConfig` | `mcp-webhook-payload.json` | `result` field |
| **A2A** | Native to protocol | `pushNotificationConfig` | `Task` or `TaskStatusUpdateEvent` | `status.message.parts[].data` |

Both protocols use **identical AdCP data schemas**. For `completed`/`failed`, this is the full task response schema. For other statuses, use the status-specific schemas.

### MCP Webhook Configuration

MCP doesn't define push notifications. AdCP fills this gap by specifying the webhook configuration (`pushNotificationConfig`) and payload format (`mcp-webhook-payload.json`), using the same structure as A2A.

```javascript
const response = await session.call('create_media_buy',
  { /* task params */ },
  {
    pushNotificationConfig: {
      url: "https://buyer.com/webhooks/adcp/create_media_buy/agent_id/operation_id",
      authentication: {
        schemes: ["HMAC-SHA256"],  // or ["bearer"] for simple auth
        credentials: "shared_secret_32_chars"
      }
    }
  }
);
```

### A2A Webhook Configuration

A2A defines push notifications natively via `PushNotificationConfig`:

```javascript
await a2a.send({
  message: {
    parts: [{
      kind: "data",
      data: {
        skill: "create_media_buy",
        parameters: { /* task params */ }
      }
    }]
  },
  pushNotificationConfig: {
    url: "https://buyer.com/webhooks/a2a",
    token: "client-validation-token",  // Optional: for client-side validation
    authentication: {
      schemes: ["bearer"],
      credentials: "shared_secret_32_chars"
    }
  }
});
```

#### A2A Payload Types

Per the [A2A specification](https://a2a-protocol.org/latest/specification/#433-push-notification-payload), the server sends one of three payload types:

| Payload Type | When Used | Contains |
|--------------|-----------|----------|
| **`Task`** | Final states (`completed`, `failed`, `canceled`) or when client needs full context | Complete task object with all history |
| **`TaskStatusUpdateEvent`** | Status transitions during execution (`working`, `input-required`) | Just the status change with message |
| **`TaskArtifactUpdateEvent`** | Streaming artifact updates | Artifact data as it becomes available |

For AdCP, most push notifications will be `Task` (for final results) or `TaskStatusUpdateEvent` (for progress updates).

### Webhook Trigger Rules

Webhooks are triggered when **all** of the following are true:

1. **Task type supports async execution** (e.g., `create_media_buy`, `update_media_buy`, `sync_creatives`)
2. **`pushNotificationConfig` is provided** in the request
3. **Task requires async processing** — initial response is `working` or `submitted`

**When push notifications are NOT sent:**
- Task type is always synchronous (e.g., `list_creative_formats`)
- Initial response is already terminal (`completed`, `failed`, `rejected`) — client has the result
- `pushNotificationConfig` was not provided — client chose polling instead

**When push notifications ARE sent:**
- Status changes to `working` → Progress update (task actively processing)
- Status changes to `input-required` → Human input needed
- Status changes to `completed` → Final result available
- Status changes to `failed` → Error details provided
- Status changes to `canceled` → Cancellation confirmed

**Note:** For `working` tasks that complete quickly, the webhook may fire almost immediately. Clients who prefer polling for short tasks can simply omit `pushNotificationConfig`.

### MCP Webhook POST Format

**Envelope Schema:** [`mcp-webhook-payload.json`](https://adcontextprotocol.org/schemas/v2/core/mcp-webhook-payload.json)

**Envelope fields (transport layer):**
- `task_id` (required) — Unique task identifier
- `task_type` (required) — e.g., "create_media_buy", "sync_creatives"
- `status` (required) — Current task status
- `timestamp` (required) — ISO 8601 time when webhook was generated
- `operation_id` (optional) — Correlates a sequence of updates
- `domain` (optional) — AdCP domain ("media-buy" or "signals")
- `context_id` (optional) — Conversation/session id
- `message` (optional) — Human-readable context

**Data field (AdCP data layer):**
- `result` — Task-specific payload. Schema: [`async-response-data.json`](https://adcontextprotocol.org/schemas/v2/core/async-response-data.json)

**Example: MCP `completed` webhook:**
```http
POST /webhooks/adcp/create_media_buy/agent_123/op_456 HTTP/1.1
Host: buyer.example.com
Authorization: Bearer your-secret-token
Content-Type: application/json

{
  "task_id": "task_456",
  "task_type": "create_media_buy",
  "domain": "media-buy",
  "status": "completed",
  "timestamp": "2025-01-22T10:30:00Z",
  "message": "Media buy created successfully",
  "result": {
    "media_buy_id": "mb_12345",
    "buyer_ref": "nike_q1_campaign_2024",
    "creative_deadline": "2024-01-30T23:59:59Z",
    "packages": [
      { "package_id": "pkg_12345_001", "buyer_ref": "nike_ctv_package" }
    ]
  }
}
```

**Example: MCP `input-required` webhook:**
```http
POST /webhooks/adcp/create_media_buy/agent_123/op_456 HTTP/1.1
Host: buyer.example.com
Authorization: Bearer your-secret-token
Content-Type: application/json

{
  "task_id": "task_456",
  "task_type": "create_media_buy",
  "status": "input-required",
  "timestamp": "2025-01-22T10:15:00Z",
  "message": "Campaign budget $150K requires VP approval to proceed",
  "result": {
    "reason": "BUDGET_EXCEEDS_LIMIT",
    "errors": [
      {
        "code": "APPROVAL_REQUIRED",
        "message": "Budget exceeds auto-approval threshold",
        "field": "total_budget"
      }
    ]
  }
}
```

### A2A Webhook POST Format

Per the [A2A specification](https://a2a-protocol.org/latest/specification/#433-push-notification-payload), the server sends one of three payload types:

| Payload | When Used |
|---------|-----------|
| **`Task`** | Final states (`completed`, `failed`) or when full context is needed |
| **`TaskStatusUpdateEvent`** | Status transitions during execution (`working`, `input-required`) |
| **`TaskArtifactUpdateEvent`** | Streaming artifact updates |

**Data field (AdCP data layer):**
- `status.message.parts[].data` — Task-specific payload. Schema: [`async-response-data.json`](https://adcontextprotocol.org/schemas/v2/core/async-response-data.json)

**Example: `Task` payload for completed state:**
```json
{
  "id": "task_456",
  "contextId": "ctx_abc123",
  "status": {
    "state": "completed",
    "message": {
      "role": "agent",
      "parts": [
        { "text": "Media buy created successfully" },
        {
          "data": {
            "media_buy_id": "mb_12345",
            "buyer_ref": "nike_q1_campaign_2024",
            "creative_deadline": "2024-01-30T23:59:59Z",
            "packages": [
              { "package_id": "pkg_12345_001", "buyer_ref": "nike_ctv_package" }
            ]
          }
        }
      ]
    },
    "timestamp": "2025-01-22T10:30:00Z"
  }
}
```

**Example: `TaskStatusUpdateEvent` for input-required:**
```json
{
  "taskId": "task_456",
  "contextId": "ctx_abc123",
  "status": {
    "state": "input-required",
    "message": {
      "role": "agent",
      "parts": [
        { "text": "Campaign budget $150K requires VP approval" },
        {
          "data": {
            "reason": "BUDGET_EXCEEDS_LIMIT"
          }
        }
      ]
    },
    "timestamp": "2025-01-22T10:15:00Z"
  }
}
```

### Data Schema Validation

The data payload (`result` in MCP, `status.message.parts[].data` in A2A) is validated against status-specific schemas:

| Status | Schema |
|--------|--------|
| `completed` | `[task]-response.json` (success branch) |
| `failed` | `[task]-response.json` (error branch) |
| `working` | `[task]-async-response-working.json` |
| `input-required` | `[task]-async-response-input-required.json` |
| `submitted` | `[task]-async-response-submitted.json` |

This ensures the data payload is **transport-agnostic** and can be validated identically regardless of which protocol's webhook envelope is used.

### Webhook Handling Example

```javascript
app.post('/webhooks/adcp/:task_type/:agent_id/:operation_id', async (req, res) => {
  const { task_type, agent_id, operation_id } = req.params;
  const response = req.body;

  // Handle all status changes - webhooks fire for any task with pushNotificationConfig
  switch (response.status) {
    case 'input-required':
      // Alert human that input is needed
      await notifyHuman({
        operation_id,
        message: response.message,
        context_id: response.context_id,
        approval_data: response.data
      });
      break;

    case 'completed':
      // Process the completed operation
      if (task_type === 'create_media_buy') {
        await handleMediaBuyCreated({
          media_buy_id: response.result?.media_buy_id,
          buyer_ref: response.result?.buyer_ref,
          packages: response.result?.packages,
          creative_deadline: response.result?.creative_deadline
        });
      }
      break;

    case 'failed':
      // Handle failure
      await handleOperationFailed({
        operation_id,
        error: response.error,
        message: response.message
      });
      break;

    case 'canceled':
      // Handle cancellation
      await handleOperationCanceled(operation_id, response.message);
      break;
  }

  res.status(200).json({ status: 'processed' });
});
```

### Webhook Reliability

**Important**: Webhooks use at-least-once delivery semantics and may be duplicated or arrive out of order.

See **[Core Concepts: Webhook Reliability](/docs/protocols/core-concepts.mdx#webhook-reliability)** for detailed implementation guidance including:
- Idempotent webhook handlers
- Sequence handling and out-of-order detection
- Security considerations (signature verification)
- Polling as backup mechanism
- Replay attack prevention

## Error Handling

### Common Error Scenarios

1. **Task Not Found**: Invalid task ID or access permissions
2. **Invalid Filters**: Malformed filter criteria in tasks/list
3. **Pagination Errors**: Invalid offset or limit values
4. **Permission Denied**: Task exists but user lacks access

### Error Response Format

```json
{
  "status": "failed",
  "message": "Task not found or access denied",
  "context_id": "ctx-123",
  "errors": [{
    "code": "task_not_found", 
    "message": "No task found with ID 'task_456' for this account",
    "field": "task_id"
  }]
}
```

## Best Practices

### State Reconciliation
- Run `tasks/list` with pending filters during application startup
- Check for old tasks that may be stuck in `submitted` status
- Use domain filtering to focus on relevant operation types
- Include webhook status to understand notification expectations

### Performance Optimization
- Use pagination for accounts with many operations
- Filter by date ranges to limit results to relevant periods
- Use `include_history: false` by default to keep responses lightweight
- Implement exponential backoff for polling loops

### Monitoring and Alerting
- Monitor `input-required` tasks for user attention needs
- Alert on tasks stuck in `submitted` status beyond expected duration
- Track `failed` tasks for error reporting and system health
- Use domain breakdown to understand operation distribution

### Integration Patterns
- Store task IDs with your application entities for later reference
- Use webhooks as primary notification mechanism, polling as backup
- Implement proper error handling for both webhook and polling failures
- Consider domain-specific polling intervals and timeout values

## Related Documentation

- **[Core Concepts](/docs/protocols/core-concepts)** - Protocol fundamentals and design principles
- **[MCP Guide](/docs/protocols/mcp-guide)** - MCP-specific implementation patterns
- **[A2A Guide](/docs/protocols/a2a-guide)** - A2A-specific integration examples
- **[Media Buy Reference](/docs/media-buy/task-reference/)** - Domain-specific task documentation
- **[Signals Reference](/docs/signals/overview)** - Signal-specific task documentation