---
title: Task Management
sidebar_position: 8
---

# Task Management

AdCP provides unified task management for tracking all async operations across media-buy and signals domains. This enables state reconciliation, progress monitoring, and webhook integration for long-running operations.

## Overview

AdCP operations may complete immediately (~1 second), take processing time (~60 seconds), or require extended execution (minutes to days). Task management provides visibility and control over these async operations regardless of their domain or complexity.

**Core Tasks:**
- **[`tasks/list`](#taskslist)** - List and filter async operations for state reconciliation  
- **[`tasks/get`](#tasksget)** - Poll specific tasks for status, progress, and results

**Key Features:**
- **Cross-Domain Coverage**: Works for both media-buy and signals operations
- **State Reconciliation**: Prevents lost or orphaned operations
- **Webhook Integration**: Optional push notifications for completion
- **Progress Tracking**: Real-time status updates for active operations
- **Error Recovery**: Detailed error information and retry guidance

## Task Status Lifecycle

All AdCP operations follow a consistent status progression using the **A2A Protocol's TaskState enum** (A2A Specification Section 4.1.3)
**Reference**: [A2A Protocol TaskState Enum](https://a2a-protocol.org/latest/specification/#413-taskstate)

### Status Definitions

| Status | Description | Duration | Client Action |
|--------|-------------|----------|---------------|
| `submitted` | Queued for long-running execution | Hours to days | Poll periodically or wait for webhook |
| `working` | Actively processing | < 120 seconds | Poll frequently (5-10s intervals) |
| `input-required` | Paused, waiting for user input | Until input provided | Read message, provide clarification |
| `completed` | Successfully finished | Final | Process results, stop polling |
| `failed` | Failed due to error | Final | Handle error, potentially retry |
| `canceled` | Canceled by user | Final | Clean up, stop polling |
| `rejected` | Rejected before starting | Final | Review rejection reason |
| `auth-required` | Needs authentication | Until auth provided | Provide credentials |
| `unknown` | Indeterminate state | Variable | Check again or escalate |

### Status Transitions

```mermaid
graph LR
    A[Request] --> B[submitted]
    A --> C[working]
    A --> D[completed]
    
    B --> C
    B --> E[input-required]
    B --> F[failed]
    B --> G[canceled]
    
    C --> D
    C --> F
    C --> E
    
    E --> C
    E --> G
```

**Immediate Completion**: Simple operations may skip to `completed` without intermediate states.

**Working vs Submitted**: `working` indicates active processing with completion expected within 120 seconds, while `submitted` indicates queued execution that may take much longer.

## tasks/list

List and filter async tasks across your account to enable state reconciliation and operation tracking.

**Response Time**: ~1 second (simple database lookup)

**Request Schema**: [`https://adcontextprotocol.org/schemas/v2/core/tasks-list-request.json`](https://adcontextprotocol.org/schemas/v2/core/tasks-list-request.json)
**Response Schema**: [`https://adcontextprotocol.org/schemas/v2/core/tasks-list-response.json`](https://adcontextprotocol.org/schemas/v2/core/tasks-list-response.json)

### Request Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `filters` | object | No | Filter criteria for querying tasks |
| `sort` | object | No | Sorting parameters |
| `pagination` | object | No | Pagination controls |
| `include_history` | boolean | No | Include full conversation history for each task (default: false) |

### Filtering Options

#### Status and Type Filtering
```json
{
  "filters": {
    "status": "submitted",
    "statuses": ["submitted", "working", "input-required"],
    "task_type": "create_media_buy",
    "task_types": ["create_media_buy", "activate_signal"]
  }
}
```

#### Domain-Specific Filtering
```json
{
  "filters": {
    "domain": "media-buy",           // Filter by domain
    "domains": ["media-buy", "signals"],
    "task_types": [
      "create_media_buy",
      "update_media_buy", 
      "sync_creatives",
      "activate_signal",
      "get_signals"
    ]
  }
}
```

#### Date and Context Filtering
```json
{
  "filters": {
    "created_after": "2025-01-01T00:00:00Z",
    "created_before": "2025-01-31T23:59:59Z",
    "updated_after": "2025-01-20T00:00:00Z",
    "context_contains": "nike_q1_2025",
    "task_ids": ["task_456", "task_789"],
    "has_webhook": true
  }
}
```

### Response Structure

```json
{
  "message": "Found 27 tasks matching your criteria. 15 are pending and may need attention.",
  "context_id": "ctx-123",
  "query_summary": {
    "total_matching": 27,
    "returned": 20,
    "domain_breakdown": {
      "media-buy": 18,
      "signals": 9
    },
    "status_breakdown": {
      "submitted": 12,
      "working": 3,
      "completed": 8,
      "failed": 4
    }
  },
  "tasks": [
    {
      "task_id": "task_456",
      "task_type": "create_media_buy",
      "domain": "media-buy",
      "status": "submitted",
      "created_at": "2025-01-22T10:00:00Z",
      "updated_at": "2025-01-22T10:00:00Z",
      "message": "Media buy requires manual approval for $150K campaign",
      "has_webhook": true
    },
    {
      "task_id": "task_789",
      "task_type": "activate_signal",
      "domain": "signals",
      "status": "completed",
      "created_at": "2025-01-22T09:45:00Z",
      "completed_at": "2025-01-22T09:46:00Z",
      "message": "Signal sent successfully to 3 endpoints",
      "has_webhook": false
    }
  ],
  "pagination": {
    "limit": 20,
    "offset": 0,
    "has_more": true,
    "next_offset": 20
  }
}
```

### Common Use Cases

#### State Reconciliation
Find all pending operations across domains:
```json
{
  "filters": {
    "statuses": ["submitted", "working", "input-required"]
  },
  "sort": {
    "field": "created_at",
    "direction": "asc"
  }
}
```

#### Domain-Specific Monitoring
Track only media-buy operations:
```json
{
  "filters": {
    "domain": "media-buy",
    "statuses": ["submitted", "working"]
  }
}
```

#### Operations Needing Attention
```json
{
  "filters": {
    "statuses": ["input-required", "failed"],
    "updated_before": "2025-01-20T00:00:00Z"  // Old stuck tasks
  }
}
```

#### Lost Connection Recovery
Recover from lost task submissions by examining conversation history:
```json
{
  "filters": {
    "created_after": "2025-01-22T10:00:00Z"
  },
  "include_history": true
}
```

Then check `history[0].data` to see original requests and identify your lost task:
```javascript
tasks.tasks.forEach(task => {
  const originalRequest = task.history?.[0]?.data;
  if (originalRequest?.buyer_ref === "nike_q1_2025") {
    console.log(`Found my lost task: ${task.task_id}`);
  }
});
```

## tasks/get

Poll a specific task by ID to check status, progress, and retrieve results when complete.

**Response Time**: ~1 second (simple database lookup)

**Request Schema**: [`https://adcontextprotocol.org/schemas/v2/core/tasks-get-request.json`](https://adcontextprotocol.org/schemas/v2/core/tasks-get-request.json)
**Response Schema**: [`https://adcontextprotocol.org/schemas/v2/core/tasks-get-response.json`](https://adcontextprotocol.org/schemas/v2/core/tasks-get-response.json)

### Request Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `task_id` | string | Yes | Unique identifier of the task to retrieve |
| `include_history` | boolean | No | Include full conversation history for this task (default: false) |

### Response Structure

#### Basic Task Information
```json
{
  "message": "Media buy creation is 75% complete. Currently validating inventory availability.",
  "context_id": "ctx-123",
  "task_id": "task_456",
  "task_type": "create_media_buy",
  "domain": "media-buy",
  "status": "working",
  "created_at": "2025-01-22T10:00:00Z",
  "updated_at": "2025-01-22T10:15:00Z",
}
```

#### Progress Information
```json
{
  "progress": {
    "percentage": 75,
    "current_step": "validating_inventory_availability",
    "total_steps": 4,
    "step_number": 3
  }
}
```

#### Task with Conversation History
```json
{
  "status": "completed",
  "completed_at": "2025-01-22T10:25:00Z",
  "history": [
    {
      "timestamp": "2025-01-22T10:00:00Z",
      "type": "request",
      "data": {
        "buyer_ref": "nike_q1_2025",
        "brief": "Premium CTV inventory for Nike campaign"
      }
    },
    {
      "timestamp": "2025-01-22T10:25:00Z",
      "type": "response",
      "data": {
        "media_buy_id": "mb_987654321",
        "packages": [{ "package_id": "pkg_abc123" }]
      }
    }
  ]
}
```

#### Failed Task Errors
```json
{
  "status": "failed",
  "completed_at": "2025-01-22T10:20:00Z",
  "error": {
    "code": "insufficient_inventory",
    "message": "Requested targeting yielded 0 available impressions",
    "details": {
      "domain": "media-buy",
      "operation": "create_media_buy",
      "specific_context": {}
    }
  }
}
```

### Polling Patterns

#### Basic Polling Loop
```javascript
async function pollTask(taskId) {
  while (true) {
    const response = await session.call('tasks/get', { 
      task_id: taskId
    });
    
    switch (response.status) {
      case 'completed':
        return response; // Get full result from history if needed
        
      case 'failed':
        throw new Error(`Task failed: ${response.error.message}`);
        
      case 'input-required':
        const input = await promptUser(response.message);
        // Continue conversation with same context_id
        return await handleUserInput(response.context_id, input);
        
      case 'working':
        console.log(`Progress: ${response.progress?.percentage || 0}%`);
        await sleep(5000); // Poll working tasks frequently
        break;
        
      case 'submitted':
        console.log(`Task queued for long-running execution`);
        await sleep(60000); // Poll submitted tasks less frequently
        break;
    }
  }
}
```

#### Smart Polling with Domain Awareness
```javascript
async function smartPollTask(taskId) {
  let pollInterval = 2000;
  const maxInterval = 60000;
  
  while (true) {
    const response = await session.call('tasks/get', { task_id: taskId });
    
    if (['completed', 'failed', 'canceled'].includes(response.status)) {
      return response;
    }
    
    // Adjust polling based on domain and status
    if (response.status === 'working') {
      pollInterval = response.domain === 'signals' ? 2000 : 5000;
    } else if (response.status === 'submitted') {
      pollInterval = response.domain === 'media-buy' ? 60000 : 30000;
    }
    
    await sleep(Math.min(pollInterval, maxInterval));
  }
}
```

## Protocol Integration

Task management works consistently across all AdCP protocols.

### MCP Integration

```javascript
// List tasks
const taskList = await session.call('tasks/list', {
  filters: { statuses: ['submitted', 'working'] }
});

// Poll specific task
const taskStatus = await session.call('tasks/get', {
  task_id: 'task_456'
});
```

### A2A Integration

#### Natural Language
```javascript
await a2a.send({
  message: {
    parts: [{
      kind: "text",
      text: "Show me all pending media buy tasks from the last week"
    }]
  }
});
```

#### Explicit Skill Invocation
```javascript
await a2a.send({
  message: {
    parts: [{
      kind: "data",
      data: {
        skill: "tasks/list",
        parameters: {
          filters: {
            domain: "media-buy",
            statuses: ["submitted", "working"],
            created_after: "2025-01-15T00:00:00Z"
          }
        }
      }
    }]
  }
});
```

## Webhook Integration

Task management integrates with protocol-level webhook configuration for push notifications.

### Webhook Configuration

Configure webhooks at the protocol level when making async task calls. See **[Core Concepts: Protocol-Level Webhook Configuration](/docs/protocols/core-concepts#protocol-level-webhook-configuration)** for complete setup examples.

**Quick example:**
```javascript
const response = await session.call('create_media_buy',
  { /* task params */ },
  {
    push_notification_config: {
      url: "https://buyer.com/webhooks/adcp/create_media_buy/agent_id/operation_id",
      authentication: {
        schemes: ["HMAC-SHA256"],  // or ["Bearer"] for simple auth
        credentials: "shared_secret_32_chars"
      }
    }
  }
);
```

### Webhook POST Format

When a task's status changes, the publisher POSTs a payload following **A2A Protocol's push notification payload structure** (A2A Specification Section 4.3.3). The payload is a **StreamResponse object** (A2A Specification Section 3.2.3) containing exactly one of: `task` (Task object), `message` (Message object), `statusUpdate` (TaskStatusUpdateEvent), or `artifactUpdate` (TaskArtifactUpdateEvent). ADCP declares only the structure of `parts[].data` (DataPart data field) within Message objects for task-specific payloads.

**Webhook Payload Schema**: [`https://adcontextprotocol.org/schemas/v2/core/webhook-payload.json`](https://adcontextprotocol.org/schemas/v2/core/webhook-payload.json)

**StreamResponse structure (A2A Section 3.2.3):**
The payload contains exactly one of:
- `statusUpdate`: A TaskStatusUpdateEvent indicating a status change (used for status transitions like `input-required`, `failed`, `working`)
- `task`: A Task object with the current task state (used for final completion with full context)
- `message`: A Message object containing a message response
- `artifactUpdate`: A TaskArtifactUpdateEvent indicating artifact update

**TaskStatusUpdateEvent structure (when using `statusUpdate` variant - most common for status changes):**
- `taskId` (required) — Unique identifier for the task
- `contextId` (required) — Unique identifier for the contextual collection
- `status` (required) — TaskStatus object containing:
  - `state` (required) — Current task state (A2A TaskState enum)
  - `message` (optional) — Message object with parts array
  - `timestamp` (optional) — ISO 8601 timestamp when status was recorded
- `final` (required) — Boolean indicating if this is the final event in the stream

**Task object structure (when using `task` variant - for final completion):**
- `id` (required) — Unique identifier for the task (not top-level `taskId`)
- `contextId` (required) — Unique identifier for the contextual collection
- `status` (required) — TaskStatus object containing:
  - `state` (required) — Current task state (A2A TaskState enum)
  - `message` (optional) — Message object with parts array
  - `timestamp` (optional) — ISO 8601 timestamp when status was recorded

**Message.parts structure (within status.message or task.status.message):**
- `parts[]` — Array of message parts (A2A Part union type)
  - TextPart: `{text: string}` — Human-readable context (optional)
  - DataPart: `{data: object}` — Task-specific payload (ADCP declares only this structure)
  - FilePart: `{file: object}` — Optional file references (rarely used in webhooks)

**Extracting task data:**
```javascript
function extractWebhookData(webhookPayload) {
  // A2A StreamResponse contains exactly one of: task, message, statusUpdate, artifactUpdate
  
  // Handle statusUpdate (for status change events like input-required, failed, working)
  if (webhookPayload.statusUpdate) {
    const event = webhookPayload.statusUpdate;
    const taskId = event.taskId; // Note: taskId in statusUpdate, not id
    const status = event.status.state;
    const message = event.status.message;
    
    if (message?.parts) {
      const dataPart = message.parts.find(part => part.data !== undefined);
      return {
        taskId,
        status,
        data: dataPart?.data, // This is the AdCP task-specific payload
        final: event.final // Indicates if this is the final event
      };
    }
    
    return { taskId, status, final: event.final };
  }
  
  // Handle task (for final completion with full task state)
  if (webhookPayload.task) {
    const task = webhookPayload.task;
    const taskId = task.id; // Task ID is in task.id
    const status = task.status.state;
    const message = task.status.message;
    
    if (message?.parts) {
      const dataPart = message.parts.find(part => part.data !== undefined);
      return {
        taskId,
        status,
        data: dataPart?.data // This is the AdCP task-specific payload
      };
    }
  }
  
  // Handle other StreamResponse variants (message, artifactUpdate)...
  return null;
}
```

**Example: `input-required` webhook (human approval needed) - A2A StreamResponse format:**
```http
POST /webhooks/adcp/create_media_buy/agent_123/op_456 HTTP/1.1
Host: buyer.example.com
Authorization: Bearer your-secret-token
Content-Type: application/json

{
  "statusUpdate": {
    "taskId": "task_456",
    "contextId": "ctx_abc123",
    "status": {
      "state": "input-required",
      "timestamp": "2025-01-22T10:15:00Z",
      "message": {
        "messageId": "msg_456_001",
        "role": "agent",
        "parts": [
          {
            "text": "Campaign budget $150K requires VP approval to proceed"
          },
          {
            "data": {
              "buyer_ref": "nike_q1_campaign_2024"
            }
          }
        ]
      }
    },
    "final": false
  }
}
```

**Example: `completed` webhook (after approval granted - full create_media_buy response) - A2A StreamResponse format:**
```http
POST /webhooks/adcp/create_media_buy/agent_123/op_456 HTTP/1.1
Host: buyer.example.com
Authorization: Bearer your-secret-token
Content-Type: application/json

{
  "task": {
    "id": "task_456",
    "contextId": "ctx_abc123",
    "status": {
      "state": "completed",
      "timestamp": "2025-01-22T10:30:00Z",
      "message": {
        "parts": [
          {
            "text": "Media buy created successfully with 2 packages ready for creative assignment"
          },
          {
            "data": {
              "media_buy_id": "mb_12345",
              "buyer_ref": "nike_q1_campaign_2024",
              "creative_deadline": "2024-01-30T23:59:59Z",
              "packages": [
                { "package_id": "pkg_12345_001", "buyer_ref": "nike_ctv_package" }
              ]
            }
          }
        ]
      }
    }
  }
}
```

The webhook receives the **full A2A-compatible StreamResponse structure** for each status change. For `statusUpdate` events, extract task data from `statusUpdate.status.message.parts[]` array by finding the DataPart (part with `data` property). Task ID is in `statusUpdate.taskId` and status state is in `statusUpdate.status.state`. For `task` events, use `task.id` and `task.status.state`. The `statusUpdate.final` flag indicates if this is the final event in the stream. This means your webhook handler gets all the context and data needed to take appropriate action.

**Operation Identification**: For `create_media_buy` operations, `buyer_ref` is required in all webhook payloads (`parts.data.buyer_ref`) to enable operation identification. This allows buyers to correlate webhook notifications with their internal systems using their own reference identifier, in addition to the `taskId` provided by the A2A structure.

### Webhook Handling Example

```javascript
app.post('/webhooks/adcp/:task_type/:agent_id/:operation_id', async (req, res) => {
  const { task_type, agent_id, operation_id } = req.params;
  const payload = req.body;

  // Extract data from A2A StreamResponse format
  let taskId, status, data, final;
  
  if (payload.statusUpdate) {
    // Status change event
    const event = payload.statusUpdate;
    taskId = event.taskId;
    status = event.status.state;
    final = event.final;
    const dataPart = event.status.message?.parts?.find(p => p.data);
    data = dataPart?.data;
  } else if (payload.task) {
    // Final task state
    const task = payload.task;
    taskId = task.id;
    status = task.status.state;
    const dataPart = task.status.message?.parts?.find(p => p.data);
    data = dataPart?.data;
    final = true; // task variant typically indicates final state
  } else {
    return res.status(400).json({ error: 'Invalid webhook payload format' });
  }

  // Webhooks are only called for 'submitted' operations
  // So we only need to handle status changes that occur after submission
  switch (status) {
    case 'input-required':
      // Alert human that input is needed
      await notifyHuman({
        taskId,
        operation_id,
        message: payload.statusUpdate?.status?.message?.parts?.find(p => p.text)?.text,
        context_id: payload.statusUpdate?.contextId,
        approval_data: data
      });
      break;

    case 'completed':
      // Process the completed operation
      if (task_type === 'create_media_buy') {
        await handleMediaBuyCreated({
          taskId,
          media_buy_id: data?.media_buy_id,
          buyer_ref: data?.buyer_ref,
          packages: data?.packages,
          creative_deadline: data?.creative_deadline
        });
      }
      break;

    case 'failed':
      // Handle failure
      const errorMessage = payload.statusUpdate?.status?.message?.parts?.find(p => p.text)?.text;
      await handleOperationFailed({
        taskId,
        operation_id,
        error: data?.errors || [{ message: errorMessage }],
        message: errorMessage
      });
      break;

    case 'canceled':
      // Handle cancellation
      const cancelMessage = payload.statusUpdate?.status?.message?.parts?.find(p => p.text)?.text;
      await handleOperationCanceled(taskId, operation_id, cancelMessage);
      break;
  }

  res.status(200).json({ status: 'processed' });
});
```

### Webhook Reliability

**Important**: Webhooks use at-least-once delivery semantics and may be duplicated or arrive out of order.

See **[Core Concepts: Webhook Reliability](/docs/protocols/core-concepts#webhook-reliability)** for detailed implementation guidance including:
- Idempotent webhook handlers
- Sequence handling and out-of-order detection
- Security considerations (signature verification)
- Polling as backup mechanism
- Replay attack prevention

## Error Handling

### Common Error Scenarios

1. **Task Not Found**: Invalid task ID or access permissions
2. **Invalid Filters**: Malformed filter criteria in tasks/list
3. **Pagination Errors**: Invalid offset or limit values
4. **Permission Denied**: Task exists but user lacks access

### Error Response Format

```json
{
  "status": "failed",
  "message": "Task not found or access denied",
  "context_id": "ctx-123",
  "errors": [{
    "code": "task_not_found", 
    "message": "No task found with ID 'task_456' for this account",
    "field": "task_id"
  }]
}
```

## Best Practices

### State Reconciliation
- Run `tasks/list` with pending filters during application startup
- Check for old tasks that may be stuck in `submitted` status
- Use domain filtering to focus on relevant operation types
- Include webhook status to understand notification expectations

### Performance Optimization
- Use pagination for accounts with many operations
- Filter by date ranges to limit results to relevant periods
- Use `include_history: false` by default to keep responses lightweight
- Implement exponential backoff for polling loops

### Monitoring and Alerting
- Monitor `input-required` tasks for user attention needs
- Alert on tasks stuck in `submitted` status beyond expected duration
- Track `failed` tasks for error reporting and system health
- Use domain breakdown to understand operation distribution

### Integration Patterns
- Store task IDs with your application entities for later reference
- Use webhooks as primary notification mechanism, polling as backup
- Implement proper error handling for both webhook and polling failures
- Consider domain-specific polling intervals and timeout values

## Related Documentation

- **[Core Concepts](/docs/protocols/core-concepts)** - Protocol fundamentals and design principles
- **[MCP Guide](/docs/protocols/mcp-guide)** - MCP-specific implementation patterns
- **[A2A Guide](/docs/protocols/a2a-guide)** - A2A-specific integration examples
- **[Media Buy Reference](/docs/media-buy/task-reference/)** - Domain-specific task documentation
- **[Signals Reference](/docs/signals/overview)** - Signal-specific task documentation