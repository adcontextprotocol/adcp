---
sidebar_position: 4
title: Protocol Comparison
description: Compare MCP and A2A protocols for AdCP integration. Both use the same unified status system with different transport formats.
keywords: [MCP vs A2A, protocol comparison, AdCP integration, status handling, transport differences]
---

# Protocol Comparison

Both MCP and A2A provide identical AdCP capabilities using the same unified status system. They differ only in transport format and async handling.

## Quick Comparison

| Aspect | MCP | A2A |
|--------|-----|-----|
| **Request Style** | Tool calls | Task messages |
| **Response Style** | Direct JSON | Artifacts |
| **Status System** | ✅ Unified status field | ✅ Unified status field |
| **Async Handling** | Polling with tasks/get | SSE streaming |
| **Webhooks** | Protocol wrapper extension | Native PushNotificationConfig |
| **Task Management** | tasks/list, tasks/get tools | Native tasks/list, tasks/get |
| **Context** | Manual (pass context_id) | Automatic (protocol-managed) |
| **Best For** | Claude, AI assistants | Agent workflows |

## Unified Status System

**✨ New in AdCP 1.6.0**: Both protocols now use the same status field with A2A TaskState values.

### Status Handling (Both Protocols)

Every response includes a status field that tells you exactly what to do:

```json
{
  "status": "input-required",    // Same values for both protocols
  "message": "Need your budget", // Same human explanation
  // ... protocol-specific formatting below
}
```

| Status | What It Means | Your Action |
|--------|---------------|-------------|
| `completed` | Task finished | Process data, show success |
| `input-required` | Need user input | Read message, prompt user, follow up |
| `working` | Processing (< 120s) | Poll frequently, show progress |
| `submitted` | Long-running (hours to days) | Provide webhook or poll less frequently |
| `failed` | Error occurred | Show error, handle gracefully |
| `auth-required` | Need auth | Prompt for credentials |

See [Core Concepts](/docs/protocols/core-concepts) for complete status handling guide.

## Transport Format Differences

Same status and data, different packaging:

### MCP Response Format
```json
{
  "message": "I need your budget and target audience",
  "status": "input-required",
  "context_id": "ctx-123",
  "data": {
    "products": [],
    "suggestions": ["budget", "audience"]
  }
}
```

### A2A Response Format
```json
{
  "status": "input-required",
  "contextId": "ctx-123",
  "artifacts": [{
    "artifactId": "artifact-product-discovery-xyz",
    "name": "product_discovery",
    "parts": [
      {
        "kind": "text",
        "text": "I need your budget and target audience"
      },
      {
        "kind": "data",
        "data": {
          "products": [],
          "suggestions": ["budget", "audience"]
        }
      }
    ]
  }]
}
```

## Async Operation Differences

Both protocols handle async operations with the same status progression:
`submitted` → `working` → `completed`/`failed`

### MCP Async Pattern
```javascript
// Initial response with task_id
{
  "status": "submitted",
  "message": "Creating media buy, requires manual approval",
  "context_id": "ctx-123",
  "task_id": "task-456",
}

// Poll using tasks/get
const updates = await session.call('tasks/get', { 
  task_id: "task-456", 
  include_result: true 
});

// Optional: Configure webhook at protocol level (A2A-compatible structure)
const response = await session.call('create_media_buy', params, {
  push_notification_config: {
    url: "https://buyer.com/webhooks",
    authentication: {
      schemes: ["HMAC-SHA256"],  // or ["Bearer"]
      credentials: "shared_secret_32_chars"
    }
  }
});
```

### A2A Async Pattern
```javascript
// Initial response with native task tracking
{
  "status": "submitted", 
  "taskId": "task-456",
  "contextId": "ctx-123",
  "estimatedCompletionTime": "2025-01-23T10:00:00Z"
}

// Real-time updates via SSE
const events = new EventSource(`/tasks/${response.taskId}/events`);
events.onmessage = (event) => {
  const update = JSON.parse(event.data);
  console.log(`Status: ${update.status}, Message: ${update.message}`);
};

// Native webhook support
await a2a.send({
  message: { /* skill invocation */ },
  push_notification_config: {
    webhook_url: "https://buyer.com/webhooks",
    authentication: {
      schemes: ["Bearer"],
      credentials: "secret_token_min_32_chars"
    }
  }
});
```

## Push Notification Architecture

Both MCP and A2A use HTTP webhooks for async task updates. AdCP keeps the **envelope format** protocol-specific while using **identical data schemas** for the business payload.

### Key Differences

| Aspect | MCP | A2A |
|--------|-----|-----|
| **Spec Status** | AdCP provides the webhook mechanism | Native protocol feature |
| **Configuration** | `pushNotificationConfig` | `pushNotificationConfig` |
| **Envelope** | `mcp-webhook-payload.json` | `Task`, `TaskStatusUpdateEvent`, or `TaskArtifactUpdateEvent` |
| **Data Location** | `result` field | `status.message.parts[].data` |
| **Data Schemas** | **Identical** AdCP schemas | **Identical** AdCP schemas |

### MCP Webhooks

MCP doesn't define push notifications, so AdCP provides this capability. When you configure a webhook, the server will POST task updates to your URL instead of requiring you to poll.

**Envelope Schema:** [`mcp-webhook-payload.json`](https://adcontextprotocol.org/schemas/v2/core/mcp-webhook-payload.json)

```javascript
// Configure webhook when calling MCP tool
const response = await session.call('create_media_buy',
  { /* task params */ },
  {
    pushNotificationConfig: {
      url: "https://buyer.com/webhooks/adcp",
      authentication: {
        schemes: ["HMAC-SHA256"],
        credentials: "shared_secret_32_chars"
      }
    }
  }
);
```

**MCP Webhook POST:**
```json
{
  "task_id": "task_456",
  "task_type": "create_media_buy",
  "status": "completed",
  "timestamp": "2025-01-22T10:30:00Z",
  "message": "Media buy created successfully",
  "result": {
    "media_buy_id": "mb_12345",
    "buyer_ref": "nike_q1_campaign",
    "packages": [...]
  }
}
```

### A2A Webhooks

A2A defines push notifications natively via `PushNotificationConfig`. Per the [A2A spec](https://a2a-protocol.org/latest/specification/#433-push-notification-payload), the server can send `Task`, `TaskStatusUpdateEvent`, or `TaskArtifactUpdateEvent` depending on the situation.

**Data Location:** `status.message.parts[].data`

```javascript
// Configure push notification when sending A2A task
await a2a.send({
  message: {
    parts: [{
      kind: "data",
      data: {
        skill: "create_media_buy",
        parameters: { /* task params */ }
      }
    }]
  },
  pushNotificationConfig: {
    url: "https://buyer.com/webhooks/a2a",
    authentication: {
      schemes: ["bearer"],
      credentials: "shared_secret_32_chars"
    }
  }
});
```

**A2A Webhook POST (Task object for completed state):**
```json
{
  "id": "task_456",
  "contextId": "ctx_123",
  "status": {
    "state": "completed",
    "message": {
      "role": "agent",
      "parts": [
        { "text": "Media buy created successfully" },
        {
          "data": {
            "media_buy_id": "mb_12345",
            "buyer_ref": "nike_q1_campaign",
            "packages": [...]
          }
        }
      ]
    },
    "timestamp": "2025-01-22T10:30:00Z"
  }
}
```

### Unified Data Schemas

Both protocols use HTTP webhooks. The **data payload** uses identical AdCP schemas regardless of envelope format:

| Status | MCP Location | A2A Location | Schema |
|--------|--------------|--------------|--------|
| `completed` | `result` | `status.message.parts[].data` | `create-media-buy-async-response-completed.json` |
| `failed` | `result` | `status.message.parts[].data` | `create-media-buy-async-response-failed.json` |
| `working` | `result` | `status.message.parts[].data` | `create-media-buy-async-response-working.json` |
| `input-required` | `result` | `status.message.parts[].data` | `create-media-buy-async-response-input-required.json` |

This separation ensures:
- **Consistent validation** of AdCP data across protocols
- **Native protocol behavior** preserved (A2A SSE, MCP polling)
- **No redundant envelope** in A2A (uses native message structure)

### Task Management

Both protocols now provide equivalent task management capabilities:

#### MCP: AdCP Tasks
```javascript
// List pending tasks
await session.call('tasks/list', {
  filters: { statuses: ["submitted", "working"] }
});

// Poll specific task
await session.call('tasks/get', { 
  task_id: "task_456", 
  include_result: true 
});

// State reconciliation
const reconciliation = await session.reconcileState();
```

#### A2A: Native RPC Methods
```javascript
// Native task management
const tasks = await a2a.rpc('tasks/list', {
  filters: { statuses: ["submitted", "working"] }
});

const task = await a2a.rpc('tasks/get', { 
  task_id: "task_456",
  include_result: true 
});
```

### Server Decision Making

In both protocols, the server decides whether to use webhooks:

- **Quick operations** (< 120s): Returns `working`, ignores webhook configuration
- **Long operations** (hours/days): Returns `submitted`, uses webhook if provided
- **Fallback**: Clients can always poll regardless of webhook configuration

## Clarification Handling

**Before AdCP 1.6.0**: Different approaches for each protocol  
**After AdCP 1.6.0**: Same pattern using `status: "input-required"`

### Unified Clarification Pattern

```javascript
// Works for both MCP and A2A
function handleResponse(response) {
  if (response.status === 'input-required') {
    // Extract clarification from message
    const info = promptUser(response.message);
    
    // Send follow-up with same context
    return sendFollowUp(response.context_id, info);
  }
  
  if (response.status === 'completed') {
    return processResults(response.data);
  }
}
```

### Example: Clarification Flow

**User:** "Find video products"  
**AdCP Response:** 
```json
{
  "status": "input-required",
  "message": "I'd be happy to help find video products. What's your budget and target audience?",
  "context_id": "ctx-123"
}
```

**User Follow-up:** "Budget is $50K, targeting pet owners"  
**AdCP Response:**
```json
{
  "status": "completed", 
  "message": "Found 8 video products perfect for pet owners",
  "context_id": "ctx-123",
  "data": { "products": [...] }
}
```

## Human-in-the-Loop Workflows

Both protocols handle approvals using `status: "input-required"`:

```json
{
  "status": "input-required",
  "message": "Media buy exceeds auto-approval limit ($100K). Please approve to proceed.",
  "context_id": "ctx-123",
  "data": {
    "approval_required": true,
    "amount": 150000,
    "reason": "exceeds_limit"
  }
}
```

Client handling is identical:
```javascript
if (response.status === 'input-required' && response.data?.approval_required) {
  const decision = await getApproval(response.message);
  return sendApproval(response.context_id, decision);
}
```

## Context Management

### MCP: Manual Context
```javascript
let contextId = null;

async function callAdcp(request) {
  if (contextId) {
    request.context_id = contextId;
  }
  
  const response = await mcp.call('get_products', request);
  contextId = response.context_id; // Save for next call
  
  return response;
}
```

### A2A: Automatic Context
```javascript
// A2A manages context automatically
const response1 = await a2a.send({ message: "Find video products" });
const response2 = await a2a.send({ 
  contextId: response1.contextId, // Optional - A2A tracks this
  message: "Focus on premium inventory" 
});
```

## Operation Examples

### Product Discovery

**MCP:**
```javascript
const response = await mcp.call('get_products', {
  brief: "CTV campaign for sports fans",
  budget: 100000
});

if (response.status === 'completed') {
  console.log(response.data.products);
}
```

**A2A:**
```javascript
const response = await a2a.send({
  message: {
    parts: [{
      kind: "data",
      data: {
        skill: "get_products",
        parameters: {
          brief: "CTV campaign for sports fans",
          budget: 100000
        }
      }
    }]
  }
});

if (response.status === 'completed') {
  console.log(response.artifacts[0].parts[1].data.products);
}
```

## Error Handling

Both use `status: "failed"` with same error structure:

```json
{
  "status": "failed",
  "message": "Insufficient inventory for your targeting criteria",
  "context_id": "ctx-123",
  "data": {
    "error_code": "insufficient_inventory",
    "suggestions": ["Expand targeting", "Increase CPM"]
  }
}
```

## Choosing a Protocol

Choose based on your ecosystem and preferences:

### Choose MCP if you're using:
- Claude Desktop or Claude Code
- MCP-compatible AI assistants  
- Simple tool-based integrations
- Direct JSON responses

### Choose A2A if you're using:
- Google AI agents or Agent Engine
- Multi-modal workflows (text + files)
- Real-time streaming updates
- Artifact-based data handling

### Both protocols provide:
- ✅ Same AdCP tasks and capabilities
- ✅ Unified status system for clear client logic  
- ✅ Context management for conversations
- ✅ Async operation support
- ✅ Human-in-the-loop workflows
- ✅ Error handling and recovery

## Migration Between Protocols

The unified status system makes it easy to switch protocols:

```javascript
// Abstract client that works with both
class UnifiedAdcpClient {
  constructor(protocol, config) {
    this.client = protocol === 'mcp' 
      ? new McpClient(config)
      : new A2aClient(config);
  }
  
  async send(request) {
    const response = await this.client.send(request);
    
    // Normalize response format
    return {
      status: response.status,
      message: response.message || response.artifacts?.[0]?.parts?.[0]?.text,
      contextId: response.context_id || response.contextId,
      data: response.data || response.artifacts?.[0]?.parts?.[1]?.data
    };
  }
}
```

## Next Steps

- **Core Concepts**: Read [Core Concepts](/docs/protocols/core-concepts) for status handling patterns
- **MCP Guide**: See [MCP Guide](/docs/protocols/mcp-guide) for tool calls and context management
- **A2A Guide**: See [A2A Guide](/docs/protocols/a2a-guide) for artifacts and streaming
- **Migration**: Both protocols provide the same capabilities with unified status handling