---
title: sync_creatives
sidebar_position: 4
testable: true
---

# sync_creatives

Upload and manage creative assets for media buys. Supports bulk uploads, upsert semantics, and generative creatives.

**Response Time**: Instant to minutes (depends on file processing and validation)

**Request Schema**: [`/schemas/v2/media-buy/sync-creatives-request.json`](https://adcontextprotocol.org/schemas/v2/media-buy/sync-creatives-request.json)
**Response Schema**: [`/schemas/v2/media-buy/sync-creatives-response.json`](https://adcontextprotocol.org/schemas/v2/media-buy/sync-creatives-response.json)

## Quick Start

Upload creative assets:

<CodeGroup>

```javascript JavaScript
import { testAgent } from '@adcp/client/testing';

const result = await testAgent.syncCreatives({
  creatives: [{
    creative_id: 'creative_video_001',
    name: 'Summer Sale 30s',
    format_id: {
      agent_url: 'https://creative.adcontextprotocol.org',
      id: 'video_standard_30s'
    },
    assets: {
      video: {
        url: 'https://cdn.example.com/summer-sale-30s.mp4',
        width: 1920,
        height: 1080,
        duration_ms: 30000
      }
    }
  }]
});

// Check for operation-level errors first
if (result.errors) {
  console.error('Operation failed:', result.errors);
} else {
  console.log(`Synced ${result.creatives.length} creatives`);
}
```

```python Python
import asyncio
from adcp import test_agent

async def main():
    result = await test_agent.simple.sync_creatives(
        creatives=[{
            'creative_id': 'creative_video_001',
            'name': 'Summer Sale 30s',
            'format_id': {
                'agent_url': 'https://creative.adcontextprotocol.org',
                'id': 'video_standard_30s'
            },
            'assets': {
                'video': {
                    'url': 'https://cdn.example.com/summer-sale-30s.mp4',
                    'width': 1920,
                    'height': 1080,
                    'duration_ms': 30000
                }
            }
        }]
    )

    # Check for operation-level errors first
    if hasattr(result, 'errors') and result.errors:
        print('Operation failed:', result.errors)
    else:
        print(f"Synced {len(result.creatives)} creatives")

asyncio.run(main())
```

</CodeGroup>

## Request Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `creatives` | Creative[] | Yes | Creative assets to upload/update (max 100) |
| `creative_ids` | string[] | No | Optional filter to limit sync scope to specific creative IDs. Only these creatives are affected, others remain untouched. Useful for partial updates and error recovery. |
| `assignments` | object | No | Map of creative_id to array of package_ids for bulk assignment |
| `dry_run` | boolean | No | When true, preview changes without applying them (default: false) |
| `validation_mode` | string | No | Validation strictness: `"strict"` (default) or `"lenient"` |
| `delete_missing` | boolean | No | When true, creatives not in this sync are archived (default: false) |

### Creative Object

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `creative_id` | string | Yes | Unique identifier for this creative |
| `name` | string | Yes | Human-readable name |
| `format_id` | FormatId | Yes | Format specification (structured object with `agent_url` and `id`) |
| `assets` | object | Yes | Assets keyed by role (e.g., `{video: {...}, thumbnail: {...}}`) |
| `tags` | string[] | No | Searchable tags for creative organization |

### Asset Structure

Assets are keyed by role name. Each role contains the asset details:

```json test=false
{
  "assets": {
    "video": {
      "url": "https://cdn.example.com/video.mp4",
      "width": 1920,
      "height": 1080,
      "duration_ms": 30000
    },
    "thumbnail": {
      "url": "https://cdn.example.com/thumb.jpg",
      "width": 300,
      "height": 250
    }
  }
}
```

### Assignments Structure

Assignments are at the request level, mapping creative IDs to package IDs:

```json test=false
{
  "assignments": {
    "creative_video_001": ["pkg_premium", "pkg_standard"],
    "creative_display_002": ["pkg_standard"]
  }
}
```

## Response

| Field | Description |
|-------|-------------|
| `creatives` | Array of synced creative objects with `platform_creative_id` populated |
| `errors` | Array of validation/processing errors (if any) |
| `warnings` | Array of non-blocking warnings (if any) |

**Each creative in response includes**:
- All request fields
- `platform_creative_id` - Platform's internal ID
- Processing status and timestamps

**See schema for complete field list**: [sync-creatives-response.json](https://adcontextprotocol.org/schemas/v2/media-buy/sync-creatives-response.json)

## Common Scenarios

### Bulk Upload

Upload multiple creatives in one call:

<CodeGroup>

```javascript JavaScript
import { testAgent } from '@adcp/client/testing';

const result = await testAgent.syncCreatives({
  creatives: [
    {
      creative_id: 'creative_display_001',
      name: 'Summer Sale Banner 300x250',
      format_id: {
        agent_url: 'https://creative.adcontextprotocol.org',
        id: 'display_300x250'
      },
      assets: {
        image: {
          url: 'https://cdn.example.com/banner-300x250.jpg',
          width: 300,
          height: 250
        }
      }
    },
    {
      creative_id: 'creative_video_002',
      name: 'Product Demo 15s',
      format_id: {
        agent_url: 'https://creative.adcontextprotocol.org',
        id: 'video_standard_15s'
      },
      assets: {
        video: {
          url: 'https://cdn.example.com/demo-15s.mp4',
          width: 1920,
          height: 1080,
          duration_ms: 15000
        }
      }
    },
    {
      creative_id: 'creative_display_002',
      name: 'Summer Sale Banner 728x90',
      format_id: {
        agent_url: 'https://creative.adcontextprotocol.org',
        id: 'display_728x90'
      },
      assets: {
        image: {
          url: 'https://cdn.example.com/banner-728x90.jpg',
          width: 728,
          height: 90
        }
      }
    }
  ]
});

// Check for operation-level errors first
if (result.errors) {
  console.error('Operation failed:', result.errors);
} else {
  console.log(`Successfully synced ${result.creatives.length} creatives`);
  result.creatives.forEach(creative => {
  console.log(`  ${creative.name}: ${creative.platform_creative_id}`);
});
}
```

```python Python
import asyncio
from adcp import test_agent

async def main():
    result = await test_agent.simple.sync_creatives(
        creatives=[
            {
                'creative_id': 'creative_display_001',
                'name': 'Summer Sale Banner 300x250',
                'format_id': {
                    'agent_url': 'https://creative.adcontextprotocol.org',
                    'id': 'display_300x250'
                },
                'assets': {
                    'image': {
                        'url': 'https://cdn.example.com/banner-300x250.jpg',
                        'width': 300,
                        'height': 250
                    }
                }
            },
            {
                'creative_id': 'creative_video_002',
                'name': 'Product Demo 15s',
                'format_id': {
                    'agent_url': 'https://creative.adcontextprotocol.org',
                    'id': 'video_standard_15s'
                },
                'assets': {
                    'video': {
                        'url': 'https://cdn.example.com/demo-15s.mp4',
                        'width': 1920,
                        'height': 1080,
                        'duration_ms': 15000
                    }
                }
            },
            {
                'creative_id': 'creative_display_002',
                'name': 'Summer Sale Banner 728x90',
                'format_id': {
                    'agent_url': 'https://creative.adcontextprotocol.org',
                    'id': 'display_728x90'
                },
                'assets': {
                    'image': {
                        'url': 'https://cdn.example.com/banner-728x90.jpg',
                        'width': 728,
                        'height': 90
                    }
                }
            }
        ]
    )

    # Check for operation-level errors first
    if hasattr(result, 'errors') and result.errors:
        print('Operation failed:', result.errors)
    else:
        print(f"Successfully synced {len(result.creatives)} creatives")
        for creative in result.creatives:
            print(f"  {creative.name}: {creative.platform_creative_id}")

asyncio.run(main())
```

</CodeGroup>

### Generative Creatives

Use the creative agent to generate creatives from a brand manifest. See the [Generative Creatives guide](/docs/creative/generative-creative) for complete workflow details.

<CodeGroup>

```javascript JavaScript
import { testAgent } from '@adcp/client/testing';

const result = await testAgent.syncCreatives({
  creatives: [{
    creative_id: 'creative_gen_001',
    name: 'AI-Generated Summer Banner',
    format_id: {
      agent_url: 'https://creative.adcontextprotocol.org',
      id: 'display_300x250'
    },
    assets: {
      manifest: {
        url: 'https://cdn.example.com/brand-manifest.json'
      }
    }
  }]
});

// Check for operation-level errors first
if (result.errors) {
  console.error('Operation failed:', result.errors);
} else {
  console.log('Generative creative synced:', result.creatives[0].creative_id);
}
```

```python Python
import asyncio
from adcp import test_agent

async def main():
    result = await test_agent.simple.sync_creatives(
        creatives=[{
            'creative_id': 'creative_gen_001',
            'name': 'AI-Generated Summer Banner',
            'format_id': {
                'agent_url': 'https://creative.adcontextprotocol.org',
                'id': 'display_300x250'
            },
            'assets': {
                'manifest': {
                    'url': 'https://cdn.example.com/brand-manifest.json'
                }
            }
        }]
    )

    # Check for operation-level errors first
    if hasattr(result, 'errors') and result.errors:
        print('Operation failed:', result.errors)
    else:
        print(f"Generative creative synced: {result.creatives[0].creative_id}")

asyncio.run(main())
```

</CodeGroup>

### Dry Run Validation

Validate creative configuration without uploading:

<CodeGroup>

```javascript JavaScript
import { testAgent } from '@adcp/client/testing';

const result = await testAgent.syncCreatives({
  dry_run: true,
  creatives: [{
    creative_id: 'creative_test_001',
    name: 'Test Creative',
    format_id: {
      agent_url: 'https://creative.adcontextprotocol.org',
      id: 'video_standard_30s'
    },
    assets: {
      video: {
        url: 'https://cdn.example.com/test-video.mp4',
        width: 1920,
        height: 1080,
        duration_ms: 30000
      }
    }
  }]
});

if (result.errors && result.errors.length > 0) {
  console.log('Validation errors found:');
  result.errors.forEach(error => console.log(`  - ${error.message}`));
} else {
  console.log('Validation passed! Ready to sync.');
}
```

```python Python
import asyncio
from adcp import test_agent

async def main():
    result = await test_agent.simple.sync_creatives(
        dry_run=True,
        creatives=[{
            'creative_id': 'creative_test_001',
            'name': 'Test Creative',
            'format_id': {
                'agent_url': 'https://creative.adcontextprotocol.org',
                'id': 'video_standard_30s'
            },
            'assets': {
                'video': {
                    'url': 'https://cdn.example.com/test-video.mp4',
                    'width': 1920,
                    'height': 1080,
                    'duration_ms': 30000
                }
            }
        }]
    )

    if hasattr(result, 'errors') and result.errors:
        print('Validation errors found:')
        for error in result.errors:
            print(f"  - {error.message}")
    else:
        print('Validation passed! Ready to sync.')

asyncio.run(main())
```

</CodeGroup>

### Scoped Update with creative_ids Filter

Update only specific creatives from a large library without affecting others:

<CodeGroup>

```javascript JavaScript
import { testAgent } from '@adcp/client/testing';

// Update just 2 creatives out of 100+ in the library
const result = await testAgent.syncCreatives({
  creative_ids: ['creative_video_001', 'creative_display_001'],
  creatives: [
    {
      creative_id: 'creative_video_001',
      name: 'Summer Sale 30s - Updated',
      format_id: {
        agent_url: 'https://creative.adcontextprotocol.org',
        id: 'video_standard_30s'
      },
      assets: {
        video: {
          url: 'https://cdn.example.com/updated-video.mp4',
          width: 1920,
          height: 1080,
          duration_ms: 30000
        }
      }
    },
    {
      creative_id: 'creative_display_001',
      name: 'Summer Sale Banner - Updated',
      format_id: {
        agent_url: 'https://creative.adcontextprotocol.org',
        id: 'display_300x250'
      },
      assets: {
        image: {
          url: 'https://cdn.example.com/updated-banner.jpg',
          width: 300,
          height: 250
        }
      }
    }
  ]
});

if (result.errors) {
  console.error('Update failed:', result.errors);
} else {
  console.log(`Updated ${result.creatives.length} creatives, others untouched`);
}
```

```python Python
import asyncio
from adcp import test_agent

async def main():
    # Update just 2 creatives out of 100+ in the library
    result = await test_agent.simple.sync_creatives(
        creative_ids=['creative_video_001', 'creative_display_001'],
        creatives=[
            {
                'creative_id': 'creative_video_001',
                'name': 'Summer Sale 30s - Updated',
                'format_id': {
                    'agent_url': 'https://creative.adcontextprotocol.org',
                    'id': 'video_standard_30s'
                },
                'assets': {
                    'video': {
                        'url': 'https://cdn.example.com/updated-video.mp4',
                        'width': 1920,
                        'height': 1080,
                        'duration_ms': 30000
                    }
                }
            },
            {
                'creative_id': 'creative_display_001',
                'name': 'Summer Sale Banner - Updated',
                'format_id': {
                    'agent_url': 'https://creative.adcontextprotocol.org',
                    'id': 'display_300x250'
                },
                'assets': {
                    'image': {
                        'url': 'https://cdn.example.com/updated-banner.jpg',
                        'width': 300,
                        'height': 250
                    }
                }
            }
        ]
    )

    if hasattr(result, 'errors') and result.errors:
        print('Update failed:', result.errors)
    else:
        print(f"Updated {len(result.creatives)} creatives, others untouched")

asyncio.run(main())
```

</CodeGroup>

**Why use creative_ids filter:**
- Scoped updates: Only specified creatives modified, even with 100+ in library
- Error recovery: Retry only failed creatives after bulk sync validation failures
- Performance: Publisher can optimize processing when scope is known upfront
- Safety: Explicit targeting reduces risk of unintended changes

## Sync Modes

### Upsert (default)
- Creates new creatives or updates existing by `creative_id`
- Merges package assignments (additive)
- Updates provided fields, leaves others unchanged
- Use `creative_ids` filter to limit scope to specific creatives

### Dry Run
- Validates request without making changes
- Returns errors and warnings
- Does not process assets or create creatives
- Use for pre-flight validation checks

## Error Handling

| Error Code | Description | Resolution |
|------------|-------------|------------|
| `INVALID_FORMAT` | Format not supported by product | Check product's supported formats via `list_creative_formats` |
| `ASSET_PROCESSING_FAILED` | Asset file corrupt or invalid | Verify asset meets format requirements (codec, dimensions, duration) |
| `PACKAGE_NOT_FOUND` | Package ID doesn't exist in media buy | Verify `package_id` from `create_media_buy` response |
| `BRAND_SAFETY_VIOLATION` | Creative failed brand safety scan | Review content against publisher's brand safety guidelines |
| `FORMAT_MISMATCH` | Assets don't match format requirements | Verify asset types and specifications match format definition |
| `DUPLICATE_CREATIVE_ID` | Creative ID already exists in different media buy | Use unique `creative_id` or sync to correct media buy |

## Best Practices

1. **Use upsert semantics** - Same `creative_id` updates existing creative rather than creating duplicates. This allows iterative creative development.

2. **Validate first** - Use `mode: "dry_run"` to catch errors before actual upload. This saves bandwidth and processing time.

3. **Batch assignments** - Include all package assignments in single sync call to avoid race conditions between updates.

4. **CDN-hosted assets** - Use publicly accessible CDN URLs for faster processing. Platforms can fetch assets directly without proxy delays.

5. **Brand manifests** - For generative creatives, validate manifest schema before syncing to avoid processing failures.

6. **Check format support** - Use `list_creative_formats` to verify product supports your creative formats before uploading.

## Webhook Payloads (Async Updates)

When `sync_creatives` returns `status: "submitted"` or `status: "working"`, webhooks are triggered for status changes. The webhook payload follows **A2A Protocol's push notification payload structure** (A2A Specification Section 4.3.3). The payload is a **StreamResponse object** containing exactly one of: `statusUpdate` (for status changes), `task` (for final completion), `message`, or `artifactUpdate`.

ADCP declares only the structure of `parts[].data` (DataPart data field) within Message objects. The following specifies what `parts.data` should contain for each status in `sync_creatives` webhook payloads:

**Important**: `creative_ids` is required in all webhook payloads for `sync_creatives` tool (all statuses) to enable creative identification. This allows buyers to correlate webhook notifications with their internal systems without needing to store `taskId` mappings.

**Schema References:**

**Top-Level Webhook Payload Schema:**
- [`/schemas/v2/core/webhook-payload.json`](https://adcontextprotocol.org/schemas/v2/core/webhook-payload.json) - Complete A2A StreamResponse structure containing `statusUpdate`, `task`, `message`, or `artifactUpdate`

### Status: `input-required`

**Schema**: [`/schemas/v2/media-buy/sync-creatives-async-response-input-required.json`](https://adcontextprotocol.org/schemas/v2/media-buy/sync-creatives-async-response-input-required.json) - Defines the structure of `parts[].data` for this status.

When additional input or fixes are required (e.g., invalid format, missing assets, validation errors), the webhook uses `statusUpdate` with `parts.data` containing:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `creative_ids` | string[] | Yes | Array of creative IDs requiring input or fixes |
| `errors` | Error[] | Yes | Array of error objects explaining what input or fixes are needed |

**Example `parts.data` for `input-required`:**
```json
{
  "creative_ids": ["creative_video_001", "creative_display_002"],
  "errors": [
    {
      "code": "BRAND_SAFETY_REVIEW_REQUIRED",
      "message": "Creatives contain content that requires manual brand safety review before approval. Please review and approve or provide alternative assets.",
      "field": "creatives[0].assets",
      "suggestion": "Review creative content against publisher's brand safety guidelines or provide alternative assets"
    }
  ]
}
```

**Full webhook payload example:**
```json
{
  "statusUpdate": {
    "taskId": "task_789",
    "contextId": "ctx_abc123",
    "status": {
      "state": "input-required",
      "timestamp": "2025-01-22T12:00:00Z",
      "message": {
        "messageId": "msg_789_006",
        "role": "agent",
        "parts": [
          {
            "text": "Creative format validation failed. Please fix the issues and retry."
          },
          {
            "data": {
              "creative_ids": ["creative_video_001", "creative_display_002"],
              "errors": [
                {
                  "code": "FORMAT_MISMATCH",
                  "message": "Creative assets do not match the required format specifications. Video duration must be exactly 30 seconds, but provided video is 28 seconds.",
                  "field": "creatives[0].assets.video.duration_ms",
                  "suggestion": "Provide a video asset with duration_ms of 30000 (30 seconds) to match the format requirements"
                }
              ]
            }
          }
        ]
      }
    },
    "final": false
  }
}
```

### Status: `completed`

**Schema**: [`/schemas/v2/media-buy/sync-creatives-response.json`](https://adcontextprotocol.org/schemas/v2/media-buy/sync-creatives-response.json) - Defines the structure of `parts[].data` for this status.

When the creative sync is successfully completed, the webhook may use either `statusUpdate` or `task` variant. The `parts.data` contains the full success response matching the synchronous response schema:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `dry_run` | boolean | No | Whether this was a dry run (no actual changes made) |
| `creatives` | CreativeResult[] | Yes | Array of results for each creative processed |
| `context` | Context | No | Application-level context (if provided in request) |
| `ext` | object | No | Extension fields (if provided in request) |

**Example `parts.data` for `completed`:**
```json
{
  "creatives": [
    {
      "creative_id": "creative_video_001",
      "action": "created",
      "platform_id": "platform_12345"
    },
    {
      "creative_id": "creative_display_002",
      "action": "updated",
      "platform_id": "platform_67890",
      "changes": ["name", "assets"]
    }
  ]
}
```

**Full webhook payload example (using `task` variant):**
```json
{
  "task": {
    "id": "task_789",
    "contextId": "ctx_abc123",
    "status": {
      "state": "completed",
      "timestamp": "2025-01-22T12:30:00Z",
      "message": {
        "messageId": "msg_789_007",
        "role": "agent",
        "parts": [
          {
            "text": "Successfully synced 2 creatives"
          },
          {
            "data": {
              "creatives": [
                {
                  "creative_id": "creative_video_001",
                  "action": "created",
                  "platform_id": "platform_12345"
                },
                {
                  "creative_id": "creative_display_002",
                  "action": "updated",
                  "platform_id": "platform_67890",
                  "changes": ["name", "assets"]
                }
              ]
            }
          }
        ]
      }
    }
  }
}
```

### Status: `failed`

**Schema**: [`/schemas/v2/media-buy/sync-creatives-async-response-failed.json`](https://adcontextprotocol.org/schemas/v2/media-buy/sync-creatives-async-response-failed.json) - Defines the structure of `parts[].data` for this status.

When the sync operation fails completely (no creatives were processed), the webhook uses `statusUpdate` with `parts.data` containing:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `creative_ids` | string[] | Yes | Array of creative IDs that failed to sync (required for identification) |
| `errors` | Error[] | Yes | Array of error objects explaining why the sync operation failed |

**Example `parts.data` for `failed`:**
```json
{
  "creative_ids": ["creative_video_001", "creative_display_002"],
  "errors": [
    {
      "code": "AUTHENTICATION_FAILED",
      "message": "Invalid or expired API token",
      "field": "authentication"
    },
    {
      "code": "SERVICE_UNAVAILABLE",
      "message": "Creative processing service temporarily unavailable",
      "field": "service"
    }
  ]
}
```

**Full webhook payload example:**
```json
{
  "statusUpdate": {
    "taskId": "task_789",
    "contextId": "ctx_abc123",
    "status": {
      "state": "failed",
      "timestamp": "2025-01-22T12:45:00Z",
      "message": {
        "messageId": "msg_789_008",
        "role": "agent",
        "parts": [
          {
            "text": "Creative sync operation failed"
          },
          {
            "data": {
              "creative_ids": ["creative_video_001", "creative_display_002"],
              "errors": [
                {
                  "code": "AUTHENTICATION_FAILED",
                  "message": "Invalid or expired API token",
                  "field": "authentication"
                }
              ]
            }
          }
        ]
      }
    },
    "final": true
  }
}
```

### Status: `working`

**Schema**: [`/schemas/v2/media-buy/sync-creatives-async-response-working.json`](https://adcontextprotocol.org/schemas/v2/media-buy/sync-creatives-async-response-working.json) - Defines the structure of `parts[].data` for this status.

When the creative sync operation is actively processing (uploading assets, validating formats, processing generative creatives), the webhook uses `statusUpdate` with `parts.data` containing:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `creative_ids` | string[] | Yes | Array of creative IDs being processed. Required for identifying which creatives are being synced. |

**Example webhook payload:**
```json
{
  "statusUpdate": {
    "taskId": "task_789",
    "contextId": "ctx_abc123",
    "status": {
      "state": "working",
      "timestamp": "2025-01-22T12:10:00Z",
      "message": {
        "messageId": "msg_789_009",
        "role": "agent",
        "parts": [
          {
            "text": "Processing creatives and validating assets..."
          },
          {
            "data": {
              "creative_ids": ["creative_video_001", "creative_display_002"]
            }
          }
        ]
      }
    },
    "final": false
  }
}
```

**Note**: `creative_ids` is required in `parts.data` for `working` status to enable operation identification. The TextPart provides human-readable progress information.

### Status: `submitted`

When the creative sync is submitted for long-running processing (hours to days), the initial response returns `status: "submitted"`. Webhooks will be triggered for subsequent status changes (`input-required`, `completed`, `failed`). The `submitted` status itself does not trigger a webhook.

### Summary

| Status | StreamResponse Variant | `parts.data` Contents | Required Fields |
|--------|----------------------|----------------------|----------------|
| `input-required` | `statusUpdate` | `creative_ids[]`, `errors[]` | Both required |
| `completed` | `task` or `statusUpdate` | Full success response matching `sync-creatives-response.json` | `creatives` |
| `failed` | `statusUpdate` | `creative_ids[]`, `errors[]` | Both required |
| `working` | `statusUpdate` | `creative_ids[]` | `creative_ids` required |
| `submitted` | N/A (initial response only) | N/A | N/A |

**Important**: `creative_ids` is required in all webhook payloads for `sync_creatives` tool to enable creative identification and correlation with the buyer's internal systems. This applies to all statuses: `input-required`, `failed`, `working`, and `completed`.

**Reference**: See [Webhook Payload Schema](/schemas/v2/core/webhook-payload.json) and [Task Management](/docs/protocols/task-management) for complete webhook handling examples.

## Next Steps

- [list_creative_formats](/docs/media-buy/task-reference/list_creative_formats) - Check supported formats before upload
- [Generative Creatives Guide](/docs/creative/generative-creative) - Generate creatives from brand manifests
- [get_media_buy_delivery](/docs/media-buy/task-reference/get_media_buy_delivery) - Monitor creative performance
- [Creative Asset Types](/docs/creative/asset-types) - Technical requirements for assets
