---
title: get_products
testable: true
---

Discover available advertising products based on campaign requirements using natural language briefs or structured filters.

**Authentication**: Optional (returns limited results without credentials)

**Response Time**: ~60 seconds (AI inference with back-end systems)

**Request Schema**: [`/schemas/v2/media-buy/get-products-request.json`](https://adcontextprotocol.org/schemas/v2/media-buy/get-products-request.json)
**Response Schema**: [`/schemas/v2/media-buy/get-products-response.json`](https://adcontextprotocol.org/schemas/v2/media-buy/get-products-response.json)

## Quick Start

Discover products with a natural language brief:

<CodeGroup>

```javascript JavaScript test=false
import { testAgent } from '@adcp/client/testing';
import { GetProductsResponseSchema } from '@adcp/client';

const result = await testAgent.getProducts({
  buying_mode: 'brief',
  brief: 'Premium athletic footwear with innovative cushioning',
  brand: {
    domain: 'acmecorp.com'
  }
});

if (!result.success) {
  throw new Error(`Request failed: ${result.error}`);
}

// Validate response against schema
const validated = GetProductsResponseSchema.parse(result.data);
console.log(`Found ${validated.products.length} products`);

// Access validated product fields
for (const product of validated.products) {
  console.log(`- ${product.name} (${product.delivery_type})`);
  console.log(`  Formats: ${product.format_ids.map(f => f.id).join(', ')}`);
}
```

```python Python test=false
import asyncio
from adcp.testing import test_agent

async def discover_products():
    result = await test_agent.simple.get_products(
        buying_mode='brief',
        brief='Premium athletic footwear with innovative cushioning',
        brand={
            'domain': 'acmecorp.com'
        }
    )
    print(f"Found {len(result.products)} products")

asyncio.run(discover_products())
```

```bash CLI test=false
uvx adcp \
  https://test-agent.adcontextprotocol.org/mcp \
  get_products \
  '{"buying_mode":"brief","brief":"Premium athletic footwear with innovative cushioning","brand":{"domain":"acmecorp.com"}}' \
  --auth 1v8tAhASaUYYp4odoQ1PnMpdqNaMiTrCRqYo9OJp6IQ
```

</CodeGroup>

### Using Structured Filters

You can also use structured filters instead of (or in addition to) a brief. In `brief` mode, filters act as hard constraints on top of the publisher's curation — the brief describes intent, filters enforce requirements:

<CodeGroup>

```javascript JavaScript test=false
import { testAgent } from '@adcp/client/testing';

const result = await testAgent.getProducts({
  buying_mode: 'wholesale',
  brand: {
    domain: 'acmecorp.com'
  },
  filters: {
    format_types: ['video'],
    delivery_type: 'guaranteed',
    standard_formats_only: true
  }
});

if (result.success && result.data) {
  console.log(`Found ${result.data.products.length} guaranteed video products`);
}
```

```python Python test=false
import asyncio
from adcp.testing import test_agent

async def discover_with_filters():
    result = await test_agent.simple.get_products(
        buying_mode='wholesale',
        brand={
            'domain': 'acmecorp.com'
        },
        filters={
            'format_types': ['video'],
            'delivery_type': 'guaranteed',
            'standard_formats_only': True
        }
    )
    print(f"Found {len(result.products)} guaranteed video products")

asyncio.run(discover_with_filters())
```

</CodeGroup>

## Request Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `buying_mode` | string | Yes | `"brief"`, `"wholesale"`, or `"refine"`. `"brief"`: publisher curates products from the brief. `"wholesale"`: raw inventory for buyer-directed targeting, `brief` must not be provided. `"refine"`: iterate on known products or proposals — requires at least one of `product_ids` or `proposal_id`. Use `requested_changes` to describe what to adjust. |
| `brief` | string | Conditional | Natural language description of campaign requirements. Required when `buying_mode` is `"brief"`. Must not be provided when `buying_mode` is `"wholesale"` or `"refine"`. |
| `requested_changes` | string | No | Natural language description of what to change when refining products or proposals (e.g., `"Increase budget to $200k and narrow to California only"`). Only valid when `buying_mode` is `"refine"`. The seller does not need the original brief — describe only the delta. |
| `product_ids` | string[] | Conditional | Product IDs from a previous `get_products` response. At least one of `product_ids` or `proposal_id` is required when `buying_mode` is `"refine"`. The seller returns these products with updated forecasts, pricing, and package configurations. |
| `proposal_id` | string | Conditional | Proposal ID from a previous `get_products` response. At least one of `product_ids` or `proposal_id` is required when `buying_mode` is `"refine"`. The seller returns an updated proposal with revised forecasts, allocations, and pricing. When combined with `product_ids`, narrows or expands the proposal's product set. |
| `brand` | BrandRef | No | Brand reference (domain + optional brand_id). Resolved to full identity at execution time. |
| `account` | AccountRef | No | Account reference for account-specific pricing. Returns products with pricing from this account's rate card. |
| `buyer_campaign_ref` | string | No | Buyer's campaign label for CRM and ad server correlation (e.g., `"NovaDrink_Meals_Q2"`). Groups related discovery and buy operations. |
| `catalog` | [Catalog](/docs/creative/catalogs) | No | Catalog of items the buyer wants to promote. The seller matches catalog items against its inventory and returns products where matches exist. Requires `brand`. See [Catalog discovery](#catalog-discovery) below. |
| `filters` | Filters | No | Structured filters (see below) |
| `property_list` | PropertyListRef | No | [AdCP 3.0] Reference to a property list for filtering. See [Property Lists](/docs/governance/property/tasks/property_lists) |
| `pagination` | PaginationRequest | No | Cursor-based pagination for large product catalogs (see below) |

### Filters Object

| Parameter | Type | Description |
|-----------|------|-------------|
| `delivery_type` | string | Filter by `"guaranteed"` or `"non_guaranteed"` |
| `is_fixed_price` | boolean | Filter for fixed price vs auction products |
| `format_types` | string[] | *(uses deprecated FormatCategory)* Filter by format types (e.g., `["video", "display"]`). Consider filtering by `format_ids` instead for precise matching. |
| `format_ids` | FormatID[] | Filter by specific format IDs. **Recommended over `format_types`.** |
| `standard_formats_only` | boolean | Only return products accepting IAB standard formats |
| `min_exposures` | integer | Minimum exposures needed for measurement validity |
| `start_date` | string | Campaign start date in ISO 8601 format (YYYY-MM-DD) for availability checks |
| `end_date` | string | Campaign end date in ISO 8601 format (YYYY-MM-DD) for availability checks |
| `budget_range` | object | Budget range to filter appropriate products (see Budget Range Object below) |
| `countries` | string[] | Filter by target countries using ISO 3166-1 alpha-2 codes (case-insensitive, e.g., `["US", "CA", "GB"]`) |
| `channels` | string[] | Filter by advertising channels (e.g., `["display", "ctv", "social", "streaming_audio"]`). See [Media Channel Taxonomy](/docs/reference/media-channel-taxonomy) |

### Budget Range Object

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `currency` | string | Yes | ISO 4217 currency code (e.g., `"USD"`, `"EUR"`, `"GBP"`) |
| `min` | number | No* | Minimum budget amount |
| `max` | number | No* | Maximum budget amount |

*At least one of `min` or `max` must be specified.

### Catalog discovery

Pass a `catalog` to find advertising products that can promote your catalog items. The seller matches your catalog items against its inventory and returns products where matches exist. Supports all catalog types — a product catalog finds sponsored product slots, a job catalog finds job ad products, a flight catalog finds dynamic travel ads.

The `catalog` field uses the same [Catalog](/docs/creative/catalogs) object used throughout AdCP. You can reference a synced catalog by `catalog_id`, provide inline items, or use selectors to filter:

| Field | Type | Description |
|-------|------|-------------|
| `type` | CatalogType | Catalog type (required) — `product`, `job`, `hotel`, `flight`, `offering`, etc. |
| `catalog_id` | string | Reference a synced catalog by ID |
| `ids` | string[] | Filter to specific item IDs |
| `gtins` | string[] | Filter by GTIN for cross-retailer matching (product type only) |
| `tags` | string[] | Filter by tags (OR logic) |
| `category` | string | Filter by category |
| `query` | string | Natural language filter |

Products in the response include `catalog_types` (what catalog types they support) and `catalog_match` (which items matched).

## Response

Returns an array of `products` and optionally `proposals`.

### Products Array

| Field | Type | Description |
|-------|------|-------------|
| `product_id` | string | Unique product identifier |
| `name` | string | Human-readable product name |
| `description` | string | Detailed product description |
| `publisher_properties` | PublisherProperty[] | Array of publisher entries, each with `publisher_domain` and either `property_ids` or `property_tags` |
| `format_ids` | FormatID[] | Supported creative format IDs |
| `delivery_type` | string | `"guaranteed"` or `"non_guaranteed"` |
| `delivery_measurement` | DeliveryMeasurement | How delivery is measured (impressions, views, etc.) |
| `pricing_options` | PricingOption[] | Available pricing models (CPM, CPCV, etc.). Auction options may include `floor_price` and optional `price_guidance`. Bid-based auction models (CPM, vCPM, CPC, CPCV, CPV) may also include optional `max_bid` (boolean). |
| `brief_relevance` | string | Why this product matches the brief (when brief provided) |
| `sample_creatives` | [CreativePreview](/docs/media-buy/product-discovery/media-products#seller-generated-creatives)[] | Sample creative previews the seller generated for this product. Each preview has a `generated_creative_ref` for refinement feedback. Only present when the seller supports `creative_generation`. |
| `total_creatives_count` | integer | Total creatives the seller would generate for the full catalog on this product at execution time. Gives scale context beyond the samples. |

### Proposals Array (Optional)

Publishers may return proposals alongside products - structured media plans with budget allocations. See [Proposals](/docs/media-buy/product-discovery/media-products#proposals) for details.

| Field | Type | Description |
|-------|------|-------------|
| `proposal_id` | string | Unique identifier for executing this proposal via `create_media_buy` |
| `name` | string | Human-readable name for the media plan |
| `allocations` | ProductAllocation[] | Budget allocations across products (percentages must sum to 100) |
| `forecast` | DeliveryForecast | Aggregate delivery forecast for the proposal. Contains forecast points with metric ranges. See [Delivery Forecasts](/docs/media-buy/product-discovery/media-products#delivery-forecasts) |
| `total_budget_guidance` | object | Optional min/recommended/max budget guidance |
| `brief_alignment` | string | How this proposal addresses the campaign brief |
| `expires_at` | string | ISO 8601 timestamp when this proposal expires |

### Pagination

For large product catalogs, use cursor-based pagination:

| Request Parameter | Type | Description |
|---|---|---|
| `pagination.max_results` | integer | Maximum products per page (1-100, default: 50) |
| `pagination.cursor` | string | Cursor from previous response for next page |

| Response Field | Type | Description |
|---|---|---|
| `pagination.has_more` | boolean | Whether more products are available |
| `pagination.cursor` | string | Cursor to pass for the next page |
| `pagination.total_count` | integer | Total matching products (optional, not all backends support this) |

Pagination is optional. When omitted, the server returns all results (or a server-chosen default page). When the response includes `pagination.has_more: true`, pass `pagination.cursor` in the next request to get the next page.

### Response Metadata

| Field | Type | Description |
|-------|------|-------------|
| `property_list_applied` | boolean | [AdCP 3.0] `true` if the agent filtered products based on the provided `property_list`. Absent or `false` if not provided or not supported. |
| `catalog_applied` | boolean | `true` if the seller filtered results based on the provided `catalog`. Absent or `false` if no catalog was provided or the seller does not support catalog matching. |

**See schema for complete field list**: [`get-products-response.json`](https://adcontextprotocol.org/schemas/v2/media-buy/get-products-response.json)

## Common Scenarios

### Standard Catalog Discovery

<CodeGroup>

```javascript JavaScript test=false
import { testAgent } from '@adcp/client/testing';

// wholesale mode: buyer applies their own audiences, no publisher curation
const result = await testAgent.getProducts({
  buying_mode: 'wholesale',
  brand: {
    domain: 'acmecorp.com'
  },
  filters: {
    delivery_type: 'non_guaranteed'
  }
});

if (result.success && result.data) {
  console.log(`Found ${result.data.products.length} standard catalog products`);
}
```

```python Python test=false
import asyncio
from adcp.testing import test_agent

async def discover_standard_catalog():
    # wholesale mode: buyer applies their own audiences, no publisher curation
    result = await test_agent.simple.get_products(
        buying_mode='wholesale',
        brand={
            'domain': 'acmecorp.com'
        },
        filters={
            'delivery_type': 'non_guaranteed'
        }
    )
    print(f"Found {len(result.products)} standard catalog products")

asyncio.run(discover_standard_catalog())
```

</CodeGroup>

### Multi-Format Discovery

<CodeGroup>

```javascript JavaScript test=false
import { testAgent } from '@adcp/client/testing';

// Find products supporting both video and display
const result = await testAgent.getProducts({
  buying_mode: 'brief',
  brief: 'Brand awareness campaign with video and display',
  brand: {
    domain: 'acmecorp.com'
  },
  filters: {
    format_types: ['video', 'display']
  }
});

if (result.success && result.data) {
  console.log(`Found ${result.data.products.length} products supporting video and display`);
}
```

```python Python test=false
import asyncio
from adcp.testing import test_agent

async def discover_multi_format():
    # Find products supporting both video and display
    result = await test_agent.simple.get_products(
        buying_mode='brief',
        brief='Brand awareness campaign with video and display',
        brand={
            'domain': 'acmecorp.com'
        },
        filters={
            'format_types': ['video', 'display']
        }
    )
    print(f"Found {len(result.products)} products supporting video and display")

asyncio.run(discover_multi_format())
```

</CodeGroup>

### Budget and Date Filtering

<CodeGroup>

```javascript JavaScript test=false
import { testAgent } from '@adcp/client/testing';

// Find products within budget and date range for specific countries and channels
const result = await testAgent.getProducts({
  buying_mode: 'brief',
  brief: 'Q2 campaign for athletic footwear in North America',
  brand: {
    domain: 'acmecorp.com'
  },
  filters: {
    start_date: '2025-04-01',
    end_date: '2025-06-30',
    budget_range: {
      min: 50000,
      max: 100000,
      currency: 'USD'
    },
    countries: ['US', 'CA'],
    channels: ['display', 'ctv', 'podcast'],
    delivery_type: 'guaranteed'
  }
});

if (result.success && result.data) {
  console.log(`Found ${result.data.products.length} products for Q2 within budget`);
}
```

```python Python test=false
import asyncio
from adcp.testing import test_agent

async def discover_with_budget_and_dates():
    # Find products within budget and date range for specific countries and channels
    result = await test_agent.simple.get_products(
        buying_mode='brief',
        brief='Q2 campaign for athletic footwear in North America',
        brand={
            'domain': 'acmecorp.com'
        },
        filters={
            'start_date': '2025-04-01',
            'end_date': '2025-06-30',
            'budget_range': {
                'min': 50000,
                'max': 100000,
                'currency': 'USD'
            },
            'countries': ['US', 'CA'],
            'channels': ['display', 'ctv', 'podcast'],
            'delivery_type': 'guaranteed'
        }
    )
    print(f"Found {len(result.products)} products for Q2 within budget")

asyncio.run(discover_with_budget_and_dates())
```

</CodeGroup>

### Property Tag Resolution

<CodeGroup>

```javascript JavaScript test=false
import { testAgent } from '@adcp/client/testing';

// Get products with property tags
const result = await testAgent.getProducts({
  buying_mode: 'brief',
  brief: 'Sports content',
  brand: {
    domain: 'acmecorp.com'
  }
});

if (result.success && result.data) {
  // Products with property_tags in publisher_properties represent large networks
  // Use get_adcp_capabilities to discover the agent's portfolio
  const productsWithTags = result.data.products.filter(p =>
    p.publisher_properties?.some(pub => pub.property_tags && pub.property_tags.length > 0)
  );
  console.log(`${productsWithTags.length} products use property tags (large networks)`);
}
```

```python Python test=false
import asyncio
from adcp.testing import test_agent

async def discover_property_tags():
    # Get products with property tags
    result = await test_agent.simple.get_products(
        buying_mode='brief',
        brief='Sports content',
        brand={
            'domain': 'acmecorp.com'
        }
    )

    # Products with property_tags in publisher_properties represent large networks
    # Use get_adcp_capabilities to discover the agent's portfolio
    products_with_tags = [p for p in result.products
        if any(pub.get('property_tags') for pub in p.get('publisher_properties', []))]
    print(f"{len(products_with_tags)} products use property tags (large networks)")

asyncio.run(discover_property_tags())
```

</CodeGroup>

### Guaranteed Delivery Products

<CodeGroup>

```javascript JavaScript test=false
import { testAgent } from '@adcp/client/testing';

// Find guaranteed delivery products for measurement
const result = await testAgent.getProducts({
  buying_mode: 'brief',
  brief: 'Guaranteed delivery for lift study',
  brand: {
    domain: 'acmecorp.com'
  },
  filters: {
    delivery_type: 'guaranteed',
    min_exposures: 100000
  }
});

if (result.success && result.data) {
  console.log(`Found ${result.data.products.length} guaranteed products with 100k+ exposures`);
}
```

```python Python test=false
import asyncio
from adcp.testing import test_agent

async def discover_guaranteed():
    # Find guaranteed delivery products for measurement
    result = await test_agent.simple.get_products(
        buying_mode='brief',
        brief='Guaranteed delivery for lift study',
        brand={
            'domain': 'acmecorp.com'
        },
        filters={
            'delivery_type': 'guaranteed',
            'min_exposures': 100000
        }
    )
    print(f"Found {len(result.products)} guaranteed products with 100k+ exposures")

asyncio.run(discover_guaranteed())
```

</CodeGroup>

### Standard Formats Only

<CodeGroup>

```javascript JavaScript test=false
import { testAgent } from '@adcp/client/testing';

// Find products that only accept IAB standard formats
const result = await testAgent.getProducts({
  buying_mode: 'wholesale',
  brand: {
    domain: 'acmecorp.com'
  },
  filters: {
    standard_formats_only: true
  }
});

if (result.success && result.data) {
  console.log(`Found ${result.data.products.length} products with standard formats only`);
}
```

```python Python test=false
import asyncio
from adcp.testing import test_agent

async def discover_standard_formats():
    # Find products that only accept IAB standard formats
    result = await test_agent.simple.get_products(
        buying_mode='wholesale',
        brand={
            'domain': 'acmecorp.com'
        },
        filters={
            'standard_formats_only': True
        }
    )
    print(f"Found {len(result.products)} products with standard formats only")

asyncio.run(discover_standard_formats())
```

</CodeGroup>

### Catalog-driven discovery

Use `catalog` with a brand to discover advertising products that can promote your catalog items. The seller matches your items against its inventory and returns products where matches exist:

<CodeGroup>

```javascript JavaScript test=false
import { testAgent } from '@adcp/client/testing';

// Discover retail media products for specific catalog items
const result = await testAgent.getProducts({
  buying_mode: 'wholesale',
  brand: {
    domain: 'acmecorp.com'
  },
  catalog: {
    type: 'product',
    tags: ['ketchup', 'organic'],
    category: 'food/condiments'
  },
  filters: {
    channels: ['retail_media']
  }
});

if (result.success && result.data) {
  if (result.data.catalog_applied) {
    console.log(`Found ${result.data.products.length} products with catalog matches`);
  } else {
    console.log('Seller does not support catalog matching');
  }
}
```

```python Python test=false
import asyncio
from adcp.testing import test_agent

async def discover_commerce_products():
    # Discover retail media products for specific catalog items
    result = await test_agent.simple.get_products(
        buying_mode='wholesale',
        brand={
            'domain': 'acmecorp.com'
        },
        catalog={
            'type': 'product',
            'tags': ['ketchup', 'organic'],
            'category': 'food/condiments'
        },
        filters={
            'channels': ['retail_media']
        }
    )
    if result.get('catalog_applied'):
        print(f"Found {len(result.products)} products with catalog matches")
    else:
        print("Seller does not support catalog matching")

asyncio.run(discover_commerce_products())
```

```bash CLI test=false
uvx adcp \
  https://test-agent.adcontextprotocol.org/mcp \
  get_products \
  '{"buying_mode":"wholesale","brand":{"domain":"acmecorp.com"},"catalog":{"type":"product","tags":["ketchup","organic"],"category":"food/condiments"},"filters":{"channels":["retail_media"]}}' \
  --auth 1v8tAhASaUYYp4odoQ1PnMpdqNaMiTrCRqYo9OJp6IQ
```

</CodeGroup>

You can also use GTIN matching, reference a synced catalog, or discover products for other catalog types:

```json
{
  "catalog": {
    "type": "product",
    "gtins": ["00013000006040", "00013000006057"]
  }
}
```

```json
{
  "catalog": {
    "catalog_id": "gmc-primary",
    "type": "product"
  }
}
```

```json
{
  "catalog": {
    "type": "job",
    "catalog_id": "chef-vacancies"
  }
}
```

### Property List Filtering

<Info>
**AdCP 3.0** - Property list filtering requires governance agent support.
</Info>

Filter products to only those available on properties in your approved list:

<CodeGroup>

```javascript JavaScript test=false
import { testAgent } from '@adcp/client/testing';

// Filter products by property list from governance agent
const result = await testAgent.getProducts({
  buying_mode: 'brief',
  brief: 'Brand-safe inventory for family brand',
  brand: {
    domain: 'acmecorp.com'
  },
  property_list: {
    agent_url: 'https://governance.example.com',
    list_id: 'pl_brand_safe_2024'
  }
});

if (result.success && result.data) {
  // Check if filtering was actually applied
  if (result.data.property_list_applied) {
    console.log(`Found ${result.data.products.length} products on approved properties`);
  } else {
    console.log('Agent does not support property list filtering');
    console.log(`Found ${result.data.products.length} products (unfiltered)`);
  }
}
```

```python Python test=false
import asyncio
from adcp.testing import test_agent

async def discover_with_property_list():
    # Filter products by property list from governance agent
    result = await test_agent.simple.get_products(
        buying_mode='brief',
        brief='Brand-safe inventory for family brand',
        brand={
            'domain': 'acmecorp.com'
        },
        property_list={
            'agent_url': 'https://governance.example.com',
            'list_id': 'pl_brand_safe_2024'
        }
    )

    # Check if filtering was actually applied
    if result.get('property_list_applied'):
        print(f"Found {len(result['products'])} products on approved properties")
    else:
        print("Agent does not support property list filtering")
        print(f"Found {len(result['products'])} products (unfiltered)")

asyncio.run(discover_with_property_list())
```

</CodeGroup>

**Note**: If `property_list_applied` is absent or `false`, the sales agent did not filter products. This can happen if:
- The agent doesn't support property governance features
- The agent couldn't access the property list
- The property list had no effect on the available inventory

#### Property Targeting Behavior

Products have a `property_targeting_allowed` flag that affects filtering:

- **`property_targeting_allowed: false` (default)**: Product is "all or nothing" - excluded unless your list contains all of its properties
- **`property_targeting_allowed: true`**: Product is included if there's any intersection between its properties and your list

This allows publishers to offer run-of-network products that can't be cherry-picked alongside flexible inventory that buyers can filter.

See [Property Targeting](/docs/media-buy/product-discovery/media-products#property-targeting) for more details and [Property Governance](/docs/governance/property/specification) for more on property lists.

## Refinement

After initial discovery, use `buying_mode: "refine"` to iterate on known products or proposals. The seller skips discovery and returns updated forecasts, pricing, and package configurations reflecting your new parameters. Pass `product_ids`, `proposal_id`, or both. If the referenced products or proposal can't be found, the seller returns `PRODUCT_NOT_FOUND` or `PROPOSAL_EXPIRED` — see [Error handling](#error-handling).

### Refine products

Use `requested_changes` to describe what to adjust — the seller does not need the original brief. Filters contain absolute values (not deltas), so `budget_range` is the new target budget:

```json test=false
{
  "buying_mode": "refine",
  "product_ids": ["prod_premium_video", "prod_display_run_of_site"],
  "requested_changes": "Increase budget to $200k, narrow to California and New York only",
  "filters": {
    "start_date": "2026-04-01",
    "end_date": "2026-04-30",
    "budget_range": { "min": 200000, "max": 200000, "currency": "USD" }
  }
}
```

### Refine a proposal

```json test=false
{
  "buying_mode": "refine",
  "proposal_id": "prop_awareness_q2",
  "requested_changes": "Shift more budget toward video, extend through May",
  "filters": {
    "start_date": "2026-04-01",
    "end_date": "2026-05-31",
    "budget_range": { "min": 300000, "max": 300000, "currency": "USD" }
  }
}
```

### Refresh forecasts

To refresh forecasts and pricing without changing anything, pass only `product_ids`:

```json test=false
{
  "buying_mode": "refine",
  "product_ids": ["prod_premium_video", "prod_display_run_of_site"]
}
```

The seller returns the same products with up-to-date availability, forecasts, and pricing.

### Combining product_ids and proposal_id

When both `product_ids` and `proposal_id` are provided, `product_ids` narrow or expand the proposal's product set. The seller returns an updated proposal reflecting only the specified products with revised allocations and forecasts.

### Notes

- **`product_ids`, `proposal_id`, and `requested_changes` are only valid in `refine` mode.** Requests that include these fields in `brief` or `wholesale` mode are rejected with `INVALID_REQUEST`.
- **Proposals are ephemeral.** Proposals typically include an `expires_at` timestamp. After expiration, the seller returns `PROPOSAL_EXPIRED`. Re-discover with a new `brief` request to get a fresh proposal. Proposals without `expires_at` remain valid until the seller invalidates them.
- **Product IDs are stable catalog identifiers.** They reference the seller's inventory and are validated at request time. You can refine products from a previous call — even from a different brief — and the seller will confirm eligibility against the current request context. Custom products (`is_custom: true`) may have an `expires_at` timestamp, after which refinement returns `PRODUCT_NOT_FOUND`.

The response uses the same format as discovery. Each product reflects the updated parameters — adjusted delivery forecasts, revised pricing options, and any package or allocation changes the seller recommends based on `requested_changes` and filters. Call refine as many times as needed before committing to a `create_media_buy`.

## Seller-generated creatives

Some sellers generate creatives from the buyer's catalog and brand assets — for example, dynamic job ads from a jobs catalog, or sponsored product cards from a product feed. When a seller supports this (declared via `media_buy.creative_generation` in [`get_adcp_capabilities`](/docs/protocol/get_adcp_capabilities)), products in the response may include `sample_creatives` — representative previews showing how ads would render.

### Discovery with creative previews

Include a `catalog` and `brand` in your brief request. The seller matches catalog items to products and generates sample creatives:

```json test=false
{
  "buying_mode": "brief",
  "brief": "Sponsored jobs campaign for software engineers in California. Corporate tone, emphasize salary and remote work options.",
  "brand": { "domain": "acmecorp.com" },
  "catalog": { "type": "job", "catalog_id": "eng-roles-q2" }
}
```

Products in the response include `sample_creatives` with preview renders and a `total_creatives_count` indicating the full catalog scale:

```json test=false
{
  "products": [
    {
      "product_id": "sponsored_job_listing",
      "name": "Sponsored job listing",
      "description": "Promoted job cards in search results and recommendations",
      "format_ids": [{ "agent_url": "https://seller.example.com", "id": "job_card_standard" }],
      "catalog_types": ["job"],
      "sample_creatives": [
        {
          "generated_creative_ref": "gen_sr_eng_sf",
          "format_id": { "agent_url": "https://seller.example.com", "id": "job_card_standard" },
          "renders": [{
            "render_id": "r1",
            "output_format": "url",
            "preview_url": "https://seller.example.com/previews/abc123",
            "role": "primary",
            "dimensions": { "width": 600, "height": 300 }
          }],
          "catalog_item_ref": "job_sr_eng_sf",
          "description": "Senior Engineer role card with salary range and remote badge"
        },
        {
          "generated_creative_ref": "gen_staff_eng_la",
          "format_id": { "agent_url": "https://seller.example.com", "id": "job_card_standard" },
          "renders": [{
            "render_id": "r2",
            "output_format": "url",
            "preview_url": "https://seller.example.com/previews/def456",
            "role": "primary",
            "dimensions": { "width": 600, "height": 300 }
          }],
          "catalog_item_ref": "job_staff_eng_la",
          "description": "Staff Engineer role card highlighting equity package"
        }
      ],
      "total_creatives_count": 23
    }
  ]
}
```

### Refining creative direction

Use `buying_mode: "refine"` with `product_ids` and reference specific previews by `generated_creative_ref` in `requested_changes`:

```json test=false
{
  "buying_mode": "refine",
  "product_ids": ["sponsored_job_listing"],
  "requested_changes": "gen_sr_eng_sf is good. gen_staff_eng_la needs shorter headline and more prominent salary range. Use the dark logo variant on all creatives."
}
```

The seller returns updated `sample_creatives` reflecting the feedback. Refine as many times as needed before committing.

### Executing

When satisfied with the previews, commit via `create_media_buy`. The seller generates the full creative set at execution time:

```json test=false
{
  "buyer_ref": "eng_jobs_q2",
  "proposal_id": "prop_eng_jobs",
  "total_budget": { "amount": 25000, "currency": "USD" },
  "brand": { "domain": "acmecorp.com" },
  "account": { "account_id": "acc_123" },
  "start_time": "2026-04-01T00:00:00Z",
  "end_time": "2026-04-30T23:59:59Z"
}
```

## Error Handling

| Error Code | Description | Resolution |
|------------|-------------|------------|
| `AUTH_REQUIRED` | Authentication needed for full catalog | Provide credentials via auth header |
| `INVALID_REQUEST` | Brief too long or malformed filters | Check request parameters |
| `PRODUCT_NOT_FOUND` | One or more `product_ids` are unknown or were never valid | Remove invalid IDs and retry, or re-discover with `get_products` |
| `PROPOSAL_EXPIRED` | The referenced `proposal_id` has passed its `expires_at` timestamp | Re-discover products with a new `brief` or `wholesale` request |
| `POLICY_VIOLATION` | Category blocked for advertiser | See policy response message for details |

### Authentication Comparison

See the difference between authenticated and unauthenticated access:

<CodeGroup>

```javascript JavaScript test=false
import { testAgent, testAgentNoAuth } from '@adcp/client/testing';

// WITH authentication - full catalog with pricing
const fullCatalog = await testAgent.getProducts({
  buying_mode: 'brief',
  brief: 'Premium CTV inventory for brand awareness',
  brand: {
    domain: 'acmecorp.com'
  }
});

if (!fullCatalog.success) {
  throw new Error(`Failed to get products: ${fullCatalog.error}`);
}

console.log(`With auth: ${fullCatalog.data.products.length} products`);
console.log(`First product pricing: ${fullCatalog.data.products[0].pricing_options.length} options`);

// WITHOUT authentication - limited public catalog
const publicCatalog = await testAgentNoAuth.getProducts({
  buying_mode: 'brief',
  brief: 'Premium CTV inventory for brand awareness',
  brand: {
    domain: 'acmecorp.com'
  }
});

if (!publicCatalog.success) {
  throw new Error(`Failed to get products: ${publicCatalog.error}`);
}

console.log(`Without auth: ${publicCatalog.data.products.length} products`);
console.log(`First product pricing: ${publicCatalog.data.products[0].pricing_options?.length || 0} options`);
```

```python Python test=false
import asyncio
from adcp.testing import test_agent, test_agent_no_auth

async def compare_auth():
    # WITH authentication - full catalog with pricing
    full_catalog = await test_agent.simple.get_products(
        buying_mode='brief',
        brief='Premium CTV inventory for brand awareness',
        brand={
            'domain': 'acmecorp.com'
        }
    )

    print(f"With auth: {len(full_catalog['products'])} products")
    print(f"First product pricing: {len(full_catalog['products'][0]['pricing_options'])} options")

    # WITHOUT authentication - limited public catalog
    public_catalog = await test_agent_no_auth.simple.get_products(
        buying_mode='brief',
        brief='Premium CTV inventory for brand awareness',
        brand={
            'domain': 'acmecorp.com'
        }
    )

    print(f"Without auth: {len(public_catalog['products'])} products")
    print(f"First product pricing: {len(public_catalog['products'][0].get('pricing_options', []))} options")

asyncio.run(compare_auth())
```

</CodeGroup>

**Key Differences:**
- **Product Count**: Authenticated access returns more products, including private/custom offerings
- **Pricing Information**: Only authenticated requests receive detailed pricing options (CPM, CPCV, etc.)
- **Targeting Details**: Custom targeting capabilities may be restricted to authenticated users
- **Rate Limits**: Unauthenticated requests have lower rate limits

## Authentication Behavior

- **Without credentials**: Returns limited catalog (standard catalog products), no pricing, no custom offerings
- **With credentials**: Returns complete catalog with pricing and custom products

See [Authentication Guide](/docs/building/integration/authentication) for details.

## Asynchronous Operations

Most product searches complete immediately, but some scenarios require asynchronous processing. When this happens, you'll receive a status other than `completed` and can track progress through webhooks or polling.

### When Search Runs Asynchronously

Product search may require async processing in these situations:

- **Complex searches**: Searching across multiple inventory sources or custom curation
- **Needs clarification**: Your brief is vague and the system needs more information
- **Custom products**: Bespoke product packages that require human review

### Async Status Flow

<Tabs>
<Tab title="MCP">

#### Immediate Completion (Most Common)

```json
POST /api/mcp/call_tool

{
  "name": "get_products",
  "arguments": {
    "buying_mode": "brief",
    "brief": "CTV inventory for sports audience",
    "brand": { "domain": "acmecorp.com" }
  }
}

Response (200 OK):
{
  "status": "completed",
  "message": "Found 3 products matching your requirements",
  "products": [...]
}
```

#### Needs Clarification

When the brief is unclear, the system asks for more details:

```json
Response (200 OK):
{
  "status": "input-required",
  "message": "I need a bit more information. What's your budget range and campaign duration?",
  "task_id": "task_789",
  "context_id": "ctx_123",
  "reason": "CLARIFICATION_NEEDED",
  "partial_results": [],
  "suggestions": ["$50K-$100K", "1 month", "Q1 2024"]
}
```

Continue the conversation with the same `context_id`:

```json
POST /api/mcp/continue

{
  "context_id": "ctx_123",
  "message": "Budget is $75K for a 3-week campaign in March"
}

Response (200 OK):
{
  "status": "completed",
  "message": "Perfect! Found 5 products within your budget",
  "products": [...]
}
```

#### Complex Search (With Webhook)

For searches requiring deep inventory analysis, configure a webhook:

```json
POST /api/mcp/call_tool

{
  "name": "get_products",
  "arguments": {
    "buying_mode": "brief",
    "brief": "Premium inventory across all formats for luxury automotive brand",
    "brand": { "domain": "acmecorp.com" },
    "pushNotificationConfig": {
      "url": "https://buyer.com/webhooks/adcp/get_products",
      "authentication": {
        "schemes": ["Bearer"],
        "credentials": "secret_token_32_chars"
      }
    }
  }
}

Response (200 OK):
{
  "status": "working",
  "message": "Searching premium inventory across display, video, and audio",
  "task_id": "task_456",
  "context_id": "ctx_123",
  "percentage": 10,
  "current_step": "searching_inventory"
}

// Later, webhook POST to https://buyer.com/webhooks/adcp/get_products
{
  "task_id": "task_456",
  "task_type": "get_products",
  "status": "completed",
  "timestamp": "2025-01-22T10:30:00Z",
  "message": "Found 12 premium products across all formats",
  "result": {
    "products": [...]
  }
}
```

</Tab>
<Tab title="A2A">

#### Immediate Completion (Most Common)

```json
POST /api/a2a

{
  "message": {
    "role": "user",
    "parts": [{
      "kind": "data",
      "data": {
        "skill": "get_products",
        "parameters": {
          "buying_mode": "brief",
          "brief": "CTV inventory for sports audience",
          "brand": { "domain": "acmecorp.com" }
        }
      }
    }]
  }
}

Response (200 OK):
{
  "id": "task_123",
  "contextId": "ctx_456",
  "artifact": {
    "kind": "data",
    "data": {
      "products": [...]
    }
  },
  "status": {
    "state": "completed",
    "message": {
      "role": "agent",
      "parts": [{ "text": "Found 3 products matching your requirements" }]
    }
  }
}
```

#### Needs Clarification

Real-time updates via SSE when clarification is needed:

```json
// Initial response
{
  "id": "task_789",
  "contextId": "ctx_123",
  "status": {
    "state": "input-required",
    "message": {
      "role": "agent",
      "parts": [
        { "text": "I need a bit more information. What's your budget range and campaign duration?" },
        {
          "data": {
            "reason": "CLARIFICATION_NEEDED",
            "suggestions": ["$50K-$100K", "1 month", "Q1 2024"]
          }
        }
      ]
    }
  }
}

// Send follow-up
POST /api/a2a

{
  "contextId": "ctx_123",
  "message": {
    "role": "user",
    "parts": [{ "text": "Budget is $75K for a 3-week campaign in March" }]
  }
}

// SSE update: task completed
{
  "id": "task_789",
  "contextId": "ctx_123",
  "artifact": {
    "kind": "data",
    "data": { "products": [...] }
  },
  "status": {
    "state": "completed",
    "message": {
      "role": "agent",
      "parts": [{ "text": "Perfect! Found 5 products within your budget" }]
    }
  }
}
```

#### Complex Search (With Webhook)

Configure push notifications for long searches:

```json
POST /api/a2a

{
  "message": {
    "role": "user",
    "parts": [{
      "kind": "data",
      "data": {
        "skill": "get_products",
        "parameters": {
          "buying_mode": "brief",
          "brief": "Premium inventory across all formats for luxury automotive brand",
          "brand": { "domain": "acmecorp.com" }
        }
      }
    }]
  },
  "pushNotificationConfig": {
    "url": "https://buyer.com/webhooks/a2a/get_products",
    "authentication": {
      "schemes": ["bearer"],
      "credentials": "secret_token_32_chars"
    }
  }
}

Response (200 OK):
{
  "id": "task_456",
  "contextId": "ctx_789",
  "status": {
    "state": "working",
    "message": {
      "role": "agent",
      "parts": [
        { "text": "Searching premium inventory across display, video, and audio" },
        {
          "data": {
            "percentage": 10,
            "current_step": "searching_inventory"
          }
        }
      ]
    }
  }
}

// Later, webhook POST to https://buyer.com/webhooks/a2a/get_products
{
  "id": "task_456",
  "contextId": "ctx_789",
  "artifact": {
    "kind": "data",
    "data": {
      "products": [...]
    }
  },
  "status": {
    "state": "completed",
    "message": {
      "role": "agent",
      "parts": [
        { "text": "Found 12 premium products across all formats" },
        {
          "data": {
            "products": [...]
          }
        }
      ]
    },
    "timestamp": "2025-01-22T10:30:00Z"
  }
}
```

</Tab>
</Tabs>

### Status Overview

| Status | When It Happens | What You Do |
|--------|----------------|-------------|
| `completed` | Search finished successfully | Process the product results |
| `input-required` | Need clarification on the brief | Answer the question and continue |
| `working` | Searching across multiple sources | Wait for webhook or poll for updates |
| `submitted` | Custom curation queued | Wait for webhook notification |
| `failed` | Search couldn't complete | Check error message, adjust brief |

**Note:** For the complete status list see [Task Lifecycle](/docs/building/implementation/task-lifecycle).

**Most searches complete immediately.** Async processing is only needed for complex scenarios or when the system needs your input.

## Next Steps

After discovering products:

1. **Review Options**: Compare products, pricing, and targeting capabilities
2. **Create Media Buy**: Use [`create_media_buy`](/docs/media-buy/task-reference/create_media_buy) to execute campaign
3. **Prepare Creatives**: Use [`list_creative_formats`](/docs/media-buy/task-reference/list_creative_formats) to see format requirements
4. **Upload Assets**: Use [`sync_creatives`](/docs/media-buy/task-reference/sync_creatives) to provide creative assets

## Learn More

- [Product Discovery Guide](/docs/media-buy/product-discovery/) - Understanding briefs and products
- [Pricing Models](/docs/media-buy/advanced-topics/pricing-models) - CPM, CPCV, CPP explained
- [Brief Expectations](/docs/media-buy/product-discovery/brief-expectations) - How to write effective briefs
- [Media Products](/docs/media-buy/product-discovery/media-products) - Product structure and fields
