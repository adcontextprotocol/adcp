---
title: update_media_buy
sidebar_position: 8
testable: true
---

# update_media_buy

Modify an existing media buy using PATCH semantics. Supports campaign-level and package-level updates.

**Response Time**: Instant to days (status: `completed`, `working` < 120s, or `submitted` for manual review)

**PATCH Semantics**: Only specified fields are updated; omitted fields remain unchanged.

**Request Schema**: [`/schemas/v2/media-buy/update-media-buy-request.json`](https://adcontextprotocol.org/schemas/v2/media-buy/update-media-buy-request.json)
**Response Schema**: [`/schemas/v2/media-buy/update-media-buy-response.json`](https://adcontextprotocol.org/schemas/v2/media-buy/update-media-buy-response.json)

## Quick Start

Pause an entire campaign:

<CodeGroup>

```javascript JavaScript
import { testAgent } from '@adcp/client/testing';

const result = await testAgent.updateMediaBuy({
  buyer_ref: 'summer_campaign_2025',
  paused: true
});

// Check for errors (discriminated union response)
if (result.errors) {
  console.error('Update failed:', result.errors);
} else {
  console.log(`Campaign ${result.media_buy_id} paused`);
  if (result.implementation_date) {
    console.log(`Changes take effect: ${result.implementation_date}`);
  }
}
```

```python Python
import asyncio
from adcp import test_agent

async def pause_campaign():
    result = await test_agent.simple.update_media_buy(
        buyer_ref='summer_campaign_2025',
        paused=True
    )

    # Check for errors (discriminated union response)
    if hasattr(result, 'errors') and result.errors:
        print('Update failed:', result.errors)
    else:
        print(f"Campaign {result.media_buy_id} paused")
        if result.implementation_date:
            print(f"Changes take effect: {result.implementation_date}")

asyncio.run(pause_campaign())
```

</CodeGroup>

## Request Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `media_buy_id` | string | Yes* | Publisher's media buy identifier to update |
| `buyer_ref` | string | Yes* | Your reference for the media buy to update |
| `start_time` | string | No | Updated campaign start time |
| `end_time` | string | No | Updated campaign end time |
| `paused` | boolean | No | Pause/resume entire media buy (`true` = paused, `false` = active) |
| `packages` | PackageUpdate[] | No | Package-level updates (see below) |
| `creatives` | CreativeAsset[] | No | Upload and assign new creative assets inline |
| `creative_assignments` | CreativeAssignment[] | No | Update creative rotation weights and placement targeting |

*Either `media_buy_id` OR `buyer_ref` is required (not both)

### Package Update Object

| Parameter | Type | Description |
|-----------|------|-------------|
| `package_id` | string | Publisher's package identifier to update |
| `buyer_ref` | string | Your reference for the package to update |
| `paused` | boolean | Pause/resume specific package (`true` = paused, `false` = active) |
| `budget` | number | Updated budget allocation |
| `pacing` | string | Updated pacing strategy |
| `bid_price` | number | Updated bid price (auction products only) |
| `targeting_overlay` | TargetingOverlay | Updated targeting restrictions |
| `creative_ids` | string[] | Replace assigned creatives |

*Either `package_id` OR `buyer_ref` is required for each package update

## Response

### Success Response

| Field | Description |
|-------|-------------|
| `media_buy_id` | Media buy identifier |
| `buyer_ref` | Your reference identifier |
| `implementation_date` | ISO 8601 timestamp when changes take effect (null if pending approval) |
| `affected_packages` | Array of full Package objects showing complete state after update |

### Error Response

| Field | Description |
|-------|-------------|
| `errors` | Array of error objects explaining failure |

**Note**: Responses use discriminated unions - you get either success fields OR errors, never both. Always check for `errors` before accessing success fields.

## Common Scenarios

### Update Package Budget

Increase budget for a specific package:

<CodeGroup>

```javascript JavaScript
import { testAgent } from '@adcp/client/testing';

const result = await testAgent.updateMediaBuy({
  buyer_ref: 'summer_campaign_2025',
  packages: [{
    buyer_ref: 'ctv_package',
    budget: 50000  // Increased from 30000
  }]
});

console.log('Full response:', JSON.stringify(result, null, 2));

if (result.errors) {
  console.error('Update failed:', result.errors);
} else {
  const pkg = result.affected_packages[0];
  console.log(`Package budget updated to ${pkg.budget}`);
}
```

```python Python
import asyncio
from adcp import test_agent

async def increase_budget():
    result = await test_agent.simple.update_media_buy(
        buyer_ref='summer_campaign_2025',
        packages=[{
            'buyer_ref': 'ctv_package',
            'budget': 50000
        }]
    )

    if hasattr(result, 'errors') and result.errors:
        print('Update failed:', result.errors)
    else:
        pkg = result.affected_packages[0]
        print(f"Package budget updated to {pkg.budget}")

asyncio.run(increase_budget())
```

</CodeGroup>

### Change Campaign Dates

Extend campaign end date:

<CodeGroup>

```javascript JavaScript
import { testAgent } from '@adcp/client/testing';

const result = await testAgent.updateMediaBuy({
  buyer_ref: 'summer_campaign_2025',
  end_time: '2025-09-30T23:59:59Z'
});

if (result.errors) {
  console.error('Update failed:', result.errors);
} else {
  console.log('Campaign end date extended');
  console.log(`Effective: ${result.implementation_date}`);
}
```

```python Python
import asyncio
from adcp import test_agent

async def extend_campaign():
    result = await test_agent.simple.update_media_buy(
        buyer_ref='summer_campaign_2025',
        end_time='2025-09-30T23:59:59Z'
    )

    if hasattr(result, 'errors') and result.errors:
        print('Update failed:', result.errors)
    else:
        print('Campaign end date extended')
        print(f"Effective: {result.implementation_date}")

asyncio.run(extend_campaign())
```

</CodeGroup>

### Update Targeting

Add or modify geographic restrictions:

<CodeGroup>

```javascript JavaScript
import { testAgent } from '@adcp/client/testing';

const result = await testAgent.updateMediaBuy({
  buyer_ref: 'summer_campaign_2025',
  packages: [{
    buyer_ref: 'ctv_package',
    targeting_overlay: {
      geo_country_any_of: ['US', 'CA'],
      geo_region_any_of: ['CA', 'NY', 'TX', 'ON', 'QC']
    }
  }]
});

if (result.errors) {
  console.error('Update failed:', result.errors);
} else {
  console.log('Targeting updated successfully');
}
```

```python Python
import asyncio
from adcp import test_agent

async def update_targeting():
    result = await test_agent.simple.update_media_buy(
        buyer_ref='summer_campaign_2025',
        packages=[{
            'buyer_ref': 'ctv_package',
            'targeting_overlay': {
                'geo_country_any_of': ['US', 'CA'],
                'geo_region_any_of': ['CA', 'NY', 'TX', 'ON', 'QC']
            }
        }]
    )

    if hasattr(result, 'errors') and result.errors:
        print('Update failed:', result.errors)
    else:
        print('Targeting updated successfully')

asyncio.run(update_targeting())
```

</CodeGroup>

### Replace Creatives

Swap out creative assets for a package:

<CodeGroup>

```javascript JavaScript
import { testAgent } from '@adcp/client/testing';

const result = await testAgent.updateMediaBuy({
  buyer_ref: 'summer_campaign_2025',
  packages: [{
    buyer_ref: 'ctv_package',
    creative_ids: ['creative_video_v2', 'creative_display_v2']
  }]
});

if (result.errors) {
  console.error('Update failed:', result.errors);
} else {
  const assignments = result.affected_packages[0].creative_assignments;
  console.log(`Assigned ${assignments.length} new creatives`);
}
```

```python Python
import asyncio
from adcp import test_agent

async def replace_creatives():
    result = await test_agent.simple.update_media_buy(
        buyer_ref='summer_campaign_2025',
        packages=[{
            'buyer_ref': 'ctv_package',
            'creative_ids': ['creative_video_v2', 'creative_display_v2']
        }]
    )

    if hasattr(result, 'errors') and result.errors:
        print('Update failed:', result.errors)
    else:
        assignments = result.affected_packages[0].creative_assignments
        print(f"Assigned {len(assignments)} new creatives")

asyncio.run(replace_creatives())
```

</CodeGroup>

### Multiple Package Updates

Update multiple packages in one call:

<CodeGroup>

```javascript JavaScript
import { testAgent } from '@adcp/client/testing';

const result = await testAgent.updateMediaBuy({
  buyer_ref: 'summer_campaign_2025',
  packages: [
    {
      buyer_ref: 'ctv_package',
      budget: 50000,
      pacing: 'front_loaded'
    },
    {
      buyer_ref: 'audio_package',
      budget: 30000,
      active: false
    }
  ]
});

if (result.errors) {
  console.error('Update failed:', result.errors);
} else {
  console.log(`Updated ${result.affected_packages.length} packages`);
}
```

```python Python
import asyncio
from adcp import test_agent

async def update_multiple_packages():
    result = await test_agent.simple.update_media_buy(
        buyer_ref='summer_campaign_2025',
        packages=[
            {
                'buyer_ref': 'ctv_package',
                'budget': 50000,
                'pacing': 'front_loaded'
            },
            {
                'buyer_ref': 'audio_package',
                'budget': 30000,
                'active': False
            }
        ]
    )

    if hasattr(result, 'errors') and result.errors:
        print('Update failed:', result.errors)
    else:
        print(f"Updated {len(result.affected_packages)} packages")

asyncio.run(update_multiple_packages())
```

</CodeGroup>

## What Can Be Updated

### Campaign-Level Updates

✅ **Can update:**
- Start/end times (subject to seller approval)
- Campaign status (active/paused)

❌ **Cannot update:**
- Media buy ID
- Buyer reference
- Brand manifest
- Original package product IDs

### Package-Level Updates

✅ **Can update:**
- Budget allocation
- Pacing strategy
- Bid prices (auction products)
- Targeting overlays
- Creative assignments
- Package status (active/paused)

❌ **Cannot update:**
- Package ID
- Product ID
- Pricing option ID
- Format IDs (creatives must match existing formats)

## Error Handling

Common errors and resolutions:

| Error Code | Description | Resolution |
|------------|-------------|------------|
| `MEDIA_BUY_NOT_FOUND` | Media buy doesn't exist | Verify media_buy_id or buyer_ref |
| `PACKAGE_NOT_FOUND` | Package doesn't exist | Verify package_id or buyer_ref |
| `UPDATE_NOT_ALLOWED` | Field cannot be changed | See "What Can Be Updated" above |
| `BUDGET_INSUFFICIENT` | New budget below minimum | Increase budget amount |
| `POLICY_VIOLATION` | Update violates content policy | Review policy requirements |
| `INVALID_STATE` | Operation not allowed in current state | Check campaign status |

Example error response:

```json
{
  "errors": [{
    "code": "UPDATE_NOT_ALLOWED",
    "message": "Cannot change product_id for existing package",
    "field": "packages[0].product_id",
    "suggestion": "Create a new package with the desired product instead"
  }]
}
```

## Update Approval

Some updates require seller approval and return pending status:

- **Significant budget increases** (threshold varies by seller)
- **Date range changes** affecting inventory availability
- **Targeting changes** that alter campaign scope
- **Creative changes** requiring policy review

When approval is needed, `implementation_date` will be `null`:

```json
{
  "media_buy_id": "mb_12345",
  "buyer_ref": "summer_campaign_2025",
  "implementation_date": null,
  "affected_packages": []
}
```

## PATCH Semantics

Only specified fields are updated - omitted fields remain unchanged:

```json
{
  "buyer_ref": "summer_campaign_2025",
  "packages": [{
    "buyer_ref": "ctv_package",
    "budget": 50000
  }]
}
```

**Array replacement**: When updating arrays (like `creative_ids`), provide the complete new array:

```json
{
  "packages": [{
    "buyer_ref": "ctv_package",
    "creative_ids": ["creative_video_v2", "creative_display_v2"]
  }]
}
```

## Webhook Payloads (Async Updates)

When `update_media_buy` returns `status: "submitted"` or `status: "working"`, webhooks are triggered for status changes. The webhook payload follows **A2A Protocol's push notification payload structure** (A2A Specification Section 4.3.3). The payload is a **StreamResponse object** containing exactly one of: `statusUpdate` (for status changes), `task` (for final completion), `message`, or `artifactUpdate`.

ADCP declares only the structure of `parts[].data` (DataPart data field) within Message objects. The following specifies what `parts.data` should contain for each status in `update_media_buy` webhook payloads:

**Important**: `buyer_ref` is required in all webhook payloads for `update_media_buy` tool (all statuses) to enable media buy identification. This allows buyers to correlate webhook notifications with their internal systems without needing to store `taskId` mappings.

**Schema References:**
- **Webhook Payload Schema**: [`/schemas/v3/core/webhook-payload.json`](https://adcontextprotocol.org/schemas/v3/core/webhook-payload.json)
- **Input Required**: [`/schemas/v3/media-buy/update-media-buy-async-response-input-required.json`](https://adcontextprotocol.org/schemas/v3/media-buy/update-media-buy-async-response-input-required.json)
- **Failed**: [`/schemas/v3/media-buy/update-media-buy-async-response-failed.json`](https://adcontextprotocol.org/schemas/v3/media-buy/update-media-buy-async-response-failed.json)
- **Working**: [`/schemas/v3/media-buy/update-media-buy-async-response-working.json`](https://adcontextprotocol.org/schemas/v3/media-buy/update-media-buy-async-response-working.json)
- **Completed**: [`/schemas/v3/media-buy/update-media-buy-response.json`](https://adcontextprotocol.org/schemas/v3/media-buy/update-media-buy-response.json) (success variant)

### Status: `input-required`

When human approval or input is needed, the webhook uses `statusUpdate` with `parts.data` containing:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `buyer_ref` | string | Yes | Buyer's reference identifier for the media buy requiring approval |
| `errors` | Error[] | Yes | Array of error objects explaining what approval is needed |

**Example `parts.data` for `input-required`:**
```json
{
  "buyer_ref": "summer_campaign_2025",
  "errors": [
    {
      "code": "BUDGET_INCREASE_REQUIRES_APPROVAL",
      "message": "Budget increase from $30,000 to $80,000 exceeds auto-approval threshold of $50,000. Seller approval required.",
      "field": "packages[0].budget",
      "suggestion": "Reduce budget increase to $50,000 or less for auto-approval, or wait for seller approval (2-4 hours)"
    }
  ]
}
```

**Full webhook payload example:**
```json
{
  "statusUpdate": {
    "taskId": "task_789",
    "contextId": "ctx_abc123",
    "status": {
      "state": "input-required",
      "timestamp": "2025-01-22T11:00:00Z",
      "message": {
        "messageId": "msg_789_002",
        "role": "agent",
        "parts": [
          {
            "text": "Budget increase requires seller approval"
          },
          {
            "data": {
              "buyer_ref": "summer_campaign_2025",
              "errors": [
                {
                  "code": "BUDGET_INCREASE_REQUIRES_APPROVAL",
                  "message": "Budget increase from $30,000 to $80,000 exceeds auto-approval threshold of $50,000. Seller approval required.",
                  "field": "packages[0].budget",
                  "suggestion": "Reduce budget increase to $50,000 or less for auto-approval, or wait for seller approval (2-4 hours)"
                }
              ]
            }
          }
        ]
      }
    },
    "final": false
  }
}
```

### Status: `completed`

When the update is successfully applied, the webhook may use either `statusUpdate` or `task` variant. The `parts.data` contains the full success response matching the synchronous response schema:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `media_buy_id` | string | Yes | Publisher's identifier for the media buy |
| `buyer_ref` | string | Yes | Buyer's reference identifier for the media buy |
| `implementation_date` | string \| null | No | ISO 8601 timestamp when changes take effect (null if pending approval) |
| `affected_packages` | Package[] | No | Array of packages that were modified with complete state information |
| `context` | Context | No | Application-level context (if provided in request) |
| `ext` | object | No | Extension fields (if provided in request) |

**Example `parts.data` for `completed`:**
```json
{
  "media_buy_id": "mb_12345",
  "buyer_ref": "summer_campaign_2025",
  "implementation_date": "2025-06-15T10:00:00Z",
  "affected_packages": [
    {
      "package_id": "pkg_12345_001",
      "buyer_ref": "ctv_package",
      "product_id": "ctv_sports_premium",
      "budget": 50000,
      "pacing": "front_loaded",
      "paused": false
    }
  ]
}
```

**Full webhook payload example (using `task` variant):**
```json
{
  "task": {
    "id": "task_789",
    "contextId": "ctx_abc123",
    "status": {
      "state": "completed",
      "timestamp": "2025-01-22T11:30:00Z",
      "message": {
        "messageId": "msg_789_003",
        "role": "agent",
        "parts": [
          {
            "text": "Media buy updated successfully. Changes take effect on 2025-06-15T10:00:00Z"
          },
          {
            "data": {
              "media_buy_id": "mb_12345",
              "buyer_ref": "summer_campaign_2025",
              "implementation_date": "2025-06-15T10:00:00Z",
              "affected_packages": [
                {
                  "package_id": "pkg_12345_001",
                  "buyer_ref": "ctv_package",
                  "product_id": "ctv_sports_premium",
                  "budget": 50000,
                  "pacing": "front_loaded",
                  "paused": false
                }
              ]
            }
          }
        ]
      }
    }
  }
}
```

### Status: `failed`

When the update operation fails, the webhook uses `statusUpdate` with `parts.data` containing:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `buyer_ref` | string | Yes | Buyer's reference identifier for the media buy that failed to update (required for identification) |
| `errors` | Error[] | Yes | Array of error objects explaining why the update failed |

**Example `parts.data` for `failed`:**
```json
{
  "buyer_ref": "summer_campaign_2025",
  "errors": [
    {
      "code": "UPDATE_NOT_ALLOWED",
      "message": "Cannot change product_id for existing package",
      "field": "packages[0].product_id",
      "suggestion": "Create a new package with the desired product instead"
    },
    {
      "code": "PACKAGE_NOT_FOUND",
      "message": "Package with buyer_ref 'invalid_package_ref' not found in this media buy",
      "field": "packages[0].buyer_ref"
    }
  ]
}
```

**Full webhook payload example:**
```json
{
  "statusUpdate": {
    "taskId": "task_789",
    "contextId": "ctx_abc123",
    "status": {
      "state": "failed",
      "timestamp": "2025-01-22T11:45:00Z",
      "message": {
        "messageId": "msg_789_004",
        "role": "agent",
        "parts": [
          {
            "text": "Media buy update failed due to validation errors"
          },
          {
            "data": {
              "buyer_ref": "summer_campaign_2025",
              "errors": [
                {
                  "code": "UPDATE_NOT_ALLOWED",
                  "message": "Cannot change product_id for existing package",
                  "field": "packages[0].product_id",
                  "suggestion": "Create a new package with the desired product instead"
                }
              ]
            }
          }
        ]
      }
    },
    "final": true
  }
}
```

### Status: `working`

When the update operation is actively processing (typically < 120 seconds), the webhook uses `statusUpdate` with `parts.data` containing:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `buyer_ref` | string | Yes | Buyer's reference identifier for the media buy being updated. Required for identifying which media buy is being updated. |

**Example webhook payload:**
```json
{
  "statusUpdate": {
    "taskId": "task_789",
    "contextId": "ctx_abc123",
    "status": {
      "state": "working",
      "timestamp": "2025-01-22T11:10:00Z",
      "message": {
        "messageId": "msg_789_005",
        "role": "agent",
        "parts": [
          {
            "text": "Processing update and validating changes..."
          },
          {
            "data": {
              "buyer_ref": "summer_campaign_2025"
            }
          }
        ]
      }
    },
    "final": false
  }
}
```

**Note**: `buyer_ref` is required in `parts.data` for `working` status to enable operation identification. The TextPart provides human-readable progress information.

### Status: `submitted`

When the update is submitted for long-running processing (hours to days), the initial response returns `status: "submitted"`. Webhooks will be triggered for subsequent status changes (`input-required`, `completed`, `failed`). The `submitted` status itself does not trigger a webhook.

### Summary

| Status | StreamResponse Variant | `parts.data` Contents | Required Fields |
|--------|----------------------|----------------------|----------------|
| `input-required` | `statusUpdate` | `buyer_ref`, `errors[]` | Both required |
| `completed` | `task` or `statusUpdate` | Full success response matching `update-media-buy-response.json` | `media_buy_id`, `buyer_ref` |
| `failed` | `statusUpdate` | `buyer_ref`, `errors[]` | Both required |
| `working` | `statusUpdate` | `buyer_ref` | `buyer_ref` required |
| `submitted` | N/A (initial response only) | N/A | N/A |

**Important**: `buyer_ref` is required in all webhook payloads for `update_media_buy` tool to enable media buy identification and correlation with the buyer's internal systems. This applies to all statuses: `input-required`, `failed`, `working`, and `completed`.

**Reference**: See [Webhook Payload Schema](/schemas/v3/core/webhook-payload.json) and [Task Management](/docs/protocols/task-management) for complete webhook handling examples.

## Best Practices

**1. Use Precise Updates**
Update only what needs to change - don't resend unchanged values.

**2. Budget Increases**
Small incremental increases are more likely to be auto-approved than large jumps.

**3. Pause Before Major Changes**
Pause campaigns before making significant targeting or creative changes to avoid delivery issues.

**4. Test with Small Changes**
Test update workflows with minor changes before critical campaign modifications.

**5. Monitor Status**
Always check response status and `implementation_date` for approval requirements.

**6. Validate Package State**
Check `affected_packages` in response to confirm changes were applied correctly.

## Usage Notes

- Updates are atomic - either all changes apply or none do
- Both media buys and packages can be referenced by `buyer_ref` or publisher IDs
- Pending states (`working`, `submitted`) are normal, not errors
- Orchestrators MUST handle pending states as part of normal workflow
- `implementation_date` indicates when changes take effect (null if pending approval)

## Next Steps

After updating a media buy:

1. **Verify Changes**: Use [`get_media_buy_delivery`](/docs/media-buy/task-reference/get_media_buy_delivery) to confirm updates
2. **Upload New Creatives**: Use [`sync_creatives`](/docs/media-buy/task-reference/sync_creatives) if creative_ids changed
3. **Monitor Performance**: Track impact of changes on campaign metrics
4. **Optimize Further**: Use [`provide_performance_feedback`](/docs/media-buy/task-reference/provide_performance_feedback) for ongoing optimization

## Learn More

- [Media Buy Lifecycle](/docs/media-buy/media-buys/) - Complete campaign workflow
- [Targeting](/docs/media-buy/advanced-topics/targeting) - Targeting overlays and restrictions
- [Task Management](/docs/protocols/task-management) - Async patterns and status checking
- [create_media_buy](/docs/media-buy/task-reference/create_media_buy) - Initial campaign creation
