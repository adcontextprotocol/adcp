---
sidebar_position: 1
title: Overview
---

<Info>
**AdCP 3.0 Proposal** - This protocol is under development for AdCP 3.0. Feedback welcome via [GitHub Discussions](https://github.com/adcontextprotocol/adcp/discussions).
</Info>

Property Governance standardizes how advertising properties (websites, apps, CTV, podcasts, billboards) are identified, authorized, enriched with data, and selected for campaigns.

## Overview

Property Governance addresses four distinct concerns:

| Concern | Question | Owner | Mechanism |
|---------|----------|-------|-----------|
| **Property Identity** | What properties exist? | Publishers | `adagents.json` properties array |
| **Sales Authorization** | Who can sell this property? | Publishers | `adagents.json` authorized_agents |
| **Property Data** | What do we know about this property? | Data providers | Governance agents via `list_property_features` |
| **Property Selection** | Which properties meet my requirements? | Buyers | Property lists with filters |

The first two are **publisher-side declarations** via adagents.json. The last two are **buyer-side operations** that consume property data from governance agents.

## Publisher Side: adagents.json

Publishers declare their properties and authorize sales agents via `/.well-known/adagents.json`:

```json
{
  "$schema": "https://adcontextprotocol.org/schemas/v2/adagents.json",
  "properties": [
    {
      "property_id": "example_site",
      "property_type": "website",
      "name": "Example Site",
      "identifiers": [{"type": "domain", "value": "example.com"}]
    }
  ],
  "authorized_agents": [
    {
      "url": "https://agent.example.com",
      "authorized_for": "Official sales agent",
      "authorization_type": "property_ids",
      "property_ids": ["example_site"]
    }
  ]
}
```

See the [adagents.json Tech Spec](./adagents) for complete documentation.

## Buyer Side: Property Data and Selection

### Property Data Providers

Governance agents provide data about properties - compliance scores, brand safety ratings, sustainability metrics, etc. They advertise their capabilities via `list_property_features`:

```json
{
  "features": [
    { "feature_id": "consent_quality", "type": "quantitative", "range": { "min": 0, "max": 100 } },
    { "feature_id": "coppa_certified", "type": "binary" },
    { "feature_id": "carbon_score", "type": "quantitative", "range": { "min": 0, "max": 100 } }
  ]
}
```

Buyers send property lists to these agents, and the agents filter and score the properties based on their specialized data. Different agents specialize in different data:

- **Compliance vendors** (data integrity, consent quality)
- **Brand safety providers** (content classification, risk scoring)
- **Quality measurement** (viewability, fraud detection)
- **Sustainability providers** (carbon scoring, green hosting)

### Property Selection via Governance Agents

Buyers create **property lists on governance agents** - the agents manage these lists and apply their filtering logic:

```json
{
  "tool": "create_property_list",
  "arguments": {
    "name": "Q1 Campaign - UK Premium",
    "base_properties": [
      {
        "selection_type": "publisher_tags",
        "publisher_domain": "raptive.com",
        "tags": ["premium_news"]
      }
    ],
    "filters": {
      "countries_all": ["UK"],
      "channels_any": ["display", "video"],
      "feature_requirements": [
        { "feature_id": "consent_quality", "min_value": 85, "max_value": 100 }
      ]
    },
    "brand_manifest": {
      "brand_name": "ToyBrand",
      "industry": "toys",
      "target_audience": "children_under_13"
    }
  }
}
```

When you provide a brand manifest, governance agents automatically apply appropriate rules (COPPA for children's brands, content filtering based on industry, etc.).

A buyer agent typically works with **multiple governance agents** (consent, brand safety, sustainability) and aggregates/intersects their results into a final compliant list.

## How It Fits Together

```mermaid
flowchart TB
    subgraph Buyer["BUYER AGENT"]
        B1[Source of truth for compliant list]
        B2[Aggregates results from specialized agents]
        B3[Issues auth_tokens for sellers]
    end

    subgraph Governance["GOVERNANCE AGENTS"]
        CA["Consent Agent<br/>consent_quality<br/>tcf_version<br/>coppa_certified"]
        S3["Scope3 Agent<br/>carbon_score<br/>climate_risk<br/>green_hosting"]
        BS["Brand Safety Agent<br/>content_category<br/>brand_risk<br/>sentiment"]
    end

    subgraph Seller["SELLER AGENT (DSP/SSP)"]
        SE1[Caches resolved property lists]
        SE2[Uses cached lists for bid-time decisions]
    end

    Buyer -->|create_property_list + webhooks| CA
    Buyer -->|create_property_list + webhooks| S3
    Buyer -->|create_property_list + webhooks| BS

    Buyer -->|get_property_list with auth_token| Seller
```

## Campaign Lifecycle

Property governance operates across three distinct timing contexts. The key principle: **all governance evaluation happens at setup time**, with bid-time decisions using only cached data.

```mermaid
sequenceDiagram
    participant O as Orchestrator
    participant G as Governance Agent
    participant D as Decisioning Platform

    rect rgb(240, 248, 255)
    Note over O,D: Phase 1: Campaign Planning (minutes-hours)
    O->>G: create_property_list(filters, brand_manifest)
    G-->>O: list_id, auth_token
    O->>D: Share list_id + auth_token
    D->>G: get_property_list(list_id, auth_token, resolve=true)
    G-->>D: identifiers[] (pass/fail list, no scores)
    D->>G: Register webhook for list updates
    D->>D: Cache locally (optionally as AXE segments)
    end

    rect rgb(255, 248, 240)
    Note over O,D: Phase 2: Bid Time (under 100ms, NO governance calls)
    D->>D: Check domain against cached allowlist
    Note right of D: May use AXE axei/axex segments<br/>or direct domain lookup
    D->>D: Pass → bid, Fail → skip
    end

    rect rgb(248, 255, 240)
    Note over O,D: Phase 3: Monitoring (during flight)
    G-->>D: Webhook: list changed (counts only)
    D->>G: get_property_list(list_id, auth_token, resolve=true)
    G-->>D: Updated identifiers[]
    D->>D: Update cached allowlist
    end
```

### Phase 1: Campaign Planning

During campaign setup, the orchestrator creates property lists on governance agents with filters and brand manifests. The governance agent evaluates properties and returns a **pass/fail list of identifiers** (no raw scores are exposed). The orchestrator shares the `list_id` and `auth_token` with the decisioning platform, which fetches and caches the resolved list.

### Phase 2: Bid Time

At bid time, the decisioning platform uses **only its local cache**—no calls to governance agents. Latency requirements (under 100ms) make real-time API calls impractical. The decisioning platform may implement this cache as:

- **Direct domain lookup**: In-memory set of approved domains
- **AXE segments**: Cache domains as `axei` (include) or `axex` (exclude) segments for impression-level filtering

The choice of caching mechanism is implementation-specific; the protocol only requires that bid-time decisions use cached data.

### Phase 3: Monitoring

During campaign flight, governance agents continue evaluating properties. When a property's compliance status changes, the agent sends a webhook notification to registered subscribers. The webhook contains **change counts only** (not scores or reasons)—the decisioning platform must call `get_property_list` to fetch the updated list and refresh its cache.

## Sharing Property Lists with Sellers

Once a buyer has a compliant property list, they share it with sellers:

1. **Get a list reference**: The buyer agent exposes the list via `get_property_list`
2. **Issue an auth token**: The buyer generates a token that authorizes access to the list
3. **Pass to seller**: Include `property_list_ref` with `auth_token` in product discovery or media buy requests
4. **Seller caches locally**: Sellers fetch and cache the resolved list for bid-time decisions
5. **Webhooks for updates**: When the list changes, sellers are notified to refresh their cache

```json
{
  "property_list_ref": {
    "agent_url": "https://buyer-agent.example.com",
    "list_id": "pl_q1_uk_premium",
    "auth_token": "eyJhbGciOiJIUzI1NiIs..."
  }
}
```

Sellers use this reference in `get_products` to filter available inventory:

```json
{
  "tool": "get_products",
  "arguments": {
    "brief": "UK video inventory for Q1",
    "property_list_ref": {
      "agent_url": "https://buyer-agent.example.com",
      "list_id": "pl_q1_uk_premium",
      "auth_token": "..."
    }
  }
}
```

## Relationship to Other Protocols

### Property Governance + Media Buy

The Media Buy Protocol consumes property lists at multiple stages:

- **Product discovery**: Pass `property_list_ref` to `get_products` to filter inventory to compliant properties
- **Media buy creation**: Reference property lists to constrain where ads can run
- **Authorization**: adagents.json validates agent authority to sell

### Property Governance + Signals

Both protocols operate on properties but serve different purposes:

| Signals Protocol | Property Governance |
|------------------|---------------------|
| Audience/contextual data | Property metadata and compliance |
| "Who should see this ad?" | "Where can this ad run?" |
| Signal activation | Property filtering |

## Tasks

### Discovery

- **[list_property_features](./tasks/list_property_features)**: Discover what data a governance agent can provide about properties

### Property List Management

- **[create_property_list](./tasks/property_lists#create_property_list)**: Create a new property list on a governance agent
- **[get_property_list](./tasks/property_lists#get_property_list)**: Retrieve resolved properties (with caching guidance)
- **[update_property_list](./tasks/property_lists#update_property_list)**: Modify filters or base properties
- **[delete_property_list](./tasks/property_lists#delete_property_list)**: Remove a property list

## Getting Started

**Publishers:**
1. Create `/.well-known/adagents.json` with property definitions
2. Authorize sales agents for your properties

**Buyers:**
1. Subscribe to governance agents for property data
2. Create property lists on each governance agent with filters and brand manifests
3. Aggregate results into a final compliant list
4. Share property list references with sellers (with auth tokens)

**Governance Agent Implementers:**
1. Implement `list_property_features` to advertise your capabilities
2. Implement property list CRUD operations
3. Support webhooks to notify buyers when evaluations change
4. See the [Protocol Specification](./specification) for implementation details

See the [Protocol Specification](./specification) for detailed implementation guidance.
