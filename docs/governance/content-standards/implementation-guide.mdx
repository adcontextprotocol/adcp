---
title: Implementation Guide
description: How to implement the Content Standards Protocol as a sales agent, buyer agent, or web publisher
---

This guide covers implementation patterns for the Content Standards Protocol from three perspectives:

1. **Sales agents** accepting and enforcing brand safety standards
2. **Buyer agents** orchestrating content validation across publishers
3. **Web publishers** without direct content access

## For Sales Agents

If you're a sales agent (publisher ad server, SSP, or platform), implementing Content Standards means accepting buyer policies and enforcing them during delivery.

### What You Need to Implement

**1. Accept content standards references on `get_products` and `create_media_buy`**

Buyers pass their standards via reference:

```json
{
  "content_standards_ref": {
    "standards_id": "nike_emea_brand_safety",
    "agent_url": "https://brandsafety.nike.com"
  }
}
```

When you receive this:
- Fetch the standards from the buyer's agent (cache aggressively - these don't change often)
- The standards document tells you exactly what to enforce - no need to call back
- Store the association between the media buy and the standards

**2. Build your evaluation capability**

The standards document contains everything you need:
- Rules (what categories to allow/block)
- Calibration examples (how to interpret edge cases)
- Required features (what signals this buyer cares about)

Use this to train or configure your content evaluation system. This could be:
- An LLM with the rules as system prompt
- A classifier trained on the calibration examples
- A rules engine for deterministic evaluation
- A third-party brand safety vendor

The protocol doesn't prescribe your implementation - just that you honor the standards.

**3. Participate in calibration (optional but recommended)**

If the buyer initiates `calibrate_content`, engage in the dialogue:

```json
// Buyer sends ambiguous examples
{
  "standards_id": "nike_emea_brand_safety",
  "artifacts": [
    {
      "property_id": { "type": "domain", "value": "espn.com" },
      "artifact_id": "article_123",
      "assets": [{ "type": "text", "role": "title", "content": "Marathon Runner Collapses at Finish Line" }]
    }
  ]
}

// You respond with your interpretation
{
  "evaluations": [{
    "artifact_id": "article_123",
    "suitable": true,
    "confidence": 0.7,
    "explanation": "Sports injury coverage in athletic context - aligns with brand's sports marketing positioning"
  }]
}
```

Calibration aligns your interpretation with the buyer's expectations before delivery starts.

**4. Support `validate_content_delivery` calls**

After delivery, buyers may request validation of where their ads appeared:

```json
{
  "standards_id": "nike_emea_brand_safety",
  "records": [
    { "artifact_id": "article_456", "impression_count": 15000 },
    { "artifact_id": "article_789", "impression_count": 8500 }
  ]
}
```

Return your evaluation for each:

```json
{
  "results": [
    { "artifact_id": "article_456", "suitable": true, "categories": ["sports", "lifestyle"] },
    { "artifact_id": "article_789", "suitable": false, "categories": ["violence"], "reason": "Graphic injury imagery" }
  ]
}
```

### Implementation Checklist

- [ ] Implement `list_content_features` so buyers can discover your capabilities before creating standards
- [ ] Parse `content_standards_ref` in `get_products` and `create_media_buy`
- [ ] Fetch and cache standards documents from buyer agents
- [ ] Build content evaluation against the rules in the standards document
- [ ] Implement `calibrate_content` for alignment dialogue
- [ ] Implement `validate_content_delivery` for post-delivery audit
- [ ] Implement `get_media_buy_artifacts` so buyers can retrieve content for their own validation

---

## For Buyer Agents

If you're a buyer agent (DSP, agency platform, or brand safety service), you orchestrate content standards across multiple publishers.

### The Proxy Pattern

Buyer agents act as intermediaries between brands and publishers:

```
Brand → Buyer Agent → Sales Agent (Publisher)
                   ↓
            Content Standards
            (hosted by buyer)
```

**1. Discover publisher capabilities**

Before creating standards, call `list_content_features` on each publisher to understand what they can evaluate:

```json
// Response from publisher
{
  "features": [
    { "id": "garm_brand_safety", "name": "GARM Brand Safety Categories" },
    { "id": "sentiment", "name": "Content Sentiment Analysis" },
    { "id": "competitive_separation", "name": "Competitor Blocking" }
  ]
}
```

Use this to build standards that reference features the publisher actually supports.

**2. Host the brand's standards**

Create and store content standards for each brand:

```json
{
  "standards_id": "nike_emea_brand_safety",
  "name": "Nike EMEA Brand Safety Policy",
  "brand_id": "nike",
  "rules": {
    "blocked_categories": ["violence", "adult", "drugs"],
    "required_categories": [],
    "competitive_separation": ["adidas", "puma", "reebok"]
  },
  "calibration": [
    {
      "artifact": { ... },
      "expected_result": { "suitable": true },
      "rationale": "Sports injury in athletic context is acceptable"
    }
  ]
}
```

Expose these via your agent's API so publishers can fetch them.

**3. Pass standards references when buying**

When creating media buys, include the reference:

```json
{
  "product_id": "espn_sports_display",
  "packages": [...],
  "content_standards_ref": {
    "standards_id": "nike_emea_brand_safety",
    "agent_url": "https://buying.agency.com"
  }
}
```

**4. Orchestrate calibration**

Before campaigns launch, run calibration with each publisher:

```python
# Pseudo-code for calibration orchestration
for publisher in campaign.publishers:
    # Get sample content from publisher
    artifacts = publisher.get_media_buy_artifacts(media_buy_id)

    # Run through your evaluation
    our_results = evaluate(artifacts, standards)

    # Send to publisher for their evaluation
    their_results = publisher.calibrate_content(standards_id, artifacts)

    # Compare and resolve discrepancies
    discrepancies = find_discrepancies(our_results, their_results)
    if discrepancies:
        # Iterate with more examples until aligned
        resolve_calibration(publisher, standards, discrepancies)
```

**5. Validate delivery**

After campaign delivery:

```python
# Get delivery records from publisher
artifacts = publisher.get_media_buy_artifacts(media_buy_id, include_delivery=True)

# Option A: Trust publisher's evaluation
results = publisher.validate_content_delivery(standards_id, artifacts)

# Option B: Validate yourself (fetch content, run your own model)
for artifact in artifacts:
    content = fetch_content(artifact.url)  # or use content_access
    our_result = evaluate(content, standards)
    compare_with_publisher(our_result, publisher_result)
```

**6. Report discrepancies**

Surface any misalignment to the brand:
- Publisher marked suitable, you disagree → potential brand safety incident
- Publisher marked unsuitable, you disagree → potential missed inventory

### Implementation Checklist

- [ ] Call `list_content_features` to discover publisher capabilities
- [ ] Store and serve content standards documents
- [ ] Include `content_standards_ref` in media buy requests
- [ ] Implement calibration orchestration workflow
- [ ] Fetch artifacts via `get_media_buy_artifacts`
- [ ] Validate delivery via `validate_content_delivery` or your own evaluation
- [ ] Build discrepancy reporting for brands

---

## For Web Publishers (URL-Based Content)

If you're a web publisher without direct programmatic access to your content (e.g., your CMS doesn't expose an API), you can use a service provider pattern.

### The Problem

A buyer sends you artifact IDs (URLs) for validation:

```json
{
  "records": [
    { "artifact_id": "https://yoursite.com/article/12345" },
    { "artifact_id": "https://yoursite.com/article/67890" }
  ]
}
```

But your ad server doesn't have the article content - it just knows the URL.

### Solution: Content Service Provider

Use a scraping/content service to resolve URLs to content:

```
Buyer → Your Ad Server → Content Service → Your Website
                      ↓
                 Evaluation
```

**Option A: Integrate a content service**

```python
async def validate_content_delivery(standards_id, records):
    standards = fetch_standards(standards_id)
    results = []

    for record in records:
        # Use content service to fetch and parse
        content = await content_service.fetch(record.artifact_id)

        # Evaluate against standards
        result = evaluate(content, standards)
        results.append(result)

    return results
```

**Option B: Pre-index your content**

Build a content index that maps URLs to extracted content:

```json
{
  "content_access": {
    "url_pattern": "https://content-cache.yoursite.com/*",
    "auth": { "type": "bearer", "token": "..." }
  }
}
```

When buyers request validation, they can fetch content directly from your cache.

**Option C: Provide artifact URLs in responses**

In `get_media_buy_artifacts`, include URLs that resolve to content:

```json
{
  "artifacts": [
    {
      "property_id": { "type": "domain", "value": "yoursite.com" },
      "artifact_id": "article_12345",
      "url": "https://yoursite.com/article/12345",
      "assets": []  // Empty - buyer fetches via URL
    }
  ],
  "content_access": {
    "url_pattern": "https://yoursite.com/*",
    "auth": null  // Public content
  }
}
```

The buyer then fetches and evaluates the content themselves.

### Implementation Checklist

- [ ] Decide on content access pattern (service, cache, or buyer-fetch)
- [ ] Implement content fetching/caching if needed
- [ ] Expose `content_access` configuration for authenticated content
- [ ] Return resolvable URLs in `get_media_buy_artifacts`

---

## Content Access Pattern

All three roles may need to exchange content securely. The `content_access` pattern provides authenticated access to a URL namespace:

```json
{
  "content_access": {
    "url_pattern": "https://cache.example.com/*",
    "auth": {
      "type": "bearer",
      "token": "eyJ..."
    }
  }
}
```

- **url_pattern**: URLs matching this pattern use this auth
- **auth.type**: Authentication method (`bearer`, `api_key`, `signed_url`)
- **auth.token**: The credential

Include this in:
- `create_content_standards` (buyer → seller: "fetch my standards here")
- `get_media_buy_artifacts` response (seller → buyer: "fetch content here")
- `validate_content_delivery` request (buyer → seller: "fetch content here if you need it")

This avoids per-asset tokens and keeps payloads small while enabling secure content exchange.
