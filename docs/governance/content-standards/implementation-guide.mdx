---
title: Implementation Guide
description: How to implement the Content Standards Protocol as a sales agent, buyer agent, or web publisher
---

This guide covers implementation patterns for the Content Standards Protocol from three perspectives:

1. **Sales agents** accepting and enforcing brand safety standards
2. **Buyer agents** orchestrating content validation across publishers
3. **Web publishers** without direct content access

## For Sales Agents

If you're a sales agent (publisher ad server, SSP, or platform), implementing Content Standards means accepting buyer policies and enforcing them during delivery.

### The Core Model

When a buyer includes a `content_standards_ref` in their request, you must:

1. **Fetch the standards** and evaluate if you can fulfill them
2. **Accept or reject** the buy based on your capabilities
3. **Calibrate** your evaluation model against the buyer's expectations
4. **Enforce** the standards during delivery
5. **Report** validation results after delivery

If you cannot fulfill the content standards requirements, **reject the buy**. Don't accept a campaign you can't properly enforce.

### What You Need to Implement

**1. Accept content standards references on `get_products` and `create_media_buy`**

Buyers pass their standards via reference:

```json
{
  "content_standards_ref": {
    "standards_id": "nike_emea_brand_safety",
    "agent_url": "https://brandsafety.nike.com"
  }
}
```

When you receive this:
- Fetch the standards document from the buyer's agent
- Evaluate whether you can enforce these requirements
- If you cannot meet the standards, reject the request
- If you can, accept and store the association with the media buy

**2. Decide: Can you fulfill this?**

The standards document contains:
- Rules (what categories to allow/block)
- Calibration examples (how to interpret edge cases)
- Competitive separation requirements
- Any other buyer-specific policies

Review these requirements against your capabilities. Different publishers have different definitions of "adjacency" - Reddit might include comments, YouTube might include related videos, a news site might mean the article body. That's fine - as long as you can meaningfully enforce the buyer's intent, accept the buy.

If you can't - for example, the buyer requires competitive separation but you don't support it, or they need adjacency data for a channel where it doesn't apply (like billboards) - reject the buy.

**3. Build your evaluation capability**

Use the standards document to train or configure your content evaluation system. This could be:
- An LLM with the rules as system prompt
- A classifier trained on the calibration examples
- A rules engine for deterministic evaluation
- A third-party brand safety vendor

The protocol doesn't prescribe your implementation - just that you honor the standards.

**4. Participate in calibration**

Before campaigns launch, calibrate your interpretation against the buyer's governance agent. You send sample artifacts, they tell you how they would rate them:

```json
// You send examples from your inventory
{
  "standards_id": "nike_emea_brand_safety",
  "artifacts": [
    {
      "property_id": { "type": "domain", "value": "espn.com" },
      "artifact_id": "article_123",
      "assets": [{ "type": "text", "role": "title", "content": "Marathon Runner Collapses at Finish Line" }]
    }
  ]
}

// Buyer's governance agent responds with their interpretation
{
  "evaluations": [{
    "artifact_id": "article_123",
    "suitable": true,
    "confidence": 0.9,
    "explanation": "Sports injury coverage in athletic context - aligns with brand's sports marketing positioning"
  }]
}
```

Use these responses to train your local model. If you disagree with a rating, ask follow-up questions to understand the buyer's reasoning.

**5. Support artifact retrieval and webhooks**

After delivery, buyers need to audit where their ads appeared. Your responsibilities:

- **Implement `get_media_buy_artifacts`** - Return content artifacts for delivered impressions so buyers can validate against their governance agent
- **Support artifact webhooks** - Push artifacts to buyer-specified endpoints in real-time or batched
- **Support reporting webhooks** - Push delivery reports to buyer-specified endpoints

The **governance agent** (not you) implements `validate_content_delivery`. Buyers fetch artifacts from you, then send them to their governance agent for validation.

```json
// Artifact webhook payload
{
  "media_buy_id": "mb_nike_reddit_q1",
  "artifacts": [
    {
      "property_id": { "type": "domain", "value": "reddit.com" },
      "artifact_id": "r_fitness_abc123",
      "assets": [{ "type": "text", "role": "title", "content": "Best protein sources" }],
      "delivered_at": "2025-01-15T10:30:00Z"
    }
  ]
}
```

### Implementation Checklist

- [ ] Parse `content_standards_ref` in `get_products` and `create_media_buy`
- [ ] Fetch and evaluate standards documents from buyer agents
- [ ] Reject buys you cannot fulfill - don't accept campaigns you can't enforce
- [ ] Build content evaluation against the standards document
- [ ] Call `calibrate_content` on buyer's governance agent to align interpretation
- [ ] Implement `get_media_buy_artifacts` so buyers can retrieve content for validation
- [ ] Support artifact webhooks for real-time/batched artifact delivery
- [ ] Support reporting webhooks for delivery metrics

---

## For Buyer Agents

If you're a buyer agent (DSP, agency platform, or brand safety service), you orchestrate content standards across multiple publishers.

### The Proxy Pattern

Buyer agents act as intermediaries between brands and publishers:

```
Brand → Buyer Agent → Sales Agent (Publisher)
                   ↓
            Content Standards
            (hosted by buyer)
```

**1. Host the brand's standards**

Create and store content standards for each brand:

```json
{
  "standards_id": "nike_emea_brand_safety",
  "name": "Nike EMEA Brand Safety Policy",
  "brand_id": "nike",
  "rules": {
    "blocked_categories": ["violence", "adult", "drugs"],
    "required_categories": [],
    "competitive_separation": ["adidas", "puma", "reebok"]
  },
  "calibration": [
    {
      "artifact": { ... },
      "expected_result": { "suitable": true },
      "rationale": "Sports injury in athletic context is acceptable"
    }
  ]
}
```

Expose these via your agent's API so publishers can fetch them.

**2. Pass standards references when buying**

When creating media buys, include the reference:

```json
{
  "product_id": "espn_sports_display",
  "packages": [...],
  "content_standards_ref": {
    "standards_id": "nike_emea_brand_safety",
    "agent_url": "https://buying.agency.com"
  }
}
```

If the publisher cannot fulfill the standards, they should reject the buy. Handle rejections gracefully and find alternative inventory.

**3. Implement `calibrate_content`**

Publishers call your `calibrate_content` endpoint to calibrate their local models. They send sample artifacts, you respond with how the brand would rate them:

```python
# Your calibrate_content implementation
def calibrate_content(standards_id, artifacts):
    standards = get_standards(standards_id)
    evaluations = []

    for artifact in artifacts:
        # Evaluate against brand's policy
        result = evaluate_against_policy(artifact, standards)
        evaluations.append({
            "artifact_id": artifact["artifact_id"],
            "suitable": result.suitable,
            "confidence": result.confidence,
            "explanation": result.explanation
        })

    return {"evaluations": evaluations}
```

This helps publishers understand your interpretation before they start enforcing.

**4. Validate delivery**

After campaign delivery, fetch artifacts from publishers and validate against the standards:

```python
# Get delivery records from publisher
artifacts = publisher.get_media_buy_artifacts(media_buy_id, include_delivery=True)

# Validate using your governance logic
for artifact in artifacts:
    result = evaluate_against_policy(artifact, standards)
    if not result.suitable:
        log_brand_safety_incident(artifact, result)
```

You can also receive artifacts via webhook instead of polling.

**5. Report to brands**

Surface validation results to the brand:
- **Incidents**: Content that didn't meet standards
- **Coverage**: What percentage of delivery was validated
- **Trends**: Changes in content safety over time

### Implementation Checklist

- [ ] Store and serve content standards documents
- [ ] Include `content_standards_ref` in media buy requests
- [ ] Handle rejections from publishers who can't fulfill standards
- [ ] Implement `calibrate_content` so publishers can align their models
- [ ] Implement `validate_content_delivery` to evaluate artifacts against standards
- [ ] Fetch artifacts via `get_media_buy_artifacts` or receive via webhook
- [ ] Build reporting for brands

---

## For Web Publishers (URL-Based Content)

If you're a web publisher without direct programmatic access to your content (e.g., your CMS doesn't expose an API), you can use a service provider pattern.

### The Problem

A buyer sends you artifact IDs (URLs) for validation:

```json
{
  "records": [
    { "artifact_id": "https://yoursite.com/article/12345" },
    { "artifact_id": "https://yoursite.com/article/67890" }
  ]
}
```

But your ad server doesn't have the article content - it just knows the URL.

### Solution: Content Service Provider

Use a scraping/content service to resolve URLs to content:

```
Buyer → Your Ad Server → Content Service → Your Website
                      ↓
                 Evaluation
```

**Option A: Integrate a content service**

```python
async def validate_content_delivery(standards_id, records):
    standards = fetch_standards(standards_id)
    results = []

    for record in records:
        # Use content service to fetch and parse
        content = await content_service.fetch(record.artifact_id)

        # Evaluate against standards
        result = evaluate(content, standards)
        results.append(result)

    return results
```

**Option B: Pre-index your content**

Build a content index that maps URLs to extracted content:

```json
{
  "content_access": {
    "url_pattern": "https://content-cache.yoursite.com/*",
    "auth": { "type": "bearer", "token": "..." }
  }
}
```

When buyers request validation, they can fetch content directly from your cache.

**Option C: Provide artifact URLs in responses**

In `get_media_buy_artifacts`, include URLs that resolve to content:

```json
{
  "artifacts": [
    {
      "property_id": { "type": "domain", "value": "yoursite.com" },
      "artifact_id": "article_12345",
      "url": "https://yoursite.com/article/12345",
      "assets": []  // Empty - buyer fetches via URL
    }
  ],
  "content_access": {
    "url_pattern": "https://yoursite.com/*",
    "auth": null  // Public content
  }
}
```

The buyer then fetches and evaluates the content themselves.

### Implementation Checklist

- [ ] Decide on content access pattern (service, cache, or buyer-fetch)
- [ ] Implement content fetching/caching if needed
- [ ] Expose `content_access` configuration for authenticated content
- [ ] Return resolvable URLs in `get_media_buy_artifacts`

---

## Content Access Pattern

All three roles may need to exchange content securely. The `content_access` pattern provides authenticated access to a URL namespace:

```json
{
  "content_access": {
    "url_pattern": "https://cache.example.com/*",
    "auth": {
      "type": "bearer",
      "token": "eyJ..."
    }
  }
}
```

- **url_pattern**: URLs matching this pattern use this auth
- **auth.type**: Authentication method (`bearer`, `api_key`, `signed_url`)
- **auth.token**: The credential

Include this in:
- `create_content_standards` (buyer → seller: "fetch my standards here")
- `get_media_buy_artifacts` response (seller → buyer: "fetch content here")
- `validate_content_delivery` request (buyer → seller: "fetch content here if you need it")

This avoids per-asset tokens and keeps payloads small while enabling secure content exchange.
