---
title: Accounts and agents
description: How sellers configure account capabilities and how buyer agents set up accounts
---

AdCP distinguishes four entities in every billable operation:

| Entity | Question | How identified |
|--------|----------|----------------|
| **Brand** | Whose products are advertised? | Brand reference: `domain` + optional `brand_id` ([brand.json](/docs/brand-protocol/brand-json)) |
| **Account** | Who gets billed? What rates apply? | [Account reference](#account-references) |
| **Operator** | Who operates the seat? | Domain (e.g., `pinnacle-media.com`) |
| **Agent** | What software is placing the buy? | Authenticated session |

**Brand** — The advertiser whose products or services are promoted. Identified by a `brand` reference (`domain` + optional `brand_id`), resolved via `/.well-known/brand.json`. Single-brand houses use the domain alone (no `brand_id`).

**Account** — A billing relationship between a buyer and seller. Determines rate card, payment terms, credit limit, and who receives invoices. Every billable operation requires an account reference — either an `account_id` or a natural key (`brand`, `operator`).

**Operator** — The entity driving buys — an agency trading desk, the brand's internal team, or another entity acting on behalf of the advertiser. Identified by domain and verifiable via [authorized operators](#authorized-operators) in `brand.json`.

**Agent** — The software placing buys and managing campaigns. Authenticates with the seller and may operate on behalf of multiple operators and brands.

See [Accounts Protocol overview](/docs/accounts/overview) for the full commercial model and [sync_accounts](/docs/accounts/tasks/sync_accounts) for the task reference.

## What sellers declare

Sellers configure four fields in the `account` section of [`get_adcp_capabilities`](/docs/protocol/get_adcp_capabilities#account):

**1. Which billing models do you support?** (`supported_billing`)

| Billing | Who is invoiced | Use case |
|---------|----------------|----------|
| `operator` | Operator (agency or brand with own seat) | Operator buying on their own terms |
| `agent` | Agent | Agent consolidates billing across brands |

**2. Do you require operator-level auth?** (`require_operator_auth`)

When `false` (default): the seller trusts the agent. The agent authenticates once and sets up accounts via `sync_accounts`.

When `true`: each operator must authenticate with the seller directly. The agent obtains a credential per operator — via OAuth using the seller's `authorization_endpoint`, or via API key out-of-band.

**3. What's the default billing model?** (`default_billing`)

Applied when the agent omits `billing` from `sync_accounts`. When set to `"agent"`, the seller pre-provisions a default account — a standing account with no brand or operator association — that buys route through automatically.

**4. How do you resolve account references?** (`account_resolution`)

| Resolution | Model | Description |
|-----------|-------|-------------|
| `explicit_account_id` | Explicit account IDs | Accounts are managed out-of-band (advertiser portal, sales rep). Buyer discovers them via `list_accounts` and passes a seller-assigned `account_id`. |
| `implicit_from_sync` | Implicit account IDs | Buyer declares intent via `sync_accounts` — who's advertising, who's paying — and the seller provisions accounts. On subsequent requests, the buyer passes brand identity (`brand`, `operator`) and the seller resolves internally. |

Default: `["explicit_account_id"]`. See [Account references](#account-references) for detailed workflows.

**Example capabilities:**

```json
{
  "account": {
    "account_resolution": ["explicit_account_id", "implicit_from_sync"],
    "require_operator_auth": false,
    "supported_billing": ["operator", "agent"],
    "default_billing": "agent"
  }
}
```

These four fields combine into four common patterns.

## Seller patterns

| Pattern | `require_operator_auth` | `supported_billing` | `default_billing` |
|---------|------------------------|--------------------|--------------------|
| Operator-gated | `true` | `["operator"]` | — |
| Direct-only | `false` | `["operator"]` | — |
| Agent-consolidated | `false` | `["agent"]` | `"agent"` |
| Hybrid | `false` | `["operator", "agent"]` | `"agent"` |

### Operator-gated

Each operator authenticates directly with the seller. No agent-level billing — every account has a direct billing relationship. Typical for premium publishers and platforms that enforce per-operator contract compliance.

**Capabilities:**

```json
{
  "account": {
    "account_resolution": ["explicit_account_id"],
    "require_operator_auth": true,
    "supported_billing": ["operator"],
    "authorization_endpoint": "https://seller.example.com/oauth/authorize"
  }
}
```

**Buyer workflow:**

1. Call `get_adcp_capabilities` — see `require_operator_auth: true` and `authorization_endpoint`
2. For each operator:
   a. Obtain operator's credential (OAuth via `authorization_endpoint`, or API key out-of-band)
   b. Open a new session with the operator's credential
   c. Call `sync_accounts` to set up each brand for this operator
3. Wait for account status `active` (poll `list_accounts` if `pending_approval`)
4. Call `get_products` / `create_media_buy` with the operator's session and `account` reference

**sync_accounts example:**

```json
{
  "brand": {
    "domain": "nova-brands.com",
    "brand_id": "spark"
  },
  "operator": "pinnacle-media.com",
  "billing": "operator"
}
```

Seller checks `nova-brands.com/.well-known/brand.json`, finds Pinnacle Media in `authorized_operators`, and fast-tracks provisioning:

```json
{
  "account_id": "acc_nova_spark",
  "brand": {
    "domain": "nova-brands.com",
    "brand_id": "spark"
  },
  "operator": "pinnacle-media.com",
  "status": "active",
  "billing": "operator",
  "account_scope": "operator_brand"
}
```

**Key point:** The operator's credential — not the agent's — authorizes all calls in that session. Brand.json verification is secondary to the credential.

### Direct-only

The seller trusts the agent's identity but requires a direct account for every brand or operator. Operators listed in `brand.json` may be provisioned instantly; others go through `pending_approval` until T&C are signed out-of-band. No default account — the agent cannot buy without a direct account.

**Capabilities:**

```json
{
  "account": {
    "account_resolution": ["explicit_account_id"],
    "supported_billing": ["operator"]
  }
}
```

**Buyer workflow:**

1. Call `get_adcp_capabilities` — see `require_operator_auth` absent (defaults to `false`)
2. Call `sync_accounts` for each brand/operator pair
3. Wait for account status `active` — may require human to complete credit/legal at `setup.url`
4. Call `get_products` with `account` reference
5. Call `create_media_buy` with `account` reference

**sync_accounts example — brand with own seat:**

```json
{
  "brand": {
    "domain": "acme-corp.com"
  },
  "operator": "acme-corp.com",
  "billing": "operator"
}
```

Seller acknowledges the request but requires setup before provisioning:

```json
{
  "account_id": "acc_acme_pending",
  "brand": {
    "domain": "acme-corp.com"
  },
  "operator": "acme-corp.com",
  "status": "pending_approval",
  "billing": "operator",
  "account_scope": "brand",
  "setup": {
    "url": "https://seller.example.com/advertiser-onboard",
    "message": "Complete advertiser registration and credit application"
  }
}
```

The seller has assigned an `account_id` and acknowledged the relationship `(brand: "acme-corp.com", operator: "acme-corp.com", billing: "operator")`, but the account is pending review before it becomes active. A human at Acme Corp completes the setup at the URL. To check progress, the agent either:
- Re-calls `sync_accounts` with the same natural key — the seller returns the updated status
- Receives a webhook notification if `push_notification_config` was provided in the request

The pending account is visible in `list_accounts` with its `account_id` — see [account_id and rejected accounts](#account_id-and-rejected-accounts) for when `account_id` is present.

**Key point:** `pending_approval` is the normal path. Every buyer needs a direct relationship with the seller.

### Agent-consolidated

All billing flows through the agent. The seller pre-provisions a default account and creates per-brand/operator accounts immediately — no pending approval needed. The agent handles re-billing. Typical for DSP-style sellers and subscription content platforms.

**Capabilities:**

```json
{
  "account": {
    "supported_billing": ["agent"],
    "default_billing": "agent"
  }
}
```

**Buyer workflow:**

1. Call `get_adcp_capabilities` — see `supported_billing: ["agent"]` and `default_billing: "agent"`
2. Call `sync_accounts` for each brand/operator pair (billing is always `agent`)
3. Accounts are active immediately — no human approval needed
4. Call `get_products` / `create_media_buy` with `account` reference

**sync_accounts example:**

```json
{
  "brand": {
    "domain": "nova-brands.com",
    "brand_id": "spark"
  },
  "operator": "pinnacle-media.com",
  "billing": "agent"
}
```

Account active immediately:

```json
{
  "account_id": "acc_spark_001",
  "brand": {
    "domain": "nova-brands.com",
    "brand_id": "spark"
  },
  "operator": "pinnacle-media.com",
  "status": "active",
  "billing": "agent",
  "account_scope": "operator_brand"
}
```

**Key point:** The agent receives a single consolidated invoice. Per-brand accounts give reporting granularity but billing is centralized. Buys without a specific `account_id` route to the default account.

### Hybrid

Both paths are available. Direct accounts (operator billing) give buyers their own rate cards and invoicing with the seller. The default account serves as the fallback — buys without a direct account route through it automatically. Typical for sellers serving both direct buyers and programmatic buyers.

**Capabilities:**

```json
{
  "account": {
    "supported_billing": ["operator", "agent"],
    "default_billing": "agent"
  }
}
```

**Buyer workflow:**

1. Call `get_adcp_capabilities` — see both billing models, `default_billing: "agent"`
2. Call `sync_accounts` for each brand/operator pair with preferred billing:
   - Operator with a direct seller relationship: `billing: "operator"`
   - Everything else: `billing: "agent"` (or omit to accept the default)
3. Direct accounts may go through `pending_approval`; agent-billed accounts are active immediately
4. Call `get_products` / `create_media_buy` with `account` reference

**sync_accounts example — unsupported billing rejected:**

The seller supports operator billing in general, but may not support it for every operator. Here, the agent requests operator billing for an operator without a direct relationship:

```json
{
  "brand": {
    "domain": "acme-corp.com"
  },
  "operator": "acme-corp.com",
  "billing": "operator"
}
```

Seller rejects the request because this operator has no direct billing relationship:

```json
{
  "brand": {
    "domain": "acme-corp.com"
  },
  "operator": "acme-corp.com",
  "status": "rejected",
  "billing": "operator",
  "action": "failed",
  "errors": [{
    "code": "BILLING_NOT_SUPPORTED",
    "message": "Operator billing is not available for this account. Re-submit with billing: \"agent\"."
  }]
}
```

The agent should re-submit with a supported billing model (e.g., `"agent"`) or inform the buyer that operator billing is not available with this seller.

**Key point:** The seller accepts the requested billing or rejects the request. Billing is never silently remapped. Direct accounts are preferred when available but the agent can always fall back to agent billing by re-submitting.

## Authorized operators

Brands declare who can represent them in `/.well-known/brand.json` via the `authorized_operators` field. Sellers SHOULD verify operators against this when processing `sync_accounts`.

```json
{
  "house": {
    "domain": "nova-brands.com",
    "name": "Nova Brands"
  },
  "brands": [
    { "id": "spark", "names": [{"en": "Spark"}] },
    { "id": "glow", "names": [{"en": "Glow"}] }
  ],
  "authorized_operators": [
    {
      "domain": "pinnacle-media.com",
      "brands": ["spark", "glow"],
      "countries": ["US", "GB", "DE"]
    },
    {
      "domain": "summit-agency.jp",
      "brands": ["spark"],
      "countries": ["JP"]
    },
    {
      "domain": "nova-brands.com",
      "brands": ["*"]
    }
  ]
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `domain` | Yes | Operator's domain |
| `brands` | Yes | Brand IDs this operator can represent. `["*"]` means all brands. |
| `countries` | No | ISO 3166-1 alpha-2 country codes. Omit for global authorization. |

### Verification flow

1. Resolve `{brand.domain}/.well-known/brand.json`
2. Check `authorized_operators` for matching `domain` with the brand in `brands`
3. If found → proceed (account may still need credit/legal approval)
4. If not found → reject the account (`action: "failed"`) or return `pending_approval` for manual review

Verification is a trust signal, not a gate. Finding the operator in `brand.json` lets the seller fast-track provisioning. If the operator isn't listed, the seller can still approve through its own review process.

**Self-authorization is implicit.** When the `operator` domain matches the brand's domain, the brand is operating its own seat — no listing in `authorized_operators` is needed.

`authorized_operators` models the interface between the brand and whoever holds the seat. It does not model internal agency hierarchies.

## Account references

Every account-scoped operation accepts an `account` object instead of a flat `account_id` string. The seller's `account_resolution` capability declares which model it supports — and the model determines the buyer's entire integration path.

### Explicit account IDs

Accounts are managed outside of AdCP. The advertiser creates an account on the seller's platform, grants the operator permission to manage it, and the agent discovers the account via `list_accounts`. The agent is not involved in authentication or billing — those are handled between the advertiser and seller directly.

**Typical sellers:** Social platforms, self-serve ad platforms — anywhere the advertiser already has an account.

**Workflow:**

1. Advertiser creates an account on the seller's platform (out-of-band)
2. Advertiser grants the operator permission to manage the account (out-of-band)
3. Agent calls `list_accounts` to discover available accounts
4. Human selects the correct account from the list
5. Agent passes `{ "account_id": "acc_acme_001" }` on every request (`get_products`, `create_media_buy`, etc.)

The agent doesn't set up accounts, negotiate billing, or manage authentication with the seller. It just discovers what already exists and lets the human choose.

### Implicit account IDs

The agent manages the buying relationship. It calls `sync_accounts` to tell the seller who's advertising, who's operating the seat, and who's paying. The seller provisions accounts and responds with status — the account IDs are a byproduct of the declaration, not something the buyer needs to know upfront.

**Typical sellers:** Traditional publishers, retail media networks — anywhere the buying relationship is established programmatically.

`sync_accounts` is the declaration tool. Each entry is a set of flags that tells the seller what the buyer needs:

| Flag | What it tells the seller |
|------|-------------------------|
| `brand` (`domain` + optional `brand_id`) | Which brand is advertising |
| `operator` | Who operates the seat (agency, trading desk) |
| `billing` | Who gets the invoice — `operator` or `agent` |
| `sandbox` | Whether this is a test account |

Every combination of flags that might require the seller to do something different — bill a different entity, set up a different rate card, create a sandbox — is a distinct declaration.

**Workflow:**

1. Agent calls `sync_accounts` with one or more declarations
2. Seller provisions or links accounts for each, responds with status:
   - `active` — ready to use
   - `pending_approval` — seller reviewing (human may need to visit `setup.url`)
   - `rejected` — seller declined the request
3. For subsequent requests, pass either:
   - `{ "account_id": "acc_acme_001" }` — using the ID the seller returned
   - `{ "brand": { "domain": "acme-corp.com", "brand_id": "bolt" }, "operator": "pinnacle-media.com" }` — if the seller supports `implicit_from_sync` resolution
4. When anything changes (billing model, new brand, new operator), call `sync_accounts` again

The agent may be involved in billing (when `billing` is `"agent"` or `"operator"`). The seller may require human approval before activating accounts.

### Natural key semantics

The tuple `(brand, operator)` uniquely identifies an account relationship. The `brand` is a nested object with `domain` and optional `brand_id`. `operator` is always required — when the brand operates its own seat, set `operator` to the brand's domain. For example, `{brand: {domain: "acme-corp.com"}, operator: "acme-corp.com"}` (brand buying direct) is a different account from `{brand: {domain: "acme-corp.com"}, operator: "pinnacle-media.com"}` (brand via agency).

See [sync_accounts task reference](/docs/accounts/tasks/sync_accounts) for the full request/response schema.

### Account status

| Status | Meaning | Next step |
|--------|---------|-----------|
| `active` | Ready to use | Place buys on this account |
| `pending_approval` | Seller reviewing | Human may need to visit `setup.url`. Poll `list_accounts` for updates. |
| `rejected` | Seller declined the request | Review rejection reason, adjust and re-sync, or contact seller |
| `payment_required` | Credit limit reached | Add funds or route spend to other accounts |
| `suspended` | Was active, now paused | Contact seller |
| `closed` | Was active, now terminated | — |

### Account scope

The agent requests accounts by natural key — `(brand, operator)`. The seller decides what granularity to assign. The `account_scope` field in the response tells the agent how the seller resolved the request:

| Scope | Meaning | Example |
|-------|---------|---------|
| `operator` | One account for all brands under this operator | Agent sends (Pinnacle Media, Acme) and (Pinnacle Media, Nova) — seller maps both to the Pinnacle Media account |
| `brand` | One account for this brand regardless of operator | Agent sends (Acme, Pinnacle Media) and (Acme, Summit Agency) — seller maps both to the Acme account |
| `operator_brand` | Dedicated account for this operator+brand pair | Agent sends (Pinnacle Media, Acme) — seller creates a specific Acme-via-Pinnacle account |
| `agent` | The agent's default account | Agent sends any brand — seller routes to the standing agent account |

The agent does not choose the scope — the seller assigns it based on its own account policy. An agent requesting `(brand: {domain: "acme-corp.com"}, operator: "pinnacle-media.com")` might receive an operator-scoped account, a brand-scoped account, or a dedicated operator_brand account depending on the seller.

When multiple natural keys resolve to the same `account_id`, the `account_scope` explains why. The agent should use the returned `account_id` for subsequent operations regardless of scope.

### account_id and rejected accounts

`account_id` is present in all `sync_accounts` responses and `list_accounts` results except when `status` is `rejected` (seller declined the account request — no account was created).

Pending accounts (`pending_approval`) always have an `account_id` — the seller has acknowledged the relationship and assigned an identifier even though approval is in progress.

## Error codes

| Code | When returned | Resolution |
|------|-------------|------------|
| `ACCOUNT_REQUIRED` | Multiple accounts; seller can't determine which | Pass `account_id` in the account reference |
| `ACCOUNT_NOT_FOUND` | `account_id` doesn't exist or agent lacks access | Check account reference, re-run `sync_accounts` |
| `ACCOUNT_SETUP_REQUIRED` | Natural key resolved but account needs setup | Check `details.setup` for URL/message |
| `ACCOUNT_AMBIGUOUS` | Natural key resolves to multiple accounts | Pass `account_id` or more specific natural key |
| `PAYMENT_REQUIRED` | Credit limit reached or funds depleted | Add funds, route to another account |
| `ACCOUNT_SUSPENDED` | Account not in good standing | Contact seller |
| `BRAND_REQUIRED` | Billable operation without brand reference | Include `brand` in request |

When the seller returns `ACCOUNT_REQUIRED`, it includes the available accounts:

```json
{
  "errors": [{
    "code": "ACCOUNT_REQUIRED",
    "message": "Multiple accounts available. Please specify account_id in the account reference.",
    "details": {
      "available_accounts": [
        { "account_id": "acc_acme_001", "name": "Acme Corp" },
        { "account_id": "acc_pinnacle", "name": "Pinnacle Media" }
      ]
    }
  }]
}
```

## Design notes

### sync_accounts and seller record systems

When an agent declares `(brand: {domain: "acme-corp.com"}, operator: "pinnacle-media.com")`, the seller looks up or creates records in its own system — CRM, OMS, ad server, or billing platform. The `account_id` returned is the seller's internal identifier for that relationship.

This means `sync_accounts` is not just "account creation" — it's the buyer-side interface to the seller's record system. The seller may:

- Map the natural key to an existing account and return it
- Create a new record and return it immediately (`status: "active"`)
- Create a placeholder pending human review (`status: "pending_approval"`)
- Decline the request entirely (`status: "rejected"`)

`list_accounts` returns all records the seller has mapped for this agent — including pending and rejected entries. The agent uses `list_accounts` to see the full state of its portfolio with this seller, not just active accounts.

### Accounts and insertion orders

An account represents a standing relationship — who gets billed, what rates apply, what credit is available. It is not a campaign or an insertion order.

Insertion orders and campaign flights are modeled as media buys via `create_media_buy`. The account determines *billing terms*; the media buy determines *what runs and when*. A single account can have many media buys over its lifetime.

### Operator revocation and caching

If a brand removes an operator from `authorized_operators`, existing active accounts are not automatically deactivated. Revocation is eventual, not immediate — similar to how `ads.txt` changes propagate on the supply side.

Sellers SHOULD respect standard HTTP caching headers on `brand.json` and re-validate periodically. A reasonable cache TTL is 24 hours.

### Brand identity for SMBs

Domain-based identity via `/.well-known/brand.json` works for organizations of any size — it's a static JSON file that can be hosted on any web server.

For organizations that cannot host files on their domain, the `authoritative_location` field in `brand.json` allows the house domain to redirect to a hosted location:

```json
{
  "house": {
    "domain": "local-bakery.com"
  },
  "authoritative_location": "https://registry.agenticadvertising.org/brands/local-bakery.com"
}
```
