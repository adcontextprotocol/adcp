---
title: Accounts and Agents
description: How AdCP identifies who is advertised, who pays, and who operates
---

AdCP distinguishes three entities in every billable operation:

| Entity | Question | How Identified |
|--------|----------|----------------|
| **Brand** | Whose products are advertised? | House domain + brand_id ([brand.json](/docs/brand-protocol/brand-json)) |
| **Account** | Who gets billed? What rates apply? | `account_id` |
| **Operator** | Who operates the seat? | Domain (e.g., `groupm.com`) |
| **Agent** | What software is placing the buy? | Authenticated session (see [Trust Model](#trust-model)) |

## Core Concepts

### Brand

The **brand** is the advertiser whose products or services are being promoted. Brands are identified canonically by their house domain + brand_id, resolved via `/.well-known/brand.json`.

For example, Dove is identified as `house: "unilever.com"` + `brand_id: "dove"`. Any party can resolve `unilever.com/.well-known/brand.json` to verify Dove's identity, assets, and authorized operators.

For single-brand houses like Acme Corp, the house domain alone (`house: "acme-corp.com"`) identifies the brand — no `brand_id` is needed.

Every billable operation requires a [brand](/docs/brand-protocol/brand-json) reference that identifies the brand and provides context for ad serving.

### Account

An **account** represents a billing relationship between a buyer and a seller. The account determines:

- **Rate card**: What prices apply (negotiated discounts, volume tiers)
- **Billing entity**: Who receives invoices
- **Payment terms**: Net 30, prepay, etc.
- **Credit limit**: Maximum outstanding balance

### Operator

The **operator** is the entity driving the buys — an agency trading desk, the brand's internal team, or another entity acting on behalf of the advertiser. Operators are identified by domain (e.g., `groupm.com`, `mindshare.com`) and can be verified against the brand's `authorized_operators` in `brand.json`.

### Agent

An **agent** is the software placing buys and managing campaigns. The agent authenticates with the seller and may operate on behalf of one or more operators and brands.

## Billing

Every account has a billing model that determines who gets invoiced:

| Billing | Who is invoiced | Use case |
|---------|----------------|----------|
| `brand` | Brand directly | Brand has direct relationship with seller |
| `operator` | Operator (agency) | Agency buying on their own terms |
| `agent` | Agent | Agent consolidates billing across brands |

### Examples

**Brand buys direct** — Acme Corp has their own account on the seller:
```
Billing: brand
Invoice: Seller → Acme Corp
Rates: Acme Corp's negotiated rates
```

**Agency buys for brand, brand pays** — GroupM buys on Unilever's account:
```
Billing: brand
Invoice: Seller → Unilever
Rates: Unilever's negotiated rates
Operator: GroupM (authorized via brand.json)
```

**Agency buys on own account** — GroupM uses their own rates:
```
Billing: operator
Invoice: Seller → GroupM
Rates: GroupM's rates
```

**Agent consolidates billing** — AI buying platform bills centrally:
```
Billing: agent
Invoice: Seller → Agent
Rates: Agent's rates
Agent re-bills individual brands and operators
```

### Agent account

When `supported_billing` includes `"agent"`, the seller pre-provisions an **agent account**: a top-level billing relationship between the seller and the agent, with no brand or operator association. It serves as the billing parent for all agent-billed sub-accounts.

When a sub-account is created with `billing: "agent"`, the seller links it to the agent account via `parent_account_id`. The agent receives a single consolidated invoice and is responsible for re-billing individual brands and operators on its side.

When `default_billing: "agent"`, the agent account also acts as the **fallback**: buys without a direct brand account route to the agent account automatically, without requiring a separate `sync_accounts` call first.

## Account Setup

The seller declares account capabilities in `get_adcp_capabilities`:

```json
{
  "account": {
    "supported_billing": ["brand", "agent"],
    "required_for_products": true
  }
}
```

| Field | Description |
|-------|-------------|
| `require_operator_auth` | Whether the seller requires operator-level credentials. Default: `false`. |
| `authorization_endpoint` | OAuth URL for obtaining operator credentials. Present when the seller supports OAuth for operator authentication. |
| `supported_billing` | Which billing models the seller supports: `brand`, `operator`, `agent` |
| `default_billing` | The billing model applied when the agent omits `billing` from sync_accounts. |
| `required_for_products` | Whether `get_products` requires an `account_id`. When true, set up an account before browsing. |

### Seller billing patterns

Sellers combine auth model and billing support in different ways. The four common patterns:

| Pattern | `require_operator_auth` | `supported_billing` | `default_billing` | Agent account |
|---------|------------------------|--------------------|--------------------|---------------|
| Operator-gated | `true` | `["brand", "operator"]` | — | No |
| Direct-only | `false` | `["brand", "operator"]` | — | No |
| Agent-consolidated | `false` | `["agent"]` | `"agent"` | Yes |
| Hybrid | `false` | `["brand", "operator", "agent"]` | `"agent"` | Yes (fallback) |

**Operator-gated** — Each operator authenticates directly with the seller (via OAuth or API key). No agent-level billing — every account has a direct billing relationship. Typical for premium publishers and platforms that enforce per-operator contract compliance.

**Direct-only** — The seller trusts the agent's identity but requires a direct account for every brand or operator. Operators listed in `brand.json` may be provisioned instantly; others go through `pending_approval` until T&C are signed out-of-band. No agent account — the agent cannot buy without a direct account for the advertiser.

**Agent-consolidated** — All billing flows through the agent. The seller maintains a single agent account and creates sub-accounts per brand/operator immediately (no pending approval needed). The agent handles re-billing. Typical for DSP-style sellers and subscription content platforms.

**Hybrid** — Both paths are available. Direct accounts (brand or operator billing) give buyers their own rate cards and invoicing with the seller. The agent account serves as the fallback — buys without a specific direct account route to the agent account automatically. Typical for sellers serving both direct buyers and programmatic buyers.

### Trust Model

The `require_operator_auth` flag determines who authenticates to the seller.

**`require_operator_auth: false`** (default, agent-trusted) — The seller trusts the agent's identity claims. The agent authenticates once with its own bearer token, then calls `sync_accounts` to declare which brands and operators it represents. The seller provisions accounts based on the agent's claims, optionally verifying operators against `brand.json`. All subsequent calls use the agent's single credential.

**`require_operator_auth: true`** (operator-scoped) — The seller requires operator-level credentials. Each operator must authenticate independently with the seller (via OAuth if `authorization_endpoint` is provided, or out-of-band via seller portal / API key). The agent obtains a credential per operator, opens a separate session per operator, and calls `sync_accounts` within each session to declare brands. The operator's credential — not the agent's — authorizes all calls in that session.

### Agent Workflow

**Agent-trusted** (`require_operator_auth: false`):
```
1. get_adcp_capabilities → learn supported_billing, required_for_products
2. sync_accounts → declare brands, operators, billing (using agent's own token)
3. Wait for account status = active (poll list_accounts if pending)
4. get_products with account_id
5. create_media_buy with account_id (optional for single-account agents)
```

**Operator-scoped** (`require_operator_auth: true`):
```
1. get_adcp_capabilities → learn require_operator_auth, authorization_endpoint
2. For each operator:
   a. Obtain operator's credential (OAuth via authorization_endpoint, or API key)
   b. Open a new session with the operator's credential
   c. sync_accounts → declare brands for this operator
   d. list_accounts → discover existing accounts
3. Wait for account status = active
4. get_products / create_media_buy using the operator's session
```

## sync_accounts

The `sync_accounts` task lets an agent declare its advertiser portfolio to a seller with upsert semantics. The agent specifies which brands it represents, who operates each seat, and the billing model. The seller responds with per-account status.

### Request

Each account entry identifies the brand by house domain + brand_id, the operator by domain, and who should be invoiced:

```json
{
  "task": "sync_accounts",
  "accounts": [
    {
      "house": "unilever.com",
      "brand_id": "dove",
      "operator": "mindshare.com",
      "billing": "brand"
    },
    {
      "house": "pg.com",
      "brand_id": "tide",
      "operator": "groupm.com",
      "billing": "agent"
    },
    {
      "house": "acme-corp.com",
      "billing": "brand"
    }
  ]
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `house` | Yes | House domain where `brand.json` is hosted. For single-brand houses, this alone identifies the brand. |
| `brand_id` | No | Brand ID within the house portfolio. Required when the house has multiple brands. |
| `operator` | No | Domain of the entity operating the seat. Omit if the brand operates its own seat. |
| `billing` | No | Who should be invoiced: `brand`, `operator`, or `agent`. Omit to accept the seller's default. The seller returns the actual billing model in the sync_accounts response, so the agent always knows what was applied. |

**Natural key:** The tuple `(house, brand_id, operator)` uniquely identifies an account relationship. Missing fields are distinct from present fields — `{house: "acme-corp.com"}` (brand buying direct) is a different account from `{house: "acme-corp.com", operator: "groupm.com"}` (brand via agency). The seller uses this natural key for upsert matching across sync calls.

### Response

The seller responds with per-account results. Each account has an action (what happened) and a status (durable state):

```json
{
  "accounts": [
    {
      "account_id": "sub_tide_001",
      "house": "pg.com",
      "brand_id": "tide",
      "operator": "groupm.com",
      "name": "Tide (via GroupM)",
      "action": "created",
      "status": "active",
      "billing": "agent",
      "parent_account_id": "acc_agent_house"
    },
    {
      "account_id": "acc_acme_pending",
      "house": "acme-corp.com",
      "name": "Acme Corp",
      "action": "created",
      "status": "pending_approval",
      "billing": "brand",
      "setup": {
        "url": "https://seller.com/credit-app/acme-corp",
        "message": "Credit application required for direct billing"
      }
    }
  ]
}
```

### Action vs Status

Each account in the response has two fields:

- **`action`**: What happened during *this* sync operation — `created`, `updated`, `unchanged`, or `failed`
- **`status`**: The durable state of the account — `active`, `pending_approval`, `payment_required`, `suspended`, or `closed`

An account can be `action: "created"` with `status: "pending_approval"` (new account, waiting for credit check) or `action: "unchanged"` with `status: "active"` (already exists, nothing changed).

### Account Status

| Status | Meaning | Next step |
|--------|---------|-----------|
| `active` | Ready to use | Agent can place buys on this account |
| `pending_approval` | Seller reviewing | Human may need to visit `setup.url` to complete credit/legal process. Poll `list_accounts` for updates. |
| `payment_required` | Credit limit reached or funds depleted | Add funds or increase credit limit. The agent should route spend to other accounts or prompt the buyer. |
| `suspended` | Was active, now paused | Contact seller to resolve |
| `closed` | Terminated | — |

### Billing Negotiation

The seller may return a different `billing` value than the agent requested. For example, if a seller doesn't support direct billing, it may route billing through the agent instead:

```json
{
  "account_id": "acc_agent_house",
  "house": "acme-corp.com",
  "action": "created",
  "status": "active",
  "billing": "agent",
  "warnings": ["Direct billing (brand) not supported. Mapped to agent billing."]
}
```

The agent should check the returned `billing` and inform the buyer if it differs from what was requested.

### delete_missing Scope

When `delete_missing: true`, the seller deactivates accounts that were previously synced by **this agent** but are not included in the current request. It does not affect accounts managed by other agents.

For example, if Agent A syncs `[dove, axe]` and Agent B syncs `[dove, tide]`, then Agent B calls sync with `delete_missing: true` and `[dove]` — only `tide` is deactivated (Agent B's account not in the new list). Agent A's `axe` account is unaffected.

The scope is always the authenticated agent's portfolio at this seller. Use `dry_run: true` to preview deactivations before committing.

## Authorized Operators

Brands declare who can represent them in `/.well-known/brand.json` via the `authorized_operators` field. This enables sellers to verify that an operator is authorized to act on a brand's behalf.

```json
{
  "house": {
    "domain": "unilever.com",
    "name": "Unilever"
  },
  "brands": [
    { "id": "dove", "names": [{"en": "Dove"}] },
    { "id": "axe", "names": [{"en": "Axe"}] }
  ],
  "authorized_operators": [
    {
      "domain": "mindshare.com",
      "brands": ["dove", "axe"],
      "countries": ["US", "GB", "DE"]
    },
    {
      "domain": "dentsu.co.jp",
      "brands": ["dove"],
      "countries": ["JP"]
    },
    {
      "domain": "unilever.com",
      "brands": ["*"]
    }
  ]
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `domain` | Yes | Operator's domain |
| `brands` | Yes | Brand IDs this operator can represent. `["*"]` means all brands. |
| `countries` | No | ISO 3166-1 alpha-2 country codes. Omit for global authorization. |

### Verification Flow

When an agent syncs an account with a third-party operator, sellers SHOULD verify the operator against `brand.json`. The verification flow:

1. Resolve `{house}/.well-known/brand.json`
2. Check `authorized_operators` for matching `domain` with the brand in `brands`
3. If found → proceed (account may still need credit/legal approval)
4. If not found → reject the account (`action: "failed"`) or return `pending_approval` for manual review

Verification is a trust signal, not a gate. In agent-trusted mode (`require_operator_auth: false`), finding the operator in `brand.json` lets the seller fast-track provisioning. If the operator isn't listed, the seller can still approve the account through its own review process — `pending_approval` covers this.

In operator-scoped mode (`require_operator_auth: true`), the operator authenticates directly, so the seller already knows who they are.

**Self-authorization is implicit.** A brand operating its own accounts does not need to list itself in `authorized_operators`. When `operator` is omitted from a sync_accounts request, or when the operator domain matches the house domain, the brand is operating its own seat.

### Scope and Hierarchy

`authorized_operators` models the **interface** between the brand and whoever holds the seat at the seller. It does not model internal hierarchies on either side:

- **Agency side**: If WPP holds the seat, `operator: "wpp.com"`. If Mindshare holds it, `operator: "mindshare.com"`. WPP's internal delegation to GroupM to Mindshare is the agency's business.
- **Brand side**: The house domain + brand_id identifies the brand. The parent/sub-brand hierarchy (Keller types) is in brand.json for anyone who needs it, but for seat mapping, house + brand_id is sufficient.

The protocol models interfaces between parties, not internal org charts.

## list_accounts

Returns accounts the authenticated agent can operate.

**Request:**
```json
{
  "task": "list_accounts"
}
```

**Response:**
```json
{
  "accounts": [
    {
      "account_id": "acc_acme_pinnacle",
      "name": "Acme c/o Pinnacle",
      "advertiser": "Acme Corp",
      "billing_proxy": "Pinnacle Media",
      "status": "active",
      "house": "acme-corp.com",
      "billing": "brand"
    },
    {
      "account_id": "acc_agent_house",
      "name": "Agent House Account",
      "status": "active",
      "billing": "agent"
    },
    {
      "account_id": "acc_dove_pending",
      "name": "Dove",
      "status": "pending_approval",
      "house": "unilever.com",
      "brand_id": "dove",
      "billing": "brand"
    }
  ]
}
```

## Request Context

### Required: Brand

Every billable operation must include the brand reference:

```json
{
  "brand": {
    "domain": "acme-corp.com"
  }
}
```

### Account ID

Agents with multiple accounts must pass `account_id` on billable operations. Single-account agents can omit it — the seller infers the account. The agent gets account IDs from `sync_accounts` (or `list_accounts` for OAuth-connected accounts):

```json
{
  "account_id": "acc_acme_pinnacle",
  "brand": { "domain": "acme-corp.com" }
}
```

The `account_id` is the seller's identifier for the billing relationship. The agent's natural key is `(house, brand_id, operator)` -- but the seller maps that to an `account_id` during account setup, and the agent uses that ID on all subsequent operations.

For `get_products`, whether `account_id` is required depends on the seller's capabilities (`account.required_for_products`). When required, the seller uses the account to determine rate-card-specific pricing and available inventory.

## Error Responses

### ACCOUNT_REQUIRED

Returned when the seller cannot determine which account to use:

```json
{
  "errors": [
    {
      "code": "ACCOUNT_REQUIRED",
      "message": "Multiple accounts available. Please specify account_id.",
      "details": {
        "available_accounts": [
          { "account_id": "acc_acme_pinnacle", "name": "Acme c/o Pinnacle" },
          { "account_id": "acc_pinnacle", "name": "Pinnacle" }
        ]
      }
    }
  ]
}
```

### ACCOUNT_NOT_FOUND

The specified account does not exist or the agent does not have access:

```json
{
  "errors": [
    {
      "code": "ACCOUNT_NOT_FOUND",
      "message": "Account 'acc_xyz' not found or not accessible"
    }
  ]
}
```

### PAYMENT_REQUIRED

The account has reached its credit limit or run out of funds:

```json
{
  "errors": [
    {
      "code": "PAYMENT_REQUIRED",
      "message": "Account 'acc_acme_pinnacle' has reached its credit limit"
    }
  ]
}
```

### ACCOUNT_SUSPENDED

The account exists but is not in good standing:

```json
{
  "errors": [
    {
      "code": "ACCOUNT_SUSPENDED",
      "message": "Account 'acc_acme_pinnacle' is suspended"
    }
  ]
}
```

### BRAND_REQUIRED

Billable operation attempted without brand reference:

```json
{
  "errors": [
    {
      "code": "BRAND_REQUIRED",
      "message": "Brand is required for this operation"
    }
  ]
}
```

## Scenarios

### Scenario 1: Brand buying direct on a publisher

Acme Corp wants to buy inventory on a premium publisher. Their in-house team operates the seat directly.

**Step 1**: Agent syncs the account:
```json
{
  "task": "sync_accounts",
  "accounts": [{
    "house": "acme-corp.com",
    "billing": "brand"
  }]
}
```

**Step 2**: Seller responds — credit check needed:
```json
{
  "accounts": [{
    "account_id": "acc_acme_001",
    "house": "acme-corp.com",
    "action": "created",
    "status": "pending_approval",
    "billing": "brand",
    "setup": {
      "url": "https://publisher.com/advertiser-onboard",
      "message": "Complete advertiser registration and credit application"
    }
  }]
}
```

**Step 3**: Human at Acme Corp completes the setup at the URL. Agent polls `list_accounts` until the account becomes `active`.

**Step 4**: Agent places buys using the account:
```json
{
  "account_id": "acc_acme_001",
  "brand": { "domain": "acme-corp.com" },
  "campaign": { "..." : "..." }
}
```

### Scenario 2: Agency buying for multiple brands on a DSP

GroupM operates buying seats on a DSP for multiple advertisers. Billing goes through the agent.

**Step 1**: Agent syncs all advertisers:
```json
{
  "task": "sync_accounts",
  "accounts": [
    {
      "house": "unilever.com",
      "brand_id": "dove",
      "operator": "groupm.com",
      "billing": "agent"
    },
    {
      "house": "pg.com",
      "brand_id": "tide",
      "operator": "groupm.com",
      "billing": "agent"
    }
  ]
}
```

**Step 2**: DSP provisions sub-accounts immediately (no approval needed — billing goes through the agent):
```json
{
  "accounts": [
    {
      "account_id": "sub_dove_001",
      "house": "unilever.com",
      "brand_id": "dove",
      "action": "created",
      "status": "active",
      "billing": "agent",
      "parent_account_id": "acc_groupm_house"
    },
    {
      "account_id": "sub_tide_001",
      "house": "pg.com",
      "brand_id": "tide",
      "action": "created",
      "status": "active",
      "billing": "agent",
      "parent_account_id": "acc_groupm_house"
    }
  ]
}
```

Both sub-accounts are active immediately. GroupM receives a single consolidated invoice from the DSP.

### Scenario 3: Agency needs brand authorization on a publisher

Mindshare wants to buy on Unilever's existing publisher account (Unilever's rates, Unilever's invoice). The publisher needs Unilever to authorize Mindshare.

**Step 1**: Agent syncs the account:
```json
{
  "task": "sync_accounts",
  "accounts": [{
    "house": "unilever.com",
    "brand_id": "dove",
    "operator": "mindshare.com",
    "billing": "brand"
  }]
}
```

**Step 2**: Seller checks `unilever.com/.well-known/brand.json` and finds Mindshare in `authorized_operators` for Dove in the US:
```json
{
  "authorized_operators": [{
    "domain": "mindshare.com",
    "brands": ["dove", "axe"],
    "countries": ["US", "GB", "DE"]
  }]
}
```

**Step 3**: Since Mindshare is pre-authorized, the seller skips the authorization step and proceeds to account provisioning. If credit is already established for Unilever:
```json
{
  "accounts": [{
    "account_id": "acc_unilever_dove",
    "house": "unilever.com",
    "brand_id": "dove",
    "operator": "mindshare.com",
    "action": "created",
    "status": "active",
    "billing": "brand",
    "rate_card": "unilever_2026"
  }]
}
```

If Mindshare were *not* in `authorized_operators`, the seller could return `pending_approval` for manual review, or reject the account outright.

### Scenario 4: Seller doesn't support direct billing

An agent requests direct billing for an advertiser, but the seller only supports billing through the agent.

**Step 1**: Agent requests brand billing:
```json
{
  "task": "sync_accounts",
  "accounts": [{
    "house": "acme-corp.com",
    "billing": "brand"
  }]
}
```

**Step 2**: Seller maps to agent billing and explains:
```json
{
  "accounts": [{
    "account_id": "acc_agent_house",
    "house": "acme-corp.com",
    "action": "created",
    "status": "active",
    "billing": "agent",
    "warnings": ["Direct billing (brand) not supported. Mapped to agent billing."]
  }]
}
```

The agent should inform the buyer that billing will be consolidated through the agent rather than invoiced directly by the seller.

## Authentication

All AdCP sessions use OAuth 2.0 bearer tokens. Whose credential is on the wire depends on the seller's `require_operator_auth` setting:

**Agent-trusted** (`require_operator_auth: false`): The bearer token identifies the agent. The agent holds a single credential and operates on behalf of all its brands and operators. Account access is scoped by `account_id` on each request.

**Operator-scoped** (`require_operator_auth: true`): The bearer token identifies the operator. The agent obtains a separate credential per operator (via OAuth or API key), then opens a dedicated session per operator. All calls within that session are authorized by the operator's credential.

```
Authorization: Bearer <token>
```

The protocol does not mandate how operator credentials are obtained. If the seller provides an `authorization_endpoint`, agents can initiate OAuth programmatically. Otherwise, operators obtain credentials out-of-band (seller portal, direct API key issuance).

See [Authentication](/docs/building/integration/authentication) for details.

## Design Notes

### Accounts and Insertion Orders

An account represents a standing relationship between a buyer and seller — who gets billed, what rates apply, what credit is available. It is not a campaign or an insertion order.

Insertion orders, campaign flights, and other time-bound spending commitments are modeled as media buys via `create_media_buy`. The account determines *billing terms*; the media buy determines *what runs and when*.

A single account can have many media buys over its lifetime, just as a single advertiser relationship can encompass many campaigns.

### Operator Revocation and Caching

If a brand removes an operator from `authorized_operators`, existing active accounts are not automatically deactivated. Revocation is eventual, not immediate — similar to how `ads.txt` changes propagate on the supply side.

Sellers SHOULD respect standard HTTP caching headers on `brand.json` and re-validate periodically. A reasonable cache TTL is 24 hours. Sellers that need tighter revocation guarantees can implement shorter cache windows or accept push notifications from brands out-of-band.

### Brand Identity for SMBs

Domain-based identity via `/.well-known/brand.json` works for organizations of any size. `brand.json` is a static JSON file that can be hosted on any web server — no special infrastructure is required.

For organizations that cannot host files on their domain, the `authoritative_location` field in `brand.json` allows the house domain to redirect to a hosted location (e.g., AgenticAdvertising.org's brand registry). The domain owner sets up a single redirect; the registry hosts the actual brand metadata.

```json
{
  "house": {
    "domain": "local-bakery.com"
  },
  "authoritative_location": "https://registry.agenticadvertising.org/brands/local-bakery.com"
}
```

## Summary

| Aspect | Protocol Defines | Seller Declares |
|--------|------------------|-----------------|
| Brand identity | House domain + brand_id via brand.json | Resolution and caching |
| Account capabilities | `account` section in capabilities | `require_operator_auth`, `authorization_endpoint`, `supported_billing`, `required_for_products` |
| Account setup | `sync_accounts` task with status lifecycle | Provisioning, credit, legal |
| Billing | Three models: brand, operator, agent | Which models are supported; whether agent account exists |
| Operator authorization | `authorized_operators` in brand.json | Verification and enforcement |
| Account status | Standard status values with setup URLs | Status transitions and notifications |
| Account ID | Required when agent has multiple accounts | Mapping from brand+operator to account |
| Agent identity | From auth token | Authentication |
| Error codes | Standard codes | When to return |
