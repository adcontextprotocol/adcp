---
title: Accounts and agents
description: How sellers configure account capabilities and how buyer agents set up accounts
---

AdCP distinguishes four entities in every billable operation:

| Entity | Question | How identified |
|--------|----------|----------------|
| **Brand** | Whose products are advertised? | House domain + brand_id ([brand.json](/docs/brand-protocol/brand-json)) |
| **Account** | Who gets billed? What rates apply? | `account_id` |
| **Operator** | Who operates the seat? | Domain (e.g., `pinnacle-media.com`) |
| **Agent** | What software is placing the buy? | Authenticated session |

See [Accounts Protocol overview](/docs/accounts/overview) for the full commercial model and [sync_accounts](/docs/accounts/tasks/sync_accounts) for the task reference.

## What sellers declare

Sellers configure four fields in the `account` section of [`get_adcp_capabilities`](/docs/protocol/get_adcp_capabilities#account):

**1. Which billing models do you support?** (`supported_billing`)

| Billing | Who is invoiced | Use case |
|---------|----------------|----------|
| `brand` | Brand directly | Brand has direct relationship with seller |
| `operator` | Operator (agency) | Agency buying on their own terms |
| `agent` | Agent | Agent consolidates billing across brands |

**2. Do you require operator-level auth?** (`require_operator_auth`)

When `false` (default): the seller trusts the agent. The agent authenticates once and declares brands/operators via `sync_accounts`.

When `true`: each operator must authenticate with the seller directly. The agent obtains a credential per operator — via OAuth using the seller's `authorization_endpoint`, or via API key out-of-band.

**3. What's the default billing model?** (`default_billing`)

Applied when the agent omits `billing` from `sync_accounts`. When set to `"agent"`, the seller pre-provisions a default account — a standing account with no brand or operator association — that buys route through automatically.

**4. Must buyers have an account before browsing?** (`required_for_products`)

When `true`, calls to `get_products` require an `account_id`. When `false` (default), products are browsable without an account.

**Example capabilities:**

```json
{
  "account": {
    "require_operator_auth": false,
    "supported_billing": ["brand", "operator", "agent"],
    "default_billing": "agent",
    "required_for_products": false
  }
}
```

These four fields combine into four common patterns.

## Seller patterns

| Pattern | `require_operator_auth` | `supported_billing` | `default_billing` | Default account |
|---------|------------------------|--------------------|--------------------|-----------------|
| Operator-gated | `true` | `["brand", "operator"]` | — | No |
| Direct-only | `false` | `["brand", "operator"]` | — | No |
| Agent-consolidated | `false` | `["agent"]` | `"agent"` | Yes |
| Hybrid | `false` | `["brand", "operator", "agent"]` | `"agent"` | Yes (fallback) |

### Operator-gated

Each operator authenticates directly with the seller. No agent-level billing — every account has a direct billing relationship. Typical for premium publishers and platforms that enforce per-operator contract compliance.

**Capabilities:**

```json
{
  "account": {
    "require_operator_auth": true,
    "supported_billing": ["brand", "operator"],
    "authorization_endpoint": "https://seller.example.com/oauth/authorize",
    "required_for_products": true
  }
}
```

**Buyer workflow:**

1. Call `get_adcp_capabilities` — see `require_operator_auth: true` and `authorization_endpoint`
2. For each operator:
   a. Obtain operator's credential (OAuth via `authorization_endpoint`, or API key out-of-band)
   b. Open a new session with the operator's credential
   c. Call `sync_accounts` to declare brands for this operator
3. Wait for account status `active` (poll `list_accounts` if `pending_approval`)
4. Call `get_products` / `create_media_buy` using the operator's session

**sync_accounts example:**

```json
{
  "accounts": [{
    "house": "nova-brands.com",
    "brand_id": "spark",
    "operator": "pinnacle-media.com",
    "billing": "brand"
  }]
}
```

Seller checks `nova-brands.com/.well-known/brand.json`, finds Pinnacle Media in `authorized_operators`, and fast-tracks provisioning:

```json
{
  "accounts": [{
    "account_id": "acc_nova_spark",
    "house": "nova-brands.com",
    "brand_id": "spark",
    "operator": "pinnacle-media.com",
    "action": "created",
    "status": "active",
    "billing": "brand"
  }]
}
```

**Key point:** The operator's credential — not the agent's — authorizes all calls in that session. Brand.json verification is secondary to the credential.

### Direct-only

The seller trusts the agent's identity but requires a direct account for every brand or operator. Operators listed in `brand.json` may be provisioned instantly; others go through `pending_approval` until T&C are signed out-of-band. No default account — the agent cannot buy without a direct account.

**Capabilities:**

```json
{
  "account": {
    "supported_billing": ["brand", "operator"],
    "required_for_products": true
  }
}
```

**Buyer workflow:**

1. Call `get_adcp_capabilities` — see `require_operator_auth` absent (defaults to `false`)
2. Call `sync_accounts` with brands and operators (using agent's own token)
3. Wait for account status `active` — may require human to complete credit/legal at `setup.url`
4. Call `get_products` with `account_id`
5. Call `create_media_buy` with `account_id`

**sync_accounts example — brand buying direct:**

```json
{
  "accounts": [{
    "house": "acme-corp.com",
    "billing": "brand"
  }]
}
```

Seller responds — credit check needed:

```json
{
  "accounts": [{
    "account_id": "acc_acme_001",
    "house": "acme-corp.com",
    "action": "created",
    "status": "pending_approval",
    "billing": "brand",
    "setup": {
      "url": "https://seller.example.com/advertiser-onboard",
      "message": "Complete advertiser registration and credit application"
    }
  }]
}
```

Human at Acme Corp completes the setup at the URL. Agent polls `list_accounts` until the account becomes `active`.

**Key point:** `pending_approval` is the normal path. Every buyer needs a direct relationship with the seller.

### Agent-consolidated

All billing flows through the agent. The seller pre-provisions a default account and creates per-brand/operator accounts immediately — no pending approval needed. The agent handles re-billing. Typical for DSP-style sellers and subscription content platforms.

**Capabilities:**

```json
{
  "account": {
    "supported_billing": ["agent"],
    "default_billing": "agent"
  }
}
```

**Buyer workflow:**

1. Call `get_adcp_capabilities` — see `supported_billing: ["agent"]` and `default_billing: "agent"`
2. Call `sync_accounts` to declare brands and operators (billing is always `agent`)
3. Accounts are active immediately — no human approval needed
4. Call `get_products` / `create_media_buy` with `account_id`

**sync_accounts example:**

```json
{
  "accounts": [
    {
      "house": "nova-brands.com",
      "brand_id": "spark",
      "operator": "pinnacle-media.com",
      "billing": "agent"
    },
    {
      "house": "acme-corp.com",
      "brand_id": "bolt",
      "operator": "pinnacle-media.com",
      "billing": "agent"
    }
  ]
}
```

Both accounts active immediately:

```json
{
  "accounts": [
    {
      "account_id": "acc_spark_001",
      "house": "nova-brands.com",
      "brand_id": "spark",
      "operator": "pinnacle-media.com",
      "action": "created",
      "status": "active",
      "billing": "agent"
    },
    {
      "account_id": "acc_bolt_001",
      "house": "acme-corp.com",
      "brand_id": "bolt",
      "operator": "pinnacle-media.com",
      "action": "created",
      "status": "active",
      "billing": "agent"
    }
  ]
}
  ]
}
```

**Key point:** The agent receives a single consolidated invoice. Per-brand accounts give reporting granularity but billing is centralized. Buys without a specific `account_id` route to the default account.

### Hybrid

Both paths are available. Direct accounts (brand or operator billing) give buyers their own rate cards and invoicing with the seller. The default account serves as the fallback — buys without a direct account route through it automatically. Typical for sellers serving both direct buyers and programmatic buyers.

**Capabilities:**

```json
{
  "account": {
    "supported_billing": ["brand", "operator", "agent"],
    "default_billing": "agent"
  }
}
```

**Buyer workflow:**

1. Call `get_adcp_capabilities` — see all three billing models, `default_billing: "agent"`
2. Call `sync_accounts` with preferred billing per brand:
   - Brands with a direct seller relationship: `billing: "brand"`
   - Everything else: `billing: "agent"` (or omit to accept the default)
3. Direct accounts may go through `pending_approval`; agent-billed accounts are active immediately
4. Call `get_products` / `create_media_buy` with `account_id`

**sync_accounts example — billing negotiation:**

The seller supports brand billing in general, but may not support it for every brand. Here, the agent requests brand billing for a brand without a direct relationship:

```json
{
  "accounts": [{
    "house": "acme-corp.com",
    "billing": "brand"
  }]
}
```

Seller maps to agent billing because this brand has no direct account:

```json
{
  "accounts": [{
    "account_id": "acc_acme_001",
    "house": "acme-corp.com",
    "action": "created",
    "status": "active",
    "billing": "agent",
    "warnings": ["Direct billing (brand) not supported. Mapped to agent billing."]
  }]
}
```

The agent should check the returned `billing` and inform the buyer if it differs from what was requested.

**Key point:** The agent always has a fallback. Direct accounts are preferred when available but not required.

## Authorized operators

Brands declare who can represent them in `/.well-known/brand.json` via the `authorized_operators` field. Sellers SHOULD verify operators against this when processing `sync_accounts`.

```json
{
  "house": {
    "domain": "nova-brands.com",
    "name": "Nova Brands"
  },
  "brands": [
    { "id": "spark", "names": [{"en": "Spark"}] },
    { "id": "glow", "names": [{"en": "Glow"}] }
  ],
  "authorized_operators": [
    {
      "domain": "pinnacle-media.com",
      "brands": ["spark", "glow"],
      "countries": ["US", "GB", "DE"]
    },
    {
      "domain": "summit-agency.jp",
      "brands": ["spark"],
      "countries": ["JP"]
    },
    {
      "domain": "nova-brands.com",
      "brands": ["*"]
    }
  ]
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `domain` | Yes | Operator's domain |
| `brands` | Yes | Brand IDs this operator can represent. `["*"]` means all brands. |
| `countries` | No | ISO 3166-1 alpha-2 country codes. Omit for global authorization. |

### Verification flow

1. Resolve `{house}/.well-known/brand.json`
2. Check `authorized_operators` for matching `domain` with the brand in `brands`
3. If found → proceed (account may still need credit/legal approval)
4. If not found → reject the account (`action: "failed"`) or return `pending_approval` for manual review

Verification is a trust signal, not a gate. Finding the operator in `brand.json` lets the seller fast-track provisioning. If the operator isn't listed, the seller can still approve through its own review process.

**Self-authorization is implicit.** When `operator` is omitted from a sync_accounts request, or when the operator domain matches the house domain, the brand is operating its own seat — no listing in `authorized_operators` is needed.

`authorized_operators` models the interface between the brand and whoever holds the seat. It does not model internal agency hierarchies.

## sync_accounts reference

The `sync_accounts` task lets an agent declare its advertiser portfolio to a seller. See [sync_accounts task reference](/docs/accounts/tasks/sync_accounts) for the full request/response schema.

**Natural key:** The tuple `(house, brand_id, operator)` uniquely identifies an account relationship. Missing fields are distinct from present fields — `{house: "acme-corp.com"}` (brand buying direct) is a different account from `{house: "acme-corp.com", operator: "pinnacle-media.com"}` (brand via agency).

### Account status

| Status | Meaning | Next step |
|--------|---------|-----------|
| `active` | Ready to use | Place buys on this account |
| `pending_approval` | Seller reviewing | Human may need to visit `setup.url`. Poll `list_accounts` for updates. |
| `rejected` | Seller declined the request | Review rejection reason, adjust and re-sync, or contact seller |
| `payment_required` | Credit limit reached | Add funds or route spend to other accounts |
| `suspended` | Was active, now paused | Contact seller |
| `closed` | Was active, now terminated | — |

### delete_missing scope

When `delete_missing: true`, the seller deactivates accounts that were previously synced by **this agent** but are not included in the current request. It does not affect accounts managed by other agents. Use `dry_run: true` to preview deactivations.

## Error codes

| Code | When returned | Resolution |
|------|-------------|------------|
| `ACCOUNT_REQUIRED` | Multiple accounts; seller can't determine which | Pass `account_id` on the request |
| `ACCOUNT_NOT_FOUND` | `account_id` doesn't exist or agent lacks access | Check `account_id`, re-sync |
| `PAYMENT_REQUIRED` | Credit limit reached or funds depleted | Add funds, route to another account |
| `ACCOUNT_SUSPENDED` | Account not in good standing | Contact seller |
| `BRAND_REQUIRED` | Billable operation without brand reference | Include `brand` in request |

When the seller returns `ACCOUNT_REQUIRED`, it includes the available accounts:

```json
{
  "errors": [{
    "code": "ACCOUNT_REQUIRED",
    "message": "Multiple accounts available. Please specify account_id.",
    "details": {
      "available_accounts": [
        { "account_id": "acc_acme_001", "name": "Acme Corp" },
        { "account_id": "acc_pinnacle", "name": "Pinnacle Media" }
      ]
    }
  }]
}
```

## Design notes

### Accounts and insertion orders

An account represents a standing relationship — who gets billed, what rates apply, what credit is available. It is not a campaign or an insertion order.

Insertion orders and campaign flights are modeled as media buys via `create_media_buy`. The account determines *billing terms*; the media buy determines *what runs and when*. A single account can have many media buys over its lifetime.

### Operator revocation and caching

If a brand removes an operator from `authorized_operators`, existing active accounts are not automatically deactivated. Revocation is eventual, not immediate — similar to how `ads.txt` changes propagate on the supply side.

Sellers SHOULD respect standard HTTP caching headers on `brand.json` and re-validate periodically. A reasonable cache TTL is 24 hours.

### Brand identity for SMBs

Domain-based identity via `/.well-known/brand.json` works for organizations of any size — it's a static JSON file that can be hosted on any web server.

For organizations that cannot host files on their domain, the `authoritative_location` field in `brand.json` allows the house domain to redirect to a hosted location:

```json
{
  "house": {
    "domain": "local-bakery.com"
  },
  "authoritative_location": "https://registry.agenticadvertising.org/brands/local-bakery.com"
}
```
