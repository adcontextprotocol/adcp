# Extension Fields and Context

## Overview

AdCP provides two mechanisms for adding custom data to requests and responses:

- **`ext`** - Platform-specific extensions that MAY affect behavior (vendor-namespaced)
- **`context`** - Opaque correlation data that is echoed unchanged

### Key Differences

| Aspect | `ext` | `context` |
|--------|-------|-----------|
| **Purpose** | Platform-specific parameters | Opaque correlation data |
| **Affects behavior** | MAY | NEVER |
| **Namespaced** | Yes (vendor keys required) | No |
| **Parsed by agents** | MAY be | NEVER |
| **Example** | `ext.gam.test_mode` | `context.ui_session_id` |

## Extension Fields (`ext`)

Extension fields enable platform-specific functionality, private publisher-buyer agreements, experimental features, and forward compatibility. Extensions follow industry conventions established by IAB standards like OpenRTB.

### Schema Pattern

Extensions appear in the same pattern everywhere they're used (requests, responses, and domain objects):

```json
{
  "product_id": "ctv_premium",
  "name": "Connected TV Premium Inventory",
  "ext": {
    "gam": {
      "order_id": "1234567890",
      "dashboard_url": "https://..."
    },
    "roku": {
      "content_genres": ["comedy", "drama"]
    }
  }
}
```

The `ext` object:
- Is always **optional** (never required)
- Accepts any valid JSON structure
- Must be preserved by implementations (even unknown fields)
- Is not validated by AdCP schemas (implementation-specific validation allowed)

### Use Cases by Layer

**Request extensions** - Platform-specific parameters, vendor configuration, custom capabilities:
```json
{
  "promoted_offering": "Tesla Model 3",
  "packages": [...],
  "ext": {
    "gam": {
      "test_mode": true,
      "ad_unit_path": "/12345/premium"
    }
  }
}
```

**Response extensions** - Platform identifiers, debug information, processing hints:
```json
{
  "media_buy_id": "mb_123",
  "ext": {
    "gam": {
      "order_id": "1234567890",
      "dashboard_url": "https://admanager.google.com/..."
    }
  }
}
```

**Object extensions** - Persistent platform-specific data on domain objects (Products, MediaBuys, Packages, CreativeManifests):
```json
{
  "product_id": "premium_video",
  "ext": {
    "roku": {
      "app_ids": ["123456", "789012"],
      "device_types": ["tv", "streaming_stick"]
    }
  }
}
```

## Context Field (`context`)

Context provides opaque correlation data that is echoed unchanged in responses and webhooks. Agents NEVER parse or use context to affect behavior - it exists solely for the initiator's internal tracking needs.

### Schema Pattern

```json
{
  "$schema": "https://adcontextprotocol.org/schemas/v2/core/context.json",
  "ui_session_id": "sess_abc123",
  "trace_id": "trace_xyz789",
  "internal_campaign_id": "camp_456",
  "buyer_org_id": "org_123"
}
```

The `context` object:
- Is always **optional** (never required)
- Accepts any valid JSON structure
- Is **echoed unchanged** in responses and webhook payloads
- NEVER affects agent behavior or processing
- Is **not interpreted** by agents (completely opaque)

### Common Context Patterns

Context is typically used for:

1. **UI/Session tracking** - Maintaining state across async operations
2. **Request correlation** - Tracing requests through distributed systems
3. **Internal identifiers** - Mapping to initiator's internal data structures
4. **Organization context** - Multi-tenant tracking

### Context in Responses

Responses echo context from the request, enabling correlation between async operations:

```json
// Request
{
  "buyer_ref": "buyer_123",
  "context": { "ui_session_id": "sess_abc" }
}

// Response
{
  "media_buy_id": "mb_456",
  "context": { "ui_session_id": "sess_abc" }  // Echoed unchanged
}
```

Context is echoed unchanged in responses and webhook payloads.

## Namespacing Conventions

### CRITICAL: All Extensions Must Be Namespaced

Extensions MUST use vendor/platform namespacing to avoid naming collisions:

✅ **Correct - Namespaced:**
```json
{
  "$schema": "https://adcontextprotocol.org/schemas/v2/core/ext.json",
  "gam": { "test_mode": true },
  "roku": { "app_ids": ["123"] }
}
```

❌ **Incorrect - Not namespaced:**
```json
{
  "ext": {
    "test_mode": true,  // Missing namespace!
    "app_ids": ["123"]  // Which platform?
  }
}
```

### Namespace Guidelines

- **Use reverse-domain format for custom namespaces**: `com.example.feature`
- **Use common platform short names**: `gam`, `roku`, `ttd`, `magnite`, `nielsen`, `comscore`
- **Consistent naming**: Same namespace across all usage (don't mix `gam` and `google_ad_manager`)
- **Documented namespaces**: Maintain internal registry of your organization's namespaces

### Why Namespacing Matters

Without namespacing:
- Name collisions between platforms are inevitable
- Extensions become ambiguous (whose `test_mode`?)
- Impossible to support multiple platforms simultaneously
- Harder to deprecate platform-specific features

## Typed Extensions

AdCP supports formal JSON schemas for extensions, enabling type safety and validation. Typed extensions are published in the `/schemas/extensions/` directory and can be declared in agent cards.

### How Typed Extensions Work

Typed extensions provide a middle ground between untyped vendor extensions and core AdCP fields:

- **Untyped extensions** (`ext.vendor.*`) - Any JSON, no validation, vendor-specific
- **Typed extensions** (`ext.sustainability.*`) - Formal schema, validated, cross-vendor
- **Core fields** - Part of AdCP specification, required for interoperability

Typed extensions enable SDK code generation, schema validation, and cross-vendor interoperability while remaining optional.

### Extension Schema Registry

The registry of available typed extensions is auto-generated from extension files:
- **Registry**: `/schemas/v1/extensions/index.json`
- **Extension schemas**: `/schemas/v1/extensions/{namespace}.json`
- **Meta schema**: `/schemas/v1/extensions/extension-meta.json`

Each versioned schema path (`/schemas/v2.5/`, `/schemas/v2.6/`) includes only extensions valid for that version, based on the `valid_from` and `valid_until` fields in each extension.

### Extension Versioning

Extensions are versioned independently of the AdCP specification:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "/schemas/extensions/sustainability.json",
  "title": "Sustainability Extension",
  "description": "Carbon footprint and green certification data",
  "valid_from": "2.5",
  "valid_until": "4.0",
  "docs_url": "https://adcontextprotocol.org/docs/extensions/sustainability",
  "type": "object",
  "properties": {
    "carbon_kg_per_impression": { "type": "number" },
    "certified_green": { "type": "boolean" }
  }
}
```

- **`valid_from`** (required): Minimum AdCP version this extension works with (e.g., `"2.5"`)
- **`valid_until`** (optional): Last AdCP version this extension works with. Omit if still valid.

This allows extensions to be backported to earlier AdCP versions and deprecated gracefully.

### Declaring Extension Support

Agents declare which typed extensions they support in their discovery metadata. The location depends on the protocol:

#### A2A Agent Cards

A2A agents declare AdCP support in the `extensions` array at `/.well-known/agent.json`:

```json
{
  "name": "AdCP Media Buy Agent",
  "skills": [{ "name": "get_products" }, { "name": "create_media_buy" }],
  "extensions": [
    {
      "uri": "https://adcontextprotocol.org/extensions/adcp",
      "description": "AdCP media buying protocol support",
      "required": false,
      "params": {
        "adcp_version": "2.6.0",
        "protocols_supported": ["media_buy"],
        "extensions_supported": ["sustainability"]
      }
    }
  ]
}
```

See the [A2A Guide](/docs/protocols/a2a-guide#adcp-extension) for complete details.

#### MCP Server Cards

MCP servers declare AdCP support via the `_meta` field at `/.well-known/mcp.json` or `/.well-known/server.json`:

```json
{
  "name": "io.adcontextprotocol/media-buy-agent",
  "tools": [{ "name": "get_products" }, { "name": "create_media_buy" }],
  "_meta": {
    "adcontextprotocol.org": {
      "adcp_version": "2.6.0",
      "protocols_supported": ["media_buy"],
      "extensions_supported": ["sustainability"]
    }
  }
}
```

See the [MCP Guide](/docs/protocols/mcp-guide#adcp-extension-via-mcp-server-card) for complete details.

#### Extension Params Schema

Both protocols use the same params structure, defined in the [AdCP extension schema](https://adcontextprotocol.org/schemas/v2/protocols/adcp-extension.json):
- **`adcp_version`** (required): Semantic version of AdCP implemented (e.g., "2.6.0")
- **`protocols_supported`** (required): Array of protocol domains (media_buy, creative, signals)
- **`extensions_supported`** (optional): Array of typed extension namespaces

When an agent declares support for an extension, clients can expect:
- The agent will accept and populate `ext.{namespace}` fields conforming to that extension's schema
- Data in `ext.{namespace}` is strongly typed and can be validated
- SDK code generation can produce type-safe interfaces for the extension

### Using Typed Extensions

When an agent supports a typed extension, you can include and expect data in the corresponding namespace:

```json
{
  "product_id": "premium_ctv",
  "name": "Premium CTV Package",
  "ext": {
    "sustainability": {
      "carbon_kg_per_impression": 0.0012,
      "certified_green": true
    }
  }
}
```

### Creating a Typed Extension

To create a typed extension:

1. **Create the extension file** at `/schemas/extensions/{namespace}.json`
2. **Follow the meta schema** defined in `/schemas/extensions/extension-meta.json`
3. **Set `valid_from`** to the minimum AdCP version your extension requires
4. **Add documentation** via the `docs_url` field

Example extension file:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "/schemas/extensions/sustainability.json",
  "title": "Sustainability Extension",
  "description": "Carbon footprint and green certification data for ad products",
  "valid_from": "2.5",
  "docs_url": "https://adcontextprotocol.org/docs/extensions/sustainability",
  "type": "object",
  "properties": {
    "carbon_kg_per_impression": {
      "type": "number",
      "description": "Estimated CO2 emissions per impression in kilograms"
    },
    "certified_green": {
      "type": "boolean",
      "description": "Whether the inventory is certified by a green advertising program"
    },
    "certification_provider": {
      "type": "string",
      "description": "Name of the green certification provider"
    }
  }
}
```

The build process auto-discovers extension files and includes them in the appropriate versioned schema builds.

### Proposing Typed Extensions

To propose a typed extension for inclusion in AdCP:

1. **Validate in production first** - Use vendor-namespaced extensions (`ext.yourcompany.*`) to prove value
2. **Document the schema** - Define clear property names, types, and descriptions
3. **Gather adoption evidence** - Show multiple implementations or strong demand
4. **Submit an RFC** - Propose the extension with schema and use cases
5. **If accepted** - Extension is added to `/schemas/extensions/` with appropriate `valid_from`

### Reserved Namespaces

The following namespaces are reserved and cannot be used for typed extensions:
- `adcp`, `core`, `protocol`, `schema`, `meta`, `ext`, `context`

These are reserved to prevent confusion with core AdCP concepts.

### Extension Deprecation Policy

#### When Extensions May Be Deprecated

1. **Superseded** - A better extension exists with a documented migration path
2. **Promoted to core** - The extension becomes a core AdCP field
3. **Low adoption** - Insufficient usage across implementations
4. **Incompatible** - Breaking changes in AdCP require removal

#### Deprecation Process

1. Set `valid_until` to current version + 1 minor release (minimum grace period)
2. Announce deprecation in CHANGELOG
3. Publish migration guide if replacement exists
4. Add deprecation warning to extension docs
5. Extension removed from builds after `valid_until` version

#### Emergency Deprecation

Security issues may require immediate deprecation:
- `valid_until` set to current version
- Security advisory published
- Patch release issued

## Proposing Spec Additions

If your extension field represents **common ad tech functionality** that would benefit all AdCP implementations:

1. **Use extensions first** - Validate the feature in production
2. **Gather evidence** - Document actual usage patterns and adoption
3. **Propose standardization** - Submit RFC to standardize as core field
4. **Dual support period** - Support both ext and core field during transition
5. **Eventual deprecation** - Once standardized, deprecate the extension version

Example progression:
```json
// Phase 1: Extension (testing)
{ "ext": { "acme": { "dynamic_pricing": true } } }

// Phase 2: Standardized (if broadly useful)
{ "dynamic_pricing_enabled": true }
```

## Validation Rules

### Extension Field Requirements

AdCP implementations MUST:
- Accept `ext` fields on all schemas that define them
- Preserve `ext` values even if not understood
- Not reject requests solely due to unknown `ext` contents
- Pass through `ext` values in responses when echoing objects

AdCP implementations MAY:
- Parse and validate known `ext` fields
- Use `ext` values to modify behavior (document this clearly)
- Add their own `ext` fields to responses
- Reject requests if KNOWN `ext` values are invalid

AdCP implementations MUST NOT:
- Require `ext` fields (always optional)
- Reject unknown/unexpected `ext` fields
- Modify `ext` values from requests (except to add platform-specific response data)

### Context Field Requirements

AdCP implementations MUST:
- Echo `context` unchanged in responses (exact JSON preservation)
- Echo `context` unchanged in webhook payloads
- Never parse or interpret `context` contents
- Never use `context` to affect behavior

AdCP implementations MUST NOT:
- Require `context` fields (always optional)
- Modify `context` values in any way
- Use `context` for operational decisions

## Extension Examples

### Comprehensive Multi-Platform Example

```json
{
  "$schema": "https://adcontextprotocol.org/schemas/v2/core/ext.json",
  "gam": {
    "order_id": "1234567890",
    "dashboard_url": "https://admanager.google.com/12345/orders",
    "test_mode": true
  },
  "roku": {
    "content_genres": ["comedy", "drama"],
    "device_types": ["tv", "streaming_stick"],
    "app_ids": ["123456", "789012"]
  },
  "ttd": {
    "uid2_enabled": true,
    "tracking_tag": "ttd_pixel_123"
  },
  "nielsen": {
    "dar_enabled": true,
    "campaign_id": "nielsen_camp_123"
  },
  "comscore": {
    "census_enabled": false,
    "client_id": "cs_client_789"
  },
  "com.mycompany.analytics": {
    "custom_dimension_1": "value",
    "experiment_id": "exp_456"
  }
}
```

All extensions follow this pattern: namespace your fields under your vendor key.

## Best Practices

### When to Use Extensions vs Context

**Use `ext` when:**
- Platform needs to parse the data
- Data MAY affect operational behavior
- Data represents platform-specific configuration
- Data should persist across operations (on objects)

**Use `context` when:**
- Data is only for caller's internal use
- Data should never affect agent behavior
- Data is for correlation/tracking only
- Data needs to be echoed unchanged

### Extension Design Guidelines

1. **Always namespace** - Every extension must be under a vendor key
2. **Document extensively** - Extensions are implementation-specific, not self-documenting
3. **Version carefully** - Breaking changes in extensions affect integrations
4. **Use JSON Schema** - Define schemas for your extensions
5. **Monitor usage** - Track which extensions are actually used
6. **Consider standardization** - Popular extensions should become core fields

### Context Design Guidelines

1. **Keep it opaque** - Don't structure context for agents to parse
2. **Avoid large payloads** - Context is echoed in every response
3. **Don't rely on preservation** - While agents MUST echo context, plan for edge cases
4. **Use for correlation only** - Never use context for operational data

## Common Pitfalls

### Anti-Pattern: Unnamespaced Extensions

❌ **Bad:**
```json
{ "ext": { "test_mode": true } }
```

✅ **Good:**
```json
{ "ext": { "gam": { "test_mode": true } } }
```

### Anti-Pattern: Using Context for Operations

❌ **Bad:**
```json
{
  "context": { "enable_feature_x": true }  // Agent should never parse this!
}
```

✅ **Good:**
```json
{
  "ext": { "acme": { "enable_feature_x": true } },
  "context": { "ui_session_id": "sess_123" }
}
```

### Anti-Pattern: Mixing Standard and Extension Fields

❌ **Bad:**
```json
{
  "promoted_offering": "Product Name",
  "ext": { "acme": { "promoted_offering_id": "123" } }  // Redundant with core field
}
```

✅ **Good:**
```json
{
  "promoted_offering": "Product Name",
  "ext": { "acme": { "internal_product_code": "SKU-123" } }  // Different purpose
}
```
