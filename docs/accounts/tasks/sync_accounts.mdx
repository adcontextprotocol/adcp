---
title: sync_accounts
testable: false
---

Sync advertiser accounts with a seller for one or more brand/operator pairs. The seller provisions or links accounts, returning their status and any setup instructions. Brands are identified by house domain + optional brand_id, resolved via `/.well-known/brand.json`.

`sync_accounts` is used across all seller protocols: media buy agents, signals agents, governance agents, and creative agents. The `account_id` returned is what you pass to protocol tasks like `create_media_buy`, `get_signals`, `activate_signal`, and `report_usage`.

**Response Time**: ~1s. Account provisioning is synchronous; credit and legal review may require human action (indicated by `status: "pending_approval"` with a `setup.url`).

**Request Schema**: [`/schemas/v1/account/sync-accounts-request.json`](https://adcontextprotocol.org/schemas/v1/account/sync-accounts-request.json)
**Response Schema**: [`/schemas/v1/account/sync-accounts-response.json`](https://adcontextprotocol.org/schemas/v1/account/sync-accounts-response.json)

## Quick start

Sync a single advertiser account and check the resulting status:

<CodeGroup>

```javascript JavaScript
import { testAgent } from "@adcp/client/testing";
import { SyncAccountsResponseSchema } from "@adcp/client";

const result = await testAgent.syncAccounts({
  house: "acme-corp.com",
  billing: "brand",
});

if (!result.success) {
  throw new Error(`Request failed: ${result.error}`);
}

const validated = SyncAccountsResponseSchema.parse(result.data);

if ("errors" in validated && validated.errors) {
  throw new Error(`Operation failed: ${JSON.stringify(validated.errors)}`);
}

console.log(`${validated.house}: ${validated.status}`);
if (validated.status === "pending_approval" && validated.setup?.url) {
  console.log(`  Complete setup at: ${validated.setup.url}`);
}
```

```python Python
import asyncio
from adcp.testing import test_agent

async def main():
    result = await test_agent.simple.sync_accounts(
        house='acme-corp.com',
        billing='brand',
    )

    if hasattr(result, 'errors') and result.errors:
        raise Exception(f"Operation failed: {result.errors}")

    print(f"{result.house}: {result.status}")
    if result.status == 'pending_approval' and hasattr(result, 'setup') and result.setup:
        print(f"  Complete setup at: {result.setup.url}")

asyncio.run(main())
```

</CodeGroup>

## Request parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `house` | string | Yes | House domain where [`brand.json`](/docs/brand-protocol/brand-json) is hosted (e.g. `acme-corp.com`, `nova-brands.com`). This is the brand registry identifier -- seller agents look up the brand's verified identity from this domain. For single-brand houses, this alone identifies the brand. |
| `brand_id` | string | No | Brand ID within the house portfolio (e.g. `spark`, `glow`). Required when the house has multiple brands. |
| `operator` | string | No | Domain of the entity operating the seat (e.g. `pinnacle-media.com`). Verified against the brand's `authorized_operators` in brand.json. Omit if the brand operates its own seat. |
| `billing` | string | No | Who should be invoiced: `brand`, `operator`, or `agent`. Omit to accept the seller's default. The seller may return a different billing model -- always check the response. |
| `sandbox` | boolean | No | When true, set up a sandbox account. No real platform calls or billing. |
| `push_notification_config` | object | No | Webhook for async notifications when account status changes (e.g., `pending_approval` transitions to `active`). |

**Natural key**: The tuple `(house, brand_id, operator)` uniquely identifies an account relationship. `{house: "acme-corp.com"}` (direct) is a different account from `{house: "acme-corp.com", operator: "pinnacle-media.com"}` (via agency).

## Response

**Success response:**

Returns the account status and details directly (not wrapped in an array).

**Error response:**

- `errors` -- Array of operation-level errors (auth failure, invalid request).

**Note:** Responses use discriminated unions -- you get either success fields OR errors, never both.

**Success fields:**

| Field | Description |
|-------|-------------|
| `account_id` | Seller-assigned account identifier. Pass this to protocol tasks (`create_media_buy`, `get_signals`, `activate_signal`, `report_usage`, etc.). May be absent when `status: "rejected"`. Present for all other statuses including `pending_approval`. |
| `house` | Echoed from request |
| `brand_id` | Echoed from request (when provided) |
| `operator` | Echoed from request (when provided) |
| `name` | Seller's display name for the account |
| `status` | Current state of the account (see [Account status](#account-status)) |
| `billing` | Actual billing model applied. May differ from requested -- always check this field. |
| `account_scope` | How the seller scoped this account: `operator` (shared across brands for this operator), `brand` (shared across operators for this brand), `operator_brand` (dedicated to this operator+brand pair), or `agent` (the agent's default account). See [account scope](/docs/building/integration/accounts-and-agents#account-scope). |
| `setup` | Present when `status: "pending_approval"`. Contains `url` for completing credit or legal setup, `message` explaining what's needed, and optional `expires_at`. |
| `rate_card` | Seller-assigned rate card identifier (when applicable) |
| `payment_terms` | Payment terms (e.g. `net_30`, `prepay`) |
| `credit_limit` | Maximum outstanding balance as `{amount, currency}` |
| `warnings` | Non-fatal notices (e.g. billing model was remapped) |
| `sandbox` | Whether this is a sandbox account, echoed from request |

### Account status

| Status | Meaning | Next step |
|--------|---------|-----------|
| `active` | Ready to use | Use `account_id` in protocol operations |
| `pending_approval` | Seller reviewing | Human may need to visit `setup.url` to complete credit or legal process. Poll `list_accounts` for updates. |
| `rejected` | Seller declined the request | Review rejection reason in `warnings`, adjust and retry, or contact seller |
| `payment_required` | Credit limit reached or funds depleted | Add funds or increase credit limit. Route spend to other accounts. |
| `suspended` | Was active, now paused | Contact seller to resolve |
| `closed` | Was active, now terminated | -- |

## Common scenarios

### Agency syncing for a brand

<CodeGroup>

```javascript JavaScript
import { testAgent } from "@adcp/client/testing";
import { SyncAccountsResponseSchema } from "@adcp/client";

const result = await testAgent.syncAccounts({
  house: "nova-brands.com",
  brand_id: "spark",
  operator: "pinnacle-media.com",
  billing: "brand",
});

if (!result.success) {
  throw new Error(`Request failed: ${result.error}`);
}

const validated = SyncAccountsResponseSchema.parse(result.data);

if ("errors" in validated && validated.errors) {
  throw new Error(`Operation failed: ${JSON.stringify(validated.errors)}`);
}

if (validated.status === "active") {
  console.log(`Ready: account_id = ${validated.account_id}`);
} else if (validated.status === "pending_approval") {
  console.log(`Setup required: ${validated.setup?.url}`);
  // Poll list_accounts until status becomes active
}
```

```python Python
import asyncio
from adcp.testing import test_agent

async def main():
    result = await test_agent.simple.sync_accounts(
        house='nova-brands.com',
        brand_id='spark',
        operator='pinnacle-media.com',
        billing='brand',
    )

    if hasattr(result, 'errors') and result.errors:
        raise Exception(f"Operation failed: {result.errors}")

    if result.status == 'active':
        print(f"Ready: account_id = {result.account_id}")
    elif result.status == 'pending_approval':
        print(f"Setup required: {result.setup.url}")
        # Poll list_accounts until status becomes active

asyncio.run(main())
```

</CodeGroup>

### Direct brand purchase

<CodeGroup>

```javascript JavaScript
import { testAgent } from "@adcp/client/testing";
import { SyncAccountsResponseSchema } from "@adcp/client";

const result = await testAgent.syncAccounts({
  house: "acme-corp.com",
  billing: "brand",
});

if (!result.success) {
  throw new Error(`Request failed: ${result.error}`);
}

const validated = SyncAccountsResponseSchema.parse(result.data);

if ("errors" in validated && validated.errors) {
  throw new Error(`Operation failed: ${JSON.stringify(validated.errors)}`);
}

if (validated.status === "active") {
  console.log(`Ready: account_id = ${validated.account_id}`);
} else if (validated.status === "pending_approval") {
  console.log(`Setup required: ${validated.setup?.url}`);
  // Poll list_accounts until status becomes active
}
```

```python Python
import asyncio
from adcp.testing import test_agent

async def main():
    result = await test_agent.simple.sync_accounts(
        house='acme-corp.com',
        billing='brand',
    )

    if hasattr(result, 'errors') and result.errors:
        raise Exception(f"Operation failed: {result.errors}")

    if result.status == 'active':
        print(f"Ready: account_id = {result.account_id}")
    elif result.status == 'pending_approval':
        print(f"Setup required: {result.setup.url}")
        # Poll list_accounts until status becomes active

asyncio.run(main())
```

</CodeGroup>

### Handling billing negotiation

The seller may return a different billing model than requested. Always check the returned `billing` value:

<CodeGroup>

```javascript JavaScript
import { testAgent } from "@adcp/client/testing";
import { SyncAccountsResponseSchema } from "@adcp/client";

const result = await testAgent.syncAccounts({
  house: "acme-corp.com",
  billing: "brand", // requested
});

if (!result.success) {
  throw new Error(`Request failed: ${result.error}`);
}

const validated = SyncAccountsResponseSchema.parse(result.data);

if ("errors" in validated && validated.errors) {
  throw new Error(`Operation failed: ${JSON.stringify(validated.errors)}`);
}

if (validated.warnings?.length) {
  console.warn(`Billing remapped: ${validated.warnings.join(", ")}`);
  console.log(`Applied billing: ${validated.billing}`); // may differ from request
}
```

```python Python
import asyncio
from adcp.testing import test_agent

async def main():
    result = await test_agent.simple.sync_accounts(
        house='acme-corp.com',
        billing='brand',
    )

    if hasattr(result, 'errors') and result.errors:
        raise Exception(f"Operation failed: {result.errors}")

    warnings = getattr(result, 'warnings', None)
    if warnings:
        print(f"Billing remapped: {', '.join(warnings)}")
        print(f"Applied billing: {result.billing}")

asyncio.run(main())
```

</CodeGroup>

### Handling rejection

When a seller declines the request, `status` is `rejected` and `account_id` is absent:

<CodeGroup>

```javascript JavaScript
import { testAgent } from "@adcp/client/testing";
import { SyncAccountsResponseSchema } from "@adcp/client";

const result = await testAgent.syncAccounts({
  house: "acme-corp.com",
  brand_id: "clearance",
});

if (!result.success) {
  throw new Error(`Request failed: ${result.error}`);
}

const validated = SyncAccountsResponseSchema.parse(result.data);

if ("errors" in validated && validated.errors) {
  throw new Error(`Operation failed: ${JSON.stringify(validated.errors)}`);
}

if (validated.status === "rejected") {
  console.log("Account request was rejected");
  if (validated.warnings?.length) {
    console.log(`Reason: ${validated.warnings.join(", ")}`);
  }
}
```

```python Python
import asyncio
from adcp.testing import test_agent

async def main():
    result = await test_agent.simple.sync_accounts(
        house='acme-corp.com',
        brand_id='clearance',
    )

    if hasattr(result, 'errors') and result.errors:
        raise Exception(f"Operation failed: {result.errors}")

    if result.status == 'rejected':
        print("Account request was rejected")
        warnings = getattr(result, 'warnings', None)
        if warnings:
            print(f"Reason: {', '.join(warnings)}")

asyncio.run(main())
```

</CodeGroup>

## Error handling

| Error Code | Description | Resolution |
|------------|-------------|------------|
| `ACCOUNT_NOT_FOUND` | Referenced account does not exist or is not accessible | Check `account_id` or re-sync |
| `PAYMENT_REQUIRED` | Account has reached its credit limit | Add funds or route to another account |
| `ACCOUNT_SUSPENDED` | Account is suspended | Contact seller to resolve |
| `BRAND_REQUIRED` | Billable operation attempted without brand reference | Include `house` in the request |

## Next steps

- [list_accounts](/docs/accounts/tasks/list_accounts) -- Poll for status changes on pending accounts
- [Accounts and agents](/docs/building/integration/accounts-and-agents) -- Billing models, trust models, and authorized operators
- [Brand protocol](/docs/brand-protocol/brand-json) -- How seller agents resolve brand identity from the `house` domain
- [get_adcp_capabilities](/docs/protocol/get_adcp_capabilities) -- Discover `supported_billing` and `account_resolution` before syncing accounts
