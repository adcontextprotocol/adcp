From 60e3064b69088d022bbe70763c4fe74d6ada6231 Mon Sep 17 00:00:00 2001
From: Brian O'Kelley <bokelley@scope3.com>
Date: Sun, 3 Aug 2025 07:37:46 +0100
Subject: [PATCH 1/7] feat: add A2A integration proposal and proof of concept
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Add comprehensive architectural proposal for integrating Google's Agent2Agent (A2A) protocol with AdCP
- Create proof-of-concept dual-protocol agent supporting both MCP and A2A
- Add flow diagrams showing cross-platform coordination and protocol bridging
- Document use cases, benefits, and implementation approach

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
---
 docs/architecture/a2a-integration-flow.md     | 175 +++++++++
 docs/architecture/a2a-integration-proposal.md | 324 ++++++++++++++++
 .../a2a-integration/dual-protocol-agent.js    | 354 ++++++++++++++++++
 3 files changed, 853 insertions(+)
 create mode 100644 docs/architecture/a2a-integration-flow.md
 create mode 100644 docs/architecture/a2a-integration-proposal.md
 create mode 100644 examples/a2a-integration/dual-protocol-agent.js

diff --git a/docs/architecture/a2a-integration-flow.md b/docs/architecture/a2a-integration-flow.md
new file mode 100644
index 0000000..2388120
--- /dev/null
+++ b/docs/architecture/a2a-integration-flow.md
@@ -0,0 +1,175 @@
+# A2A Integration Flow Examples
+
+## Example 1: Cross-Platform Campaign Coordination
+
+This example shows how an A2A orchestrator could coordinate a campaign across multiple AdCP-enabled platforms.
+
+```mermaid
+sequenceDiagram
+    participant User
+    participant A2A_Orchestrator as A2A Orchestrator
+    participant AdCP_GAM as AdCP Agent<br/>(Google Ad Manager)
+    participant AdCP_TTD as AdCP Agent<br/>(The Trade Desk)
+    participant AdCP_Signals as AdCP Signals<br/>(Scope3)
+
+    User->>A2A_Orchestrator: "Create $100K campaign for sports fans"
+    
+    Note over A2A_Orchestrator: Parse intent and plan workflow
+    
+    par Parallel Discovery
+        A2A_Orchestrator->>AdCP_Signals: A2A: "Find sports audience signals"
+        AdCP_Signals-->>A2A_Orchestrator: Sports signals found
+    and
+        A2A_Orchestrator->>AdCP_GAM: A2A: "Get CTV inventory for sports"
+        AdCP_GAM-->>A2A_Orchestrator: 5 products available
+    and
+        A2A_Orchestrator->>AdCP_TTD: A2A: "Get display inventory for sports"
+        AdCP_TTD-->>A2A_Orchestrator: 3 products available
+    end
+    
+    Note over A2A_Orchestrator: Optimize budget allocation
+    
+    par Execute Campaigns
+        A2A_Orchestrator->>AdCP_GAM: A2A: "Create $60K CTV campaign"
+        AdCP_GAM-->>A2A_Orchestrator: media_buy_id: gam_12345
+    and
+        A2A_Orchestrator->>AdCP_TTD: A2A: "Create $40K display campaign"
+        AdCP_TTD-->>A2A_Orchestrator: media_buy_id: ttd_67890
+    end
+    
+    A2A_Orchestrator->>User: Campaigns created across platforms
+```
+
+## Example 2: MCP to A2A Bridge Scenario
+
+This shows how a traditional MCP orchestrator could leverage A2A agents through a bridge.
+
+```mermaid
+sequenceDiagram
+    participant MCP_Client as MCP Orchestrator
+    participant AdCP_Agent as AdCP Sales Agent<br/>(Dual Protocol)
+    participant A2A_Analytics as A2A Analytics Agent<br/>(External)
+    participant A2A_Creative as A2A Creative Agent<br/>(External)
+
+    MCP_Client->>AdCP_Agent: MCP: create_media_buy(...)
+    
+    Note over AdCP_Agent: Need performance data
+    
+    AdCP_Agent->>A2A_Analytics: A2A: "Analyze performance for similar campaigns"
+    A2A_Analytics-->>AdCP_Agent: Performance insights
+    
+    Note over AdCP_Agent: Need creative adaptations
+    
+    AdCP_Agent->>A2A_Creative: A2A: "Generate variations for CTV campaign"
+    
+    Note over A2A_Creative: Long-running task
+    A2A_Creative-->>AdCP_Agent: task_id: task_123, status: working
+    A2A_Creative-->>AdCP_Agent: SSE: Progress update (50%)
+    A2A_Creative-->>AdCP_Agent: SSE: Task completed
+    
+    AdCP_Agent-->>MCP_Client: Media buy created with optimizations
+```
+
+## Example 3: Human-in-the-Loop Approval Flow
+
+This demonstrates how A2A's async model supports AdCP's HITL operations.
+
+```mermaid
+sequenceDiagram
+    participant A2A_Client as A2A Client
+    participant AdCP_Agent as AdCP Sales Agent
+    participant Human as Human Approver
+    participant Webhook as Approval System
+
+    A2A_Client->>AdCP_Agent: A2A: "Create $1M campaign (requires approval)"
+    
+    AdCP_Agent->>AdCP_Agent: Validate campaign parameters
+    
+    AdCP_Agent-->>A2A_Client: task_id: task_456, status: pending_approval
+    
+    AdCP_Agent->>Webhook: POST: Approval required notification
+    
+    Webhook->>Human: Email/Slack notification
+    
+    Human->>Webhook: Approve campaign
+    
+    Webhook->>AdCP_Agent: POST: Approval granted
+    
+    AdCP_Agent->>AdCP_Agent: Execute campaign creation
+    
+    AdCP_Agent-->>A2A_Client: SSE: Task completed, media_buy_id: mb_789
+```
+
+## Protocol Interaction Patterns
+
+### Pattern 1: Protocol Selection
+
+```javascript
+// Client can choose protocol based on capabilities
+if (agent.supports('a2a') && needsAsyncWorkflow) {
+  // Use A2A for complex, long-running tasks
+  await agent.a2a.send({
+    message: "Analyze and optimize all active campaigns"
+  });
+} else if (agent.supports('mcp')) {
+  // Use MCP for direct tool execution
+  await agent.mcp.call('get_media_buy_delivery', {
+    media_buy_id: 'mb_123'
+  });
+}
+```
+
+### Pattern 2: Protocol Translation
+
+```javascript
+// A2A request translated to MCP tools
+async function handleA2ARequest(message) {
+  const intent = parseIntent(message);
+  
+  switch(intent.action) {
+    case 'create_campaign':
+      // Map to MCP tools
+      const products = await mcp.call('get_products', {
+        brief: intent.brief
+      });
+      
+      return await mcp.call('create_media_buy', {
+        packages: products.map(p => p.product_id),
+        total_budget: intent.budget
+      });
+  }
+}
+```
+
+### Pattern 3: Cross-Protocol Context
+
+```javascript
+// Maintain context across protocols
+class ContextManager {
+  async handleMCPCall(tool, params, context) {
+    // Store context from MCP interaction
+    this.storeContext(context.sessionId, {
+      protocol: 'mcp',
+      tool,
+      params,
+      timestamp: Date.now()
+    });
+  }
+  
+  async handleA2ATask(task, context) {
+    // Retrieve context from previous interactions
+    const history = this.getContext(context.sessionId);
+    
+    // Use history to provide continuity
+    return this.processWithContext(task, history);
+  }
+}
+```
+
+## Benefits of Integration
+
+1. **Flexibility**: Clients can choose the most appropriate protocol
+2. **Interoperability**: AdCP agents can work with the broader A2A ecosystem
+3. **Scalability**: A2A's async model handles complex workflows
+4. **Backward Compatibility**: Existing MCP clients continue to work
+5. **Innovation**: Enables new multi-agent collaborative workflows
\ No newline at end of file
diff --git a/docs/architecture/a2a-integration-proposal.md b/docs/architecture/a2a-integration-proposal.md
new file mode 100644
index 0000000..8dda4a6
--- /dev/null
+++ b/docs/architecture/a2a-integration-proposal.md
@@ -0,0 +1,324 @@
+# AdCP + A2A Integration: Architectural Proposal
+
+## Executive Summary
+
+This document proposes an architecture for integrating Google's Agent2Agent (A2A) protocol with the Advertising Context Protocol (AdCP). The integration would enable AdCP agents to communicate with other A2A-compatible agents, expanding the ecosystem and enabling new collaborative workflows.
+
+## Background
+
+### Current State
+
+**AdCP** (Advertising Context Protocol):
+- Built on Anthropic's Model Context Protocol (MCP)
+- Focused on advertising workflows (media buying, signals, curation)
+- Uses `.well-known/adcp.json` for agent discovery
+- Agents expose MCP endpoints with specific tools
+
+**A2A** (Agent2Agent Protocol):
+- Open protocol by Google with Linux Foundation governance
+- Uses JSON-RPC 2.0 over HTTP
+- Agent Cards at `.well-known/agent.json`
+- Supports async tasks with Server-Sent Events (SSE)
+- Vendor-neutral, modality-agnostic
+
+### Complementary Nature
+
+As noted by Google's Rao Surapaneni: "We see MCP and A2A as complementary capabilities. The way we are looking at Agent2Agent is at a higher layer of abstraction to enable applications and agents to talk to each other."
+
+## Proposed Architecture
+
+### 1. Dual-Protocol Agent Architecture
+
+AdCP agents would support both MCP (for tool interactions) and A2A (for agent-to-agent communication):
+
+```
+┌─────────────────────────────────────────┐
+│           AdCP Agent                     │
+├─────────────────────────────────────────┤
+│  ┌───────────────┐  ┌────────────────┐ │
+│  │  MCP Server   │  │  A2A Server    │ │
+│  │  (Tools)      │  │  (Tasks)       │ │
+│  └───────────────┘  └────────────────┘ │
+│           │                │            │
+│           ▼                ▼            │
+│  ┌────────────────────────────────────┐│
+│  │     Core Business Logic            ││
+│  │  (Media Buy, Signals, Curation)    ││
+│  └────────────────────────────────────┘│
+└─────────────────────────────────────────┘
+```
+
+### 2. Discovery Integration
+
+Extend the AdCP discovery document to include A2A endpoints:
+
+```json
+{
+  "sales": {
+    "mcp": "https://salesagent.example.com/mcp",
+    "a2a": "https://salesagent.example.com/a2a"
+  },
+  "signals": {
+    "mcp": "https://signals.example.com/mcp",
+    "a2a": "https://signals.example.com/a2a"
+  }
+}
+```
+
+Additionally, provide an A2A Agent Card at `.well-known/agent.json`:
+
+```json
+{
+  "name": "AdCP Sales Agent",
+  "description": "AI-powered media buying agent supporting AdCP and A2A protocols",
+  "url": "https://salesagent.example.com/a2a",
+  "authentication": ["bearer", "oauth2"],
+  "supportedInputFormats": ["text/plain", "application/json"],
+  "supportedOutputFormats": ["text/plain", "application/json", "application/pdf"],
+  "skills": [
+    {
+      "name": "media_buy_planning",
+      "description": "Plan and optimize media buying campaigns",
+      "examples": [
+        "Create a $50K CTV campaign targeting sports enthusiasts",
+        "Optimize my current campaigns for better performance"
+      ]
+    },
+    {
+      "name": "inventory_discovery",
+      "description": "Discover available advertising inventory",
+      "examples": [
+        "Find premium video inventory in California",
+        "What audio inventory is available for drive time?"
+      ]
+    }
+  ]
+}
+```
+
+### 3. Protocol Bridging
+
+Create a bridge layer that translates between MCP tool calls and A2A tasks:
+
+```javascript
+// Example: MCP tool call → A2A task
+class AdCPBridge {
+  async handleMCPToolCall(tool, params) {
+    // MCP tool call from orchestrator
+    if (tool === 'create_media_buy') {
+      // Execute locally
+      return this.createMediaBuy(params);
+    }
+  }
+
+  async handleA2ATask(message) {
+    // A2A task from external agent
+    const intent = this.parseIntent(message);
+    
+    if (intent.type === 'media_buy_request') {
+      // Convert to internal format
+      const result = await this.createMediaBuy(intent.params);
+      
+      // Return A2A response
+      return {
+        artifacts: [{
+          name: "media_buy_result",
+          parts: [{
+            kind: "application/json",
+            data: result
+          }]
+        }]
+      };
+    }
+  }
+}
+```
+
+### 4. Use Cases Enabled
+
+#### Cross-Platform Campaign Coordination
+
+An A2A orchestrator could coordinate campaigns across multiple AdCP-enabled platforms:
+
+```
+A2A Orchestrator
+    │
+    ├──A2A──> AdCP Sales Agent (Google Ad Manager)
+    ├──A2A──> AdCP Sales Agent (The Trade Desk)
+    └──A2A──> AdCP Signals Agent (Scope3)
+```
+
+#### Intent-Based Workflows
+
+Natural language intents could be processed by specialized agents:
+
+```
+User: "I need to reach sports fans with a $100K budget"
+    │
+    ▼
+A2A Intent Processor
+    │
+    ├──A2A──> AdCP Signals Agent: "Find sports audience signals"
+    ├──A2A──> AdCP Sales Agent: "Get CTV inventory for sports"
+    └──A2A──> AdCP Curation Agent: "Create sports package"
+```
+
+#### Human-in-the-Loop Approval
+
+A2A's async task model aligns well with AdCP's HITL operations:
+
+```json
+{
+  "method": "message/send",
+  "params": {
+    "message": {
+      "parts": [{
+        "kind": "text",
+        "text": "Create $50K campaign pending human approval"
+      }]
+    },
+    "configuration": {
+      "pushNotificationConfig": {
+        "url": "https://approvals.example.com/webhook"
+      }
+    }
+  }
+}
+```
+
+## Implementation Approach
+
+### Phase 1: A2A Wrapper for Existing Agents
+
+Create an A2A server wrapper that exposes existing MCP tools as A2A tasks:
+
+```javascript
+class A2AWrapper {
+  constructor(mcpAgent) {
+    this.mcpAgent = mcpAgent;
+    this.setupA2AServer();
+  }
+
+  async handleTask(message) {
+    // Parse natural language or structured request
+    const intent = await this.parseIntent(message);
+    
+    // Map to MCP tool
+    const tool = this.mapIntentToTool(intent);
+    
+    // Execute via MCP
+    const result = await this.mcpAgent.execute(tool, intent.params);
+    
+    // Return A2A response
+    return this.formatA2AResponse(result);
+  }
+}
+```
+
+### Phase 2: Native A2A Integration
+
+Build A2A support directly into AdCP agents:
+
+1. **Shared Context Management**: Maintain conversation context across protocols
+2. **Task Orchestration**: Support complex multi-step workflows
+3. **Cross-Agent Collaboration**: Enable agents to delegate subtasks
+
+### Phase 3: Advanced Features
+
+1. **Multi-Modal Support**: Handle PDFs, images, and other artifacts
+2. **Streaming Updates**: Use SSE for real-time campaign monitoring
+3. **Agent Marketplace**: Discovery service for A2A-enabled AdCP agents
+
+## Technical Considerations
+
+### Authentication
+
+A2A supports standard authentication methods that align with AdCP:
+- Bearer tokens (current AdCP approach)
+- OAuth2 (for enterprise integrations)
+
+### Error Handling
+
+Map AdCP error codes to A2A JSON-RPC errors:
+
+```javascript
+// AdCP error
+{
+  "error": {
+    "code": "INVALID_PARAMETER",
+    "message": "Start date must be in the future"
+  }
+}
+
+// A2A JSON-RPC error
+{
+  "jsonrpc": "2.0",
+  "error": {
+    "code": -32602,
+    "message": "Invalid params",
+    "data": {
+      "field": "start_date",
+      "reason": "Start date must be in the future"
+    }
+  }
+}
+```
+
+### Performance
+
+- A2A's async model suits AdCP's long-running operations
+- SSE enables efficient status updates without polling
+- Task IDs allow tracking across system boundaries
+
+## Migration Path
+
+1. **Compatibility Mode**: Existing MCP clients continue working unchanged
+2. **Dual Support**: New agents support both protocols
+3. **Gradual Adoption**: Orchestrators can mix MCP and A2A agents
+4. **Feature Parity**: Ensure all MCP tools have A2A equivalents
+
+## Benefits
+
+### For Publishers
+
+- **Broader Reach**: Connect with A2A ecosystem (100+ partners)
+- **Flexibility**: Support multiple orchestrator types
+- **Innovation**: Enable new collaborative workflows
+
+### For Orchestrators
+
+- **Unified Interface**: Single protocol for diverse agents
+- **Scalability**: A2A's async model handles complex workflows
+- **Ecosystem**: Access to growing A2A agent marketplace
+
+### For the Industry
+
+- **Interoperability**: AdCP agents work with any A2A system
+- **Standards Alignment**: Two major protocols working together
+- **Future-Proof**: Prepared for multi-agent AI future
+
+## Recommendations
+
+1. **Start with Wrappers**: Build A2A wrappers for existing agents to test integration
+2. **Extend Discovery**: Update `.well-known/adcp.json` to include A2A endpoints
+3. **Pilot Programs**: Work with key partners to validate use cases
+4. **Community Feedback**: Engage both AdCP and A2A communities
+5. **Reference Implementation**: Create open-source bridge implementation
+
+## Conclusion
+
+Integrating A2A support into AdCP would:
+- Expand the addressable ecosystem
+- Enable new multi-agent workflows
+- Position AdCP at the forefront of agent interoperability
+- Maintain backward compatibility with existing MCP implementations
+
+The complementary nature of MCP (for tools) and A2A (for agent communication) creates a powerful combination for the future of AI-powered advertising.
+
+## Next Steps
+
+1. Review proposal with AdCP working group
+2. Engage with A2A community for feedback
+3. Build proof-of-concept integration
+4. Define formal specification for dual-protocol agents
+5. Update AdCP documentation with A2A guidelines
\ No newline at end of file
diff --git a/examples/a2a-integration/dual-protocol-agent.js b/examples/a2a-integration/dual-protocol-agent.js
new file mode 100644
index 0000000..3d5db36
--- /dev/null
+++ b/examples/a2a-integration/dual-protocol-agent.js
@@ -0,0 +1,354 @@
+/**
+ * Proof of Concept: AdCP Agent with Dual Protocol Support (MCP + A2A)
+ * 
+ * This example shows how an AdCP Sales Agent could support both:
+ * - MCP for tool-based interactions
+ * - A2A for agent-to-agent communication
+ */
+
+import express from 'express';
+import { MCPServer } from '@modelcontextprotocol/server';
+import { A2AServer } from '@a2a/server'; // Hypothetical A2A SDK
+
+class DualProtocolAdCPAgent {
+  constructor() {
+    this.app = express();
+    this.setupMCPServer();
+    this.setupA2AServer();
+    this.setupDiscovery();
+  }
+
+  /**
+   * MCP Server - Exposes tools for direct integration
+   */
+  setupMCPServer() {
+    this.mcpServer = new MCPServer({
+      name: 'AdCP Sales Agent',
+      version: '1.0.0',
+    });
+
+    // Register AdCP tools
+    this.mcpServer.tool('get_products', {
+      description: 'List available advertising products',
+      parameters: {
+        type: 'object',
+        properties: {
+          brief: { type: 'string' },
+          filters: { type: 'object' }
+        }
+      },
+      handler: async (params) => this.getProducts(params)
+    });
+
+    this.mcpServer.tool('create_media_buy', {
+      description: 'Create a media buy from selected packages',
+      parameters: {
+        type: 'object',
+        properties: {
+          packages: { type: 'array' },
+          total_budget: { type: 'number' },
+          targeting_overlay: { type: 'object' }
+        }
+      },
+      handler: async (params) => this.createMediaBuy(params)
+    });
+
+    // Mount MCP endpoint
+    this.app.use('/mcp', this.mcpServer.handler());
+  }
+
+  /**
+   * A2A Server - Enables agent-to-agent communication
+   */
+  setupA2AServer() {
+    this.a2aServer = new A2AServer({
+      agentCard: {
+        name: 'AdCP Sales Agent',
+        description: 'AI-powered media buying agent for programmatic advertising',
+        url: 'https://salesagent.example.com/a2a',
+        authentication: ['bearer'],
+        supportedInputFormats: ['text/plain', 'application/json'],
+        supportedOutputFormats: ['text/plain', 'application/json'],
+        skills: [
+          {
+            name: 'campaign_planning',
+            description: 'Plan and create advertising campaigns',
+            examples: [
+              'Create a $50K CTV campaign targeting sports fans',
+              'Plan a holiday campaign with audio and display'
+            ]
+          },
+          {
+            name: 'inventory_discovery', 
+            description: 'Find available advertising inventory',
+            examples: [
+              'What premium video inventory is available?',
+              'Find audio inventory for drive time'
+            ]
+          }
+        ]
+      }
+    });
+
+    // Handle A2A tasks
+    this.a2aServer.on('task', async (task) => {
+      return this.handleA2ATask(task);
+    });
+
+    // Mount A2A endpoint
+    this.app.use('/a2a', this.a2aServer.handler());
+  }
+
+  /**
+   * Discovery endpoints for both protocols
+   */
+  setupDiscovery() {
+    // AdCP discovery with A2A extension
+    this.app.get('/.well-known/adcp.json', (req, res) => {
+      res.json({
+        sales: {
+          mcp: 'https://salesagent.example.com/mcp',
+          a2a: 'https://salesagent.example.com/a2a'
+        }
+      });
+    });
+
+    // A2A Agent Card
+    this.app.get('/.well-known/agent.json', (req, res) => {
+      res.json(this.a2aServer.agentCard);
+    });
+  }
+
+  /**
+   * Handle A2A tasks by mapping to internal operations
+   */
+  async handleA2ATask(task) {
+    const { message } = task;
+    const intent = await this.parseIntent(message);
+
+    switch (intent.type) {
+      case 'inventory_search':
+        return this.handleInventorySearch(intent, task);
+      
+      case 'campaign_creation':
+        return this.handleCampaignCreation(intent, task);
+      
+      case 'performance_report':
+        return this.handlePerformanceReport(intent, task);
+      
+      default:
+        return this.handleGeneralQuery(message, task);
+    }
+  }
+
+  /**
+   * Example: Handle inventory search via A2A
+   */
+  async handleInventorySearch(intent, task) {
+    // Use the same logic as MCP tool
+    const products = await this.getProducts({
+      brief: intent.query,
+      filters: intent.filters
+    });
+
+    // Return A2A response with artifacts
+    return {
+      status: { state: 'completed' },
+      artifacts: [{
+        name: 'inventory_results',
+        parts: [{
+          kind: 'application/json',
+          data: products
+        }, {
+          kind: 'text',
+          text: `Found ${products.length} matching products:\n` +
+                products.map(p => `- ${p.name}: $${p.cpm} CPM`).join('\n')
+        }]
+      }]
+    };
+  }
+
+  /**
+   * Example: Handle campaign creation via A2A (async with updates)
+   */
+  async handleCampaignCreation(intent, task) {
+    const { taskId } = task;
+
+    // Send initial acknowledgment
+    await task.update({
+      status: { state: 'working' },
+      message: 'Analyzing campaign requirements...'
+    });
+
+    // Discover inventory
+    const products = await this.getProducts({
+      brief: intent.brief,
+      filters: { formats: intent.formats }
+    });
+
+    await task.update({
+      message: `Found ${products.length} suitable products. Creating media buy...`
+    });
+
+    // Create the media buy
+    const mediaBuy = await this.createMediaBuy({
+      packages: products.slice(0, 3).map(p => p.product_id),
+      total_budget: intent.budget,
+      targeting_overlay: intent.targeting
+    });
+
+    // Return completed task with results
+    return {
+      status: { state: 'completed' },
+      artifacts: [{
+        name: 'media_buy_confirmation',
+        parts: [{
+          kind: 'application/json',
+          data: mediaBuy
+        }, {
+          kind: 'text',
+          text: `Campaign created successfully!\n` +
+                `Media Buy ID: ${mediaBuy.media_buy_id}\n` +
+                `Status: ${mediaBuy.status}\n` +
+                `Next steps: ${mediaBuy.next_steps.join(', ')}`
+        }]
+      }]
+    };
+  }
+
+  /**
+   * Parse natural language or structured messages into intents
+   */
+  async parseIntent(message) {
+    // In production, this would use NLP or LLM
+    const text = message.parts[0]?.text || '';
+    
+    if (text.includes('inventory') || text.includes('available')) {
+      return { 
+        type: 'inventory_search',
+        query: text,
+        filters: this.extractFilters(text)
+      };
+    }
+    
+    if (text.includes('create') || text.includes('campaign')) {
+      return {
+        type: 'campaign_creation',
+        brief: text,
+        budget: this.extractBudget(text),
+        formats: this.extractFormats(text),
+        targeting: this.extractTargeting(text)
+      };
+    }
+
+    return { type: 'general', query: text };
+  }
+
+  /**
+   * Core business logic (shared between protocols)
+   */
+  async getProducts(params) {
+    // Implementation would connect to actual ad platforms
+    return [
+      {
+        product_id: 'ctv_premium_sports',
+        name: 'Connected TV - Sports Premium',
+        description: 'Premium CTV inventory on sports content',
+        formats: [{ format_id: 'video_standard', name: 'Standard Video' }],
+        cpm: 45.00,
+        min_spend: 10000,
+        brief_relevance: 'Matches sports audience request'
+      },
+      // ... more products
+    ];
+  }
+
+  async createMediaBuy(params) {
+    // Implementation would create actual campaigns
+    return {
+      media_buy_id: 'mb_' + Date.now(),
+      status: 'pending_activation',
+      creative_deadline: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
+      detail: 'Media buy created successfully',
+      next_steps: [
+        'Upload creative assets before deadline',
+        'Assets will be reviewed by ad server',
+        'Campaign will auto-activate after approval'
+      ]
+    };
+  }
+
+  // Helper methods
+  extractBudget(text) {
+    const match = text.match(/\$?([\d,]+)k?/i);
+    if (match) {
+      const value = parseFloat(match[1].replace(/,/g, ''));
+      return text.toLowerCase().includes('k') ? value * 1000 : value;
+    }
+    return 50000; // default
+  }
+
+  extractFormats(text) {
+    const formats = [];
+    if (text.includes('video') || text.includes('ctv')) formats.push('video');
+    if (text.includes('audio')) formats.push('audio');
+    if (text.includes('display')) formats.push('display');
+    return formats.length ? formats : ['video'];
+  }
+
+  extractTargeting(text) {
+    // Simple extraction - in production would be more sophisticated
+    const targeting = {};
+    
+    if (text.includes('sports')) {
+      targeting.content_category_any_of = ['IAB17']; // Sports
+    }
+    
+    const geoMatch = text.match(/in (\w+)/i);
+    if (geoMatch) {
+      targeting.geo_region_any_of = [geoMatch[1].toUpperCase()];
+    }
+    
+    return targeting;
+  }
+
+  start(port = 3000) {
+    this.app.listen(port, () => {
+      console.log(`Dual-protocol AdCP agent running on port ${port}`);
+      console.log(`- MCP endpoint: http://localhost:${port}/mcp`);
+      console.log(`- A2A endpoint: http://localhost:${port}/a2a`);
+      console.log(`- Discovery: http://localhost:${port}/.well-known/adcp.json`);
+      console.log(`- Agent Card: http://localhost:${port}/.well-known/agent.json`);
+    });
+  }
+}
+
+// Start the server
+const agent = new DualProtocolAdCPAgent();
+agent.start();
+
+/**
+ * Example usage from different clients:
+ * 
+ * 1. MCP Client (current AdCP orchestrators):
+ *    POST /mcp
+ *    {
+ *      "method": "get_products",
+ *      "params": { "brief": "sports inventory" }
+ *    }
+ * 
+ * 2. A2A Client (any A2A-compatible agent):
+ *    POST /a2a
+ *    {
+ *      "jsonrpc": "2.0",
+ *      "method": "message/send",
+ *      "params": {
+ *        "message": {
+ *          "parts": [{ 
+ *            "kind": "text", 
+ *            "text": "Find sports inventory for a $50K campaign"
+ *          }]
+ *        }
+ *      }
+ *    }
+ */
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)


From bbd396792b731628ea3d5e68985e72de5dae9259 Mon Sep 17 00:00:00 2001
From: Brian O'Kelley <bokelley@scope3.com>
Date: Sun, 3 Aug 2025 07:59:05 +0100
Subject: [PATCH 2/7] feat: propose A2A-first architecture with native task
 support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Add A2A-first architecture showing Tasks as core abstraction
- Compare HITL implementation complexity (MCP vs A2A native)
- Demonstrate creative workflow using A2A contextId
- Show how A2A's task lifecycle naturally fits advertising workflows

Key insights:
- A2A Tasks provide native support for HITL, status updates, and context
- MCP becomes a compatibility layer rather than core protocol
- Creative workflows benefit from conversational context management

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
---
 docs/architecture/a2a-first-architecture.md   | 336 ++++++++++++++++
 .../a2a-integration/creative-workflow-a2a.md  | 325 +++++++++++++++
 examples/a2a-integration/hitl-comparison.js   | 378 ++++++++++++++++++
 3 files changed, 1039 insertions(+)
 create mode 100644 docs/architecture/a2a-first-architecture.md
 create mode 100644 examples/a2a-integration/creative-workflow-a2a.md
 create mode 100644 examples/a2a-integration/hitl-comparison.js

diff --git a/docs/architecture/a2a-first-architecture.md b/docs/architecture/a2a-first-architecture.md
new file mode 100644
index 0000000..9120043
--- /dev/null
+++ b/docs/architecture/a2a-first-architecture.md
@@ -0,0 +1,336 @@
+# A2A-First Architecture for AdCP
+
+## Key Insight: Tasks as First-Class Citizens
+
+After deeper analysis, it's clear that A2A's Task abstraction is fundamentally better suited for advertising workflows than MCP's request/response model. AdCP should be built on A2A's Task model with MCP as a compatibility layer.
+
+## Why A2A Tasks Are Perfect for AdCP
+
+### 1. Native Human-in-the-Loop Support
+
+```javascript
+// A2A Task naturally handles HITL
+{
+  "taskId": "task-media-buy-123",
+  "status": {
+    "state": "pending_approval",
+    "message": "Awaiting human approval for $1M campaign"
+  },
+  "metadata": {
+    "approvalRequired": true,
+    "approver": "compliance@agency.com"
+  }
+}
+
+// vs MCP requiring explicit HITL implementation
+{
+  "error": {
+    "code": "APPROVAL_REQUIRED",
+    "task_id": "task_123"  // Must build our own task system
+  }
+}
+```
+
+### 2. Progressive Status Updates
+
+A2A Tasks can stream status updates as work progresses:
+
+```javascript
+// Creating a media buy with real-time updates
+Task: "task-mb-456"
+├── Status: "working" - "Checking inventory availability..."
+├── Status: "working" - "Validating targeting parameters..."
+├── Status: "working" - "Calculating optimal budget allocation..."
+├── Status: "working" - "Submitting to ad server..."
+├── Status: "pending_approval" - "Awaiting publisher approval..."
+└── Status: "completed" - Media buy created: mb_789
+```
+
+### 3. Context Management for Multi-Step Workflows
+
+The `contextId` naturally handles iterative workflows like creative management:
+
+```javascript
+// Initial creative upload
+{
+  "contextId": "ctx-campaign-abc",
+  "taskId": "task-creative-upload-1",
+  "artifacts": [{
+    "name": "hero_video.mp4",
+    "artifactId": "art-video-v1"
+  }]
+}
+
+// Request variations (same context)
+{
+  "contextId": "ctx-campaign-abc",  // Same context
+  "referenceTaskIds": ["task-creative-upload-1"],
+  "message": "Create vertical version for mobile"
+}
+
+// Get new artifact in same context
+{
+  "contextId": "ctx-campaign-abc",
+  "taskId": "task-creative-adapt-2",
+  "artifacts": [{
+    "name": "hero_video_vertical.mp4",
+    "artifactId": "art-video-v2"
+  }]
+}
+```
+
+## Revised Architecture: A2A Core with MCP Adapter
+
+```
+┌─────────────────────────────────────────────┐
+│           AdCP Agent (A2A-First)            │
+├─────────────────────────────────────────────┤
+│  ┌────────────────────────────────────────┐│
+│  │          A2A Task Engine               ││
+│  │  - Task lifecycle management           ││
+│  │  - Context persistence                 ││
+│  │  - Artifact handling                   ││
+│  │  - Status streaming (SSE)              ││
+│  └────────────────────────────────────────┘│
+│                    │                        │
+│  ┌─────────────────┴──────────────────┐   │
+│  │      Core Business Logic           │   │
+│  │  - Media Buy workflows             │   │
+│  │  - Signal discovery                │   │
+│  │  - Creative management             │   │
+│  │  - HITL operations                 │   │
+│  └─────────────────┬──────────────────┘   │
+│                    │                        │
+│  ┌────────────────┴───────────────────┐   │
+│  │       MCP Compatibility Layer      │   │
+│  │  - Translates tools to tasks       │   │
+│  │  - Maintains backward compat       │   │
+│  └────────────────────────────────────┘   │
+└─────────────────────────────────────────────┘
+```
+
+## Real-World AdCP Workflows as A2A Tasks
+
+### Media Buy Creation with Natural Status Updates
+
+```javascript
+class MediaBuyTask {
+  async execute(params, task) {
+    // Update: Starting
+    await task.update({
+      status: { state: "working" },
+      message: "Analyzing campaign requirements..."
+    });
+
+    // Check inventory
+    await task.update({
+      message: "Checking inventory availability across 5 platforms..."
+    });
+    const inventory = await this.checkInventory(params.brief);
+
+    // Validate targeting
+    await task.update({
+      message: "Validating targeting parameters and compliance..."
+    });
+    const validation = await this.validateTargeting(params.targeting);
+
+    if (validation.requiresApproval) {
+      // Natural HITL state
+      await task.update({
+        status: { state: "pending_approval" },
+        message: "Campaign requires compliance approval",
+        metadata: {
+          approvalType: "compliance",
+          reason: validation.reason
+        }
+      });
+      
+      // Wait for approval (via webhook or polling)
+      await this.waitForApproval(task.id);
+    }
+
+    // Create the buy
+    await task.update({
+      message: "Creating media buy in ad server..."
+    });
+    const mediaBuy = await this.createInAdServer(params);
+
+    // Return with artifacts
+    return {
+      status: { state: "completed" },
+      artifacts: [{
+        name: "media_buy_confirmation",
+        parts: [{
+          kind: "application/json",
+          data: mediaBuy
+        }, {
+          kind: "application/pdf",
+          uri: mediaBuy.contractUrl
+        }]
+      }]
+    };
+  }
+}
+```
+
+### Creative Workflow with Context
+
+```javascript
+// Task 1: Upload initial creative
+{
+  "method": "message/send",
+  "params": {
+    "message": {
+      "parts": [{
+        "kind": "text",
+        "text": "Upload creative for pet food campaign"
+      }, {
+        "kind": "file",
+        "uri": "https://cdn.example.com/pet_food_hero.mp4"
+      }]
+    }
+  }
+}
+
+// Response: Task with context
+{
+  "taskId": "task-creative-001",
+  "contextId": "ctx-petfood-campaign",
+  "status": { "state": "completed" },
+  "artifacts": [{
+    "artifactId": "art-creative-v1",
+    "name": "pet_food_hero.mp4"
+  }]
+}
+
+// Task 2: Request adaptation (same context)
+{
+  "method": "message/send",
+  "params": {
+    "contextId": "ctx-petfood-campaign",  // Continue conversation
+    "message": {
+      "parts": [{
+        "kind": "text",
+        "text": "Create a 15-second version and add captions"
+      }]
+    }
+  }
+}
+
+// Status updates via SSE
+data: {"status": {"state": "working"}, "message": "Analyzing video content..."}
+data: {"status": {"state": "working"}, "message": "Generating 15s cut..."}
+data: {"status": {"state": "working"}, "message": "Adding captions..."}
+data: {"status": {"state": "completed"}, "artifacts": [...]}
+```
+
+## MCP Compatibility Layer
+
+For backward compatibility, we provide an MCP interface that translates to A2A tasks:
+
+```javascript
+class MCPCompatibilityLayer {
+  async handleToolCall(tool, params) {
+    // Create an A2A task
+    const task = await this.a2aEngine.createTask({
+      type: 'mcp_tool_call',
+      tool: tool,
+      params: params
+    });
+
+    // Wait for completion (blocking mode)
+    const result = await task.waitForCompletion();
+
+    // Return MCP-style response
+    if (result.status.state === 'completed') {
+      return this.extractMCPResponse(result.artifacts);
+    } else {
+      throw new Error(result.status.message);
+    }
+  }
+
+  // Special handling for async operations
+  async handleAsyncTool(tool, params) {
+    const task = await this.a2aEngine.createTask({
+      type: 'mcp_async_tool',
+      tool: tool,
+      params: params
+    });
+
+    // Return task ID for polling
+    return {
+      task_id: task.id,
+      status: 'pending',
+      poll_url: `/tasks/${task.id}/status`
+    };
+  }
+}
+```
+
+## Benefits of A2A-First Architecture
+
+### 1. Natural Workflow Representation
+- Media buys naturally progress through states
+- Creative workflows maintain context
+- HITL is a first-class citizen
+
+### 2. Better User Experience
+- Real-time progress updates
+- Clear status communication
+- Contextual error handling
+
+### 3. Simplified Implementation
+- No need to build task management on top of MCP
+- Status updates are built-in
+- Artifact handling is native
+
+### 4. Future-Proof
+- Aligns with Google's vision for agent communication
+- Supports complex multi-agent workflows
+- Ready for advanced features like UI embedding
+
+## Migration Strategy
+
+### Phase 1: Internal A2A Implementation
+- Build core workflows on A2A Task model
+- Use contextId for campaign management
+- Implement status streaming
+
+### Phase 2: MCP Compatibility
+- Add MCP adapter for existing clients
+- Map tools to task types
+- Provide polling for async operations
+
+### Phase 3: Full A2A Exposure
+- Expose native A2A endpoints
+- Enable cross-agent collaboration
+- Support advanced A2A features
+
+## Example: Complete Media Buy Flow
+
+```javascript
+// 1. Start campaign planning
+Client -> Agent: "Plan a $100K campaign for pet food"
+Agent -> Client: taskId: "task-plan-001", status: "working"
+
+// 2. Stream progress updates
+SSE: "Analyzing market conditions..."
+SSE: "Found 15 suitable products across 3 platforms"
+SSE: "Optimizing budget allocation..."
+
+// 3. Present plan (with artifact)
+Agent -> Client: status: "completed", artifact: "campaign_plan.pdf"
+
+// 4. Continue in same context
+Client -> Agent: "Looks good, but increase CTV budget by 20%"
+Agent -> Client: taskId: "task-plan-002", contextId: (same)
+
+// 5. Execute with HITL
+Client -> Agent: "Execute this plan"
+Agent -> Client: status: "pending_approval", "Requires compliance review"
+
+// 6. After approval
+Agent -> Client: status: "completed", artifacts: [media_buy_ids]
+```
+
+This A2A-first approach makes AdCP workflows more natural, powerful, and future-proof while maintaining compatibility with existing MCP clients.
\ No newline at end of file
diff --git a/examples/a2a-integration/creative-workflow-a2a.md b/examples/a2a-integration/creative-workflow-a2a.md
new file mode 100644
index 0000000..28be9d6
--- /dev/null
+++ b/examples/a2a-integration/creative-workflow-a2a.md
@@ -0,0 +1,325 @@
+# Creative Workflow with A2A Context Management
+
+This example shows how A2A's `contextId` perfectly handles the iterative nature of creative workflows in advertising.
+
+## The Workflow
+
+A typical creative workflow involves multiple steps:
+1. Initial creative upload
+2. Automated review and feedback
+3. Request for variations (different sizes, formats)
+4. Approval cycles
+5. Final asset delivery
+
+With A2A's context model, this becomes a natural conversation.
+
+## Complete Example: Adding Creatives to a Campaign
+
+### Step 1: Initial Creative Upload
+
+```json
+// Client sends creative
+{
+  "method": "message/send",
+  "params": {
+    "message": {
+      "role": "user",
+      "parts": [
+        {
+          "kind": "text",
+          "text": "Upload creative for the pet food campaign media buy mb_12345"
+        },
+        {
+          "kind": "file",
+          "uri": "https://cdn.agency.com/creatives/petfood_hero_30s.mp4",
+          "metadata": {
+            "filename": "petfood_hero_30s.mp4",
+            "mimeType": "video/mp4",
+            "duration": 30,
+            "dimensions": { "width": 1920, "height": 1080 }
+          }
+        }
+      ]
+    }
+  }
+}
+```
+
+### Step 2: Agent Response with Context
+
+```json
+// Agent creates task and establishes context
+{
+  "taskId": "task-creative-001",
+  "contextId": "ctx-creative-petfood-mb12345",  // Context for this creative workflow
+  "status": {
+    "state": "working"
+  },
+  "message": "Analyzing creative and checking policy compliance..."
+}
+
+// Status updates via SSE
+data: {"message": "✓ Duration check passed (30s)"}
+data: {"message": "✓ Resolution check passed (1920x1080)"}
+data: {"message": "✓ Audio levels within range"}
+data: {"message": "⚠️ Missing captions for accessibility"}
+
+// Final response
+{
+  "taskId": "task-creative-001",
+  "contextId": "ctx-creative-petfood-mb12345",
+  "status": {
+    "state": "completed"
+  },
+  "artifacts": [{
+    "artifactId": "art-creative-v1",
+    "name": "creative_analysis",
+    "parts": [{
+      "kind": "application/json",
+      "data": {
+        "creativeId": "creative_petfood_30s_v1",
+        "status": "approved_with_suggestions",
+        "analysis": {
+          "technical": "pass",
+          "policy": "pass",
+          "accessibility": "warning"
+        },
+        "suggestions": [
+          {
+            "type": "accessibility",
+            "priority": "high",
+            "description": "Add captions for hearing-impaired viewers",
+            "impact": "Required for some platforms"
+          },
+          {
+            "type": "optimization",
+            "priority": "medium",
+            "description": "Create 15s version for better inventory match",
+            "impact": "Could access 40% more inventory"
+          },
+          {
+            "type": "format",
+            "priority": "medium", 
+            "description": "Create vertical (9:16) version for mobile",
+            "impact": "Mobile inventory has 35% better performance"
+          }
+        ]
+      }
+    }]
+  }]
+}
+```
+
+### Step 3: Client Requests Variations (Same Context)
+
+```json
+// Client continues in same context
+{
+  "method": "message/send",
+  "params": {
+    "contextId": "ctx-creative-petfood-mb12345",  // Same context!
+    "referenceTaskIds": ["task-creative-001"],     // Reference previous task
+    "message": {
+      "role": "user",
+      "parts": [{
+        "kind": "text",
+        "text": "Please create the 15s version and add captions to both versions"
+      }]
+    }
+  }
+}
+```
+
+### Step 4: Agent Processes Request with Context
+
+```json
+// Agent has full context and can reference previous artifacts
+{
+  "taskId": "task-creative-002",
+  "contextId": "ctx-creative-petfood-mb12345",  // Maintains context
+  "status": {
+    "state": "working"
+  },
+  "message": "Creating variations based on your request..."
+}
+
+// Progress updates
+data: {"message": "Generating 15-second cut..."}
+data: {"message": "Identifying key moments for shorter version..."}
+data: {"message": "Adding captions to 30s version..."}
+data: {"message": "Adding captions to 15s version..."}
+data: {"message": "Validating all versions..."}
+
+// Completion with new artifacts
+{
+  "taskId": "task-creative-002",
+  "contextId": "ctx-creative-petfood-mb12345",
+  "status": {
+    "state": "completed"
+  },
+  "artifacts": [{
+    "artifactId": "art-creative-v2",
+    "name": "creative_package",
+    "parts": [
+      {
+        "kind": "file",
+        "uri": "https://cdn.publisher.com/processed/petfood_hero_30s_captioned.mp4",
+        "metadata": {
+          "creativeId": "creative_petfood_30s_v2",
+          "version": 2,
+          "duration": 30,
+          "hasCaptions": true,
+          "format": "video_standard_30s"
+        }
+      },
+      {
+        "kind": "file", 
+        "uri": "https://cdn.publisher.com/processed/petfood_hero_15s_captioned.mp4",
+        "metadata": {
+          "creativeId": "creative_petfood_15s_v1",
+          "version": 1,
+          "duration": 15,
+          "hasCaptions": true,
+          "format": "video_standard_15s"
+        }
+      }
+    ]
+  }],
+  "message": "Created 2 versions with captions. Both are ready for the campaign."
+}
+```
+
+### Step 5: Human Review Required (Same Context)
+
+```json
+// Something requires human review
+{
+  "taskId": "task-creative-003",
+  "contextId": "ctx-creative-petfood-mb12345",
+  "status": {
+    "state": "pending_review",
+    "metadata": {
+      "reviewType": "brand_safety",
+      "flaggedElement": "Background music similarity",
+      "reviewer": "legal@publisher.com"
+    }
+  },
+  "message": "Creative requires legal review due to potential music copyright concern",
+  "artifacts": [{
+    "name": "review_package",
+    "parts": [{
+      "kind": "application/json",
+      "data": {
+        "concern": "Background music has 87% similarity to copyrighted track",
+        "track": "Popular Song by Famous Artist",
+        "timestamp": "0:12-0:28",
+        "recommendation": "Replace audio track or obtain license"
+      }
+    }]
+  }]
+}
+```
+
+### Step 6: Approval/Resolution (Same Context)
+
+```json
+// Legal team responds in the same context
+{
+  "method": "message/send", 
+  "params": {
+    "contextId": "ctx-creative-petfood-mb12345",
+    "message": {
+      "role": "user",
+      "parts": [{
+        "kind": "text",
+        "text": "Approved - we have licensing rights for this track. Document attached.",
+      }, {
+        "kind": "file",
+        "uri": "https://legal.publisher.com/licenses/track_license_2024.pdf"
+      }]
+    }
+  }
+}
+
+// Agent continues with approval
+{
+  "taskId": "task-creative-004",
+  "contextId": "ctx-creative-petfood-mb12345",
+  "status": {
+    "state": "completed"
+  },
+  "message": "All creatives approved and assigned to media buy mb_12345",
+  "artifacts": [{
+    "name": "final_creative_assignment",
+    "parts": [{
+      "kind": "application/json",
+      "data": {
+        "mediaBuyId": "mb_12345",
+        "creatives": [
+          {
+            "creativeId": "creative_petfood_30s_v2",
+            "packageAssignments": ["pkg_ctv_premium"],
+            "status": "active"
+          },
+          {
+            "creativeId": "creative_petfood_15s_v1", 
+            "packageAssignments": ["pkg_ctv_standard", "pkg_mobile_video"],
+            "status": "active"
+          }
+        ],
+        "legalClearance": {
+          "status": "approved",
+          "documentId": "doc_license_456",
+          "approvedBy": "legal@publisher.com"
+        }
+      }
+    }]
+  }]
+}
+```
+
+## Why This Is Powerful
+
+### 1. **Natural Conversation Flow**
+The entire creative workflow happens in one context, like a conversation thread. No need to pass state between disconnected API calls.
+
+### 2. **Automatic State Management**
+The agent maintains the context - it knows which media buy, which creatives, what's been discussed.
+
+### 3. **Multi-Party Collaboration**
+Different users (creative team, legal, account manager) can all participate in the same context.
+
+### 4. **Audit Trail**
+The complete conversation history is maintained, perfect for compliance and debugging.
+
+### 5. **Flexible Workflow**
+Can handle unexpected paths (like legal review) without breaking the flow.
+
+## Comparison with MCP
+
+With MCP, this same workflow would require:
+
+```javascript
+// Multiple disconnected API calls
+const creative1 = await mcp.call('upload_creative', {...});
+const analysis = await mcp.call('analyze_creative', {creative_id: creative1.id});
+const variations = await mcp.call('create_variations', {
+  creative_id: creative1.id,
+  variations: ['15s', 'add_captions']
+});
+
+// If human review needed, must implement custom task system
+if (analysis.requires_review) {
+  const taskId = await mcp.call('create_review_task', {...});
+  // Poll or webhook for completion
+  // Lose conversational context
+}
+
+// Must manually thread IDs through each call
+const assignment = await mcp.call('assign_creatives', {
+  media_buy_id: 'mb_12345',
+  creative_ids: [creative1.id, ...variations.ids]
+});
+```
+
+With A2A, it's just a natural conversation in one context.
\ No newline at end of file
diff --git a/examples/a2a-integration/hitl-comparison.js b/examples/a2a-integration/hitl-comparison.js
new file mode 100644
index 0000000..8c0c812
--- /dev/null
+++ b/examples/a2a-integration/hitl-comparison.js
@@ -0,0 +1,378 @@
+/**
+ * Comparison: Human-in-the-Loop Implementation
+ * 
+ * Shows how A2A's native Task model simplifies HITL compared to 
+ * implementing it on top of MCP
+ */
+
+// ============================================
+// CURRENT: MCP-based HITL (Complex)
+// ============================================
+
+class MCPBasedHITL {
+  constructor() {
+    // Need to build our own task management
+    this.tasks = new Map();
+    this.webhooks = new Map();
+  }
+
+  async createMediaBuy(params) {
+    try {
+      // Try to create
+      const result = await this.adServer.createCampaign(params);
+      return result;
+    } catch (error) {
+      if (error.code === 'APPROVAL_REQUIRED') {
+        // Need to create our own task system
+        const taskId = this.generateTaskId();
+        
+        // Store task state
+        this.tasks.set(taskId, {
+          id: taskId,
+          type: 'media_buy_approval',
+          status: 'pending',
+          params: params,
+          created: new Date()
+        });
+
+        // Send webhook notification
+        await this.notifyApprover(taskId);
+
+        // Return error with task ID
+        return {
+          error: {
+            code: 'PENDING_APPROVAL',
+            message: 'Manual approval required',
+            task_id: taskId,
+            // Client must poll or register webhook
+            poll_url: `/tasks/${taskId}/status`
+          }
+        };
+      }
+      throw error;
+    }
+  }
+
+  // Need separate endpoints for task management
+  async getTaskStatus(taskId) {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error('Task not found');
+    return task;
+  }
+
+  async approveTask(taskId, approver) {
+    const task = this.tasks.get(taskId);
+    if (!task) throw new Error('Task not found');
+    
+    // Update task
+    task.status = 'approved';
+    task.approvedBy = approver;
+    
+    // Execute the original operation
+    const result = await this.adServer.createCampaign(task.params);
+    
+    // Notify webhook if registered
+    const webhook = this.webhooks.get(taskId);
+    if (webhook) {
+      await fetch(webhook.url, {
+        method: 'POST',
+        body: JSON.stringify({ taskId, status: 'completed', result })
+      });
+    }
+    
+    return result;
+  }
+}
+
+// ============================================
+// NEW: A2A-based HITL (Native)
+// ============================================
+
+class A2ABasedHITL {
+  async handleMediaBuyTask(message, task) {
+    const params = this.parseParams(message);
+    
+    // Update task status as we progress
+    await task.update({
+      status: { state: 'working' },
+      message: 'Validating campaign parameters...'
+    });
+
+    // Check if approval needed
+    const validation = await this.validateCampaign(params);
+    
+    if (validation.requiresApproval) {
+      // A2A handles this natively
+      await task.update({
+        status: { 
+          state: 'pending_approval',
+          metadata: {
+            approvalType: 'compliance',
+            reason: validation.reason,
+            approver: 'compliance@agency.com'
+          }
+        },
+        message: `Campaign requires ${validation.approvalType} approval`,
+        // Client can subscribe to updates
+        pushNotificationConfig: {
+          url: message.configuration?.pushNotificationConfig?.url
+        }
+      });
+
+      // Task is now in pending state
+      // A2A protocol handles:
+      // - State persistence
+      // - Status queries
+      // - Update notifications
+      // - Context preservation
+      
+      // When approved (via separate A2A message or webhook)
+      // the task continues in the same context
+      return;
+    }
+
+    // If no approval needed, continue
+    await task.update({
+      message: 'Creating campaign in ad server...'
+    });
+
+    const result = await this.adServer.createCampaign(params);
+
+    // Return completed task with artifacts
+    return {
+      status: { state: 'completed' },
+      artifacts: [{
+        name: 'media_buy_confirmation',
+        parts: [{
+          kind: 'application/json',
+          data: result
+        }]
+      }]
+    };
+  }
+
+  // Approval is just another A2A message in the same context
+  async handleApprovalMessage(message, task) {
+    const { contextId, referenceTaskIds } = message;
+    
+    // Find the pending task in this context
+    const pendingTask = await this.findPendingTask(contextId, referenceTaskIds);
+    
+    if (message.parts[0].text.includes('approved')) {
+      // Continue the original task
+      await pendingTask.update({
+        status: { state: 'working' },
+        message: 'Approval received, creating campaign...'
+      });
+      
+      // Execute the campaign
+      const result = await this.adServer.createCampaign(pendingTask.params);
+      
+      // Complete with result
+      await pendingTask.update({
+        status: { state: 'completed' },
+        artifacts: [{
+          name: 'media_buy_confirmation',
+          parts: [{
+            kind: 'application/json',
+            data: result
+          }]
+        }]
+      });
+    } else {
+      // Rejection
+      await pendingTask.update({
+        status: { 
+          state: 'failed',
+          error: {
+            code: 'APPROVAL_REJECTED',
+            message: 'Campaign rejected by approver'
+          }
+        }
+      });
+    }
+  }
+}
+
+// ============================================
+// USAGE COMPARISON
+// ============================================
+
+// MCP: Complex polling/webhook pattern
+const mcpClient = {
+  async createCampaignWithApproval() {
+    // 1. Try to create
+    const response = await mcp.call('create_media_buy', params);
+    
+    if (response.error?.code === 'PENDING_APPROVAL') {
+      // 2. Register webhook or start polling
+      const taskId = response.error.task_id;
+      
+      // Option A: Polling
+      while (true) {
+        const status = await fetch(`/tasks/${taskId}/status`);
+        if (status.status !== 'pending') break;
+        await sleep(5000);
+      }
+      
+      // Option B: Webhook
+      await fetch('/webhooks/register', {
+        method: 'POST',
+        body: JSON.stringify({
+          task_id: taskId,
+          url: 'https://myapp.com/webhooks/task-updates'
+        })
+      });
+    }
+  }
+};
+
+// A2A: Native task handling
+const a2aClient = {
+  async createCampaignWithApproval() {
+    // 1. Send message (with optional notification URL)
+    const response = await a2a.send({
+      message: {
+        parts: [{
+          kind: 'text',
+          text: 'Create $100K CTV campaign for pet food'
+        }]
+      },
+      configuration: {
+        pushNotificationConfig: {
+          url: 'https://myapp.com/a2a/notifications'
+        }
+      }
+    });
+
+    // 2. A2A handles everything
+    // - Returns task with status
+    // - Streams updates via SSE if connected
+    // - Sends webhook notifications if configured
+    // - Maintains context for follow-ups
+    
+    // 3. Can check status anytime
+    const status = await a2a.getTask(response.taskId);
+    
+    // 4. Can continue in same context
+    if (status.state === 'pending_approval') {
+      // Approver can respond in same context
+      await a2a.send({
+        contextId: response.contextId,
+        message: {
+          parts: [{ kind: 'text', text: 'Approved' }]
+        }
+      });
+    }
+  }
+};
+
+// ============================================
+// REAL EXAMPLE: Creative Review Workflow
+// ============================================
+
+class CreativeReviewWorkflow {
+  async handleCreativeSubmission(message, task) {
+    const { contextId } = task;
+    
+    // Extract creative from message
+    const creative = message.parts.find(p => p.kind === 'file');
+    
+    await task.update({
+      status: { state: 'working' },
+      message: 'Analyzing creative for policy compliance...'
+    });
+
+    // Run automated checks
+    const autoReview = await this.runAutomatedChecks(creative);
+    
+    await task.update({
+      message: `Automated checks: ${autoReview.passed ? 'Passed' : 'Failed'}`,
+      artifacts: [{
+        name: 'automated_review',
+        parts: [{
+          kind: 'application/json',
+          data: autoReview
+        }]
+      }]
+    });
+
+    if (!autoReview.passed || autoReview.requiresHumanReview) {
+      // Need human review
+      await task.update({
+        status: { 
+          state: 'pending_review',
+          metadata: {
+            reviewType: 'creative_policy',
+            autoReviewResult: autoReview,
+            assignedTo: 'creative-review@publisher.com'
+          }
+        },
+        message: 'Creative requires human review',
+        // Include preview for reviewer
+        artifacts: [{
+          name: 'review_package',
+          parts: [
+            { kind: 'file', uri: creative.uri },
+            { kind: 'application/json', data: autoReview }
+          ]
+        }]
+      });
+      
+      // Task pauses here naturally
+      // Reviewer can respond in same context with approval/rejection
+      return;
+    }
+
+    // Auto-approved
+    await this.approveCreative(creative, task);
+  }
+
+  async handleReviewerResponse(message, task) {
+    const { contextId, referenceTaskIds } = message;
+    const decision = this.parseDecision(message);
+    
+    if (decision.approved) {
+      await task.update({
+        status: { state: 'working' },
+        message: 'Creative approved, generating variations...'
+      });
+      
+      // Generate required formats
+      const variations = await this.generateVariations(task.originalCreative);
+      
+      await task.update({
+        status: { state: 'completed' },
+        message: 'Creative approved and variations generated',
+        artifacts: [{
+          name: 'approved_creatives',
+          parts: variations.map(v => ({
+            kind: 'file',
+            uri: v.uri,
+            metadata: { format: v.format }
+          }))
+        }]
+      });
+    } else {
+      await task.update({
+        status: { state: 'rejected' },
+        message: `Creative rejected: ${decision.reason}`,
+        metadata: {
+          rejectionReason: decision.reason,
+          suggestedChanges: decision.suggestions
+        }
+      });
+    }
+  }
+}
+
+/**
+ * Key Advantages of A2A for HITL:
+ * 
+ * 1. **Native Status Model**: pending_approval, pending_review are first-class states
+ * 2. **Context Preservation**: Approvals happen in the same conversation context
+ * 3. **No Polling Required**: SSE provides real-time updates
+ * 4. **Simpler Implementation**: No need to build task management infrastructure
+ * 5. **Better UX**: Natural conversation flow for multi-step processes
+ * 6. **Audit Trail**: Task history maintained automatically
+ */
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)


From 0fc796c5fe4b3f838c89737201d47d3a27e65457 Mon Sep 17 00:00:00 2001
From: Brian O'Kelley <bokelley@scope3.com>
Date: Sun, 3 Aug 2025 08:00:29 +0100
Subject: [PATCH 3/7] docs: add A2A recommendation and detailed comparison
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Add executive recommendation for A2A-first architecture
- Create detailed technical comparison table (A2A vs MCP)
- Show concrete examples of why A2A fits advertising workflows better
- Highlight A2A's native support for HITL, context, and task lifecycle

Key insight: Advertising workflows are inherently task-based with approvals,
long-running operations, and multi-step processes. A2A's Task model provides
these capabilities natively, while MCP requires building them from scratch.

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
---
 docs/architecture/a2a-mcp-comparison.md | 162 ++++++++++++++++++++++
 docs/architecture/a2a-recommendation.md | 176 ++++++++++++++++++++++++
 2 files changed, 338 insertions(+)
 create mode 100644 docs/architecture/a2a-mcp-comparison.md
 create mode 100644 docs/architecture/a2a-recommendation.md

diff --git a/docs/architecture/a2a-mcp-comparison.md b/docs/architecture/a2a-mcp-comparison.md
new file mode 100644
index 0000000..cabb746
--- /dev/null
+++ b/docs/architecture/a2a-mcp-comparison.md
@@ -0,0 +1,162 @@
+# A2A vs MCP: Technical Comparison for AdCP
+
+## Quick Comparison Table
+
+| Feature | MCP | A2A | Winner for AdCP |
+|---------|-----|-----|-----------------|
+| **Request Model** | Request/Response | Task-based with lifecycle | A2A ✅ |
+| **Human-in-the-Loop** | Build yourself | Native states (pending_approval) | A2A ✅ |
+| **Status Updates** | Poll or custom webhooks | Native SSE streaming | A2A ✅ |
+| **Context Management** | Pass IDs manually | contextId maintains conversation | A2A ✅ |
+| **Long-Running Operations** | Return task ID, poll | Native async with updates | A2A ✅ |
+| **Error Handling** | Immediate or fail | Can pause, await input, resume | A2A ✅ |
+| **Multi-Step Workflows** | Chain API calls | Natural conversation flow | A2A ✅ |
+| **Artifact Handling** | Return in response | Structured artifacts with metadata | A2A ✅ |
+| **Protocol Complexity** | Simple | More comprehensive | MCP ✅ |
+| **Current Adoption** | Anthropic ecosystem | Google + 100+ partners | A2A ✅ |
+
+## Detailed Comparison
+
+### Creating a Media Buy
+
+#### MCP Approach
+```javascript
+// Step 1: Try to create
+const result = await mcp.call('create_media_buy', params);
+
+// Step 2: Handle approval needed
+if (result.error?.code === 'APPROVAL_REQUIRED') {
+  // Must implement:
+  // - Task storage
+  // - Webhook system  
+  // - Polling endpoints
+  // - State management
+  const taskId = result.error.task_id;
+  
+  // Step 3: Poll for updates
+  while (true) {
+    const status = await getTaskStatus(taskId);
+    if (status !== 'pending') break;
+    await sleep(5000);
+  }
+}
+```
+
+#### A2A Approach
+```javascript
+// Step 1: Send task
+const task = await a2a.send({
+  message: { text: "Create $100K campaign" }
+});
+
+// Step 2: Automatic updates via SSE
+// "Checking inventory..."
+// "Validating budget..."  
+// "Pending approval..."
+
+// Step 3: Continue in same context when approved
+// No polling, no custom task system needed
+```
+
+### Creative Review Workflow
+
+#### MCP: Multiple Disconnected Calls
+```javascript
+// Upload
+const upload = await mcp.call('upload_creative', {
+  file: 'video.mp4',
+  media_buy_id: 'mb_123'  // Must pass context
+});
+
+// Analyze  
+const analysis = await mcp.call('analyze_creative', {
+  creative_id: upload.creative_id,  // Thread ID
+  media_buy_id: 'mb_123'           // Thread context
+});
+
+// Request changes
+const variations = await mcp.call('create_variations', {
+  creative_id: upload.creative_id,  // Thread ID again
+  media_buy_id: 'mb_123',          // Thread context again
+  variations: ['15s', 'captions']
+});
+
+// If human review needed - build custom system
+```
+
+#### A2A: Natural Conversation
+```javascript
+// Upload in context
+const task1 = await a2a.send({
+  message: { 
+    text: "Upload creative for campaign",
+    file: "video.mp4"
+  }
+});
+// Returns: contextId: "ctx-creative-123"
+
+// Continue conversation
+const task2 = await a2a.send({
+  contextId: "ctx-creative-123",  // Same context!
+  message: { text: "Create 15s version with captions" }
+});
+
+// Human review - native support
+// Status: "pending_review"
+// Reviewer responds in same context
+```
+
+## Why A2A is Better for AdCP
+
+### 1. **Advertising is Task-Based**
+- Campaigns take time to create
+- Multiple approval steps
+- Long-running optimizations
+- A2A models this naturally
+
+### 2. **HITL is Essential**
+- Compliance reviews
+- Budget approvals  
+- Creative reviews
+- A2A has this built-in
+
+### 3. **Context is Critical**
+- Creative → Campaign → Performance
+- Multi-step workflows
+- Team collaboration
+- A2A's contextId handles this
+
+### 4. **Transparency Matters**
+- Clients need progress updates
+- "What's happening with my campaign?"
+- A2A streams status natively
+
+### 5. **Errors Aren't Fatal**
+- "Fix this targeting issue"
+- "Add this creative"
+- "Change the budget"
+- A2A tasks can pause and resume
+
+## MCP Strengths (Where It's Better)
+
+1. **Simplicity**: Easier to implement basic tools
+2. **Immediate Response**: Good for quick lookups
+3. **Anthropic Ecosystem**: Deep integration with Claude
+
+## Recommendation
+
+Use A2A as the core protocol for AdCP because:
+
+1. **Natural Fit**: Task model matches advertising workflows
+2. **Less Code**: Don't build what A2A provides
+3. **Better UX**: Real-time updates, natural conversations
+4. **Future-Proof**: Broader ecosystem support
+
+Provide MCP compatibility for:
+1. Simple tool queries (get_products)
+2. Backward compatibility  
+3. Anthropic ecosystem integration
+
+## The Verdict
+
+**A2A for workflows, MCP for tools.** Since AdCP is primarily about workflows (media buying, creative management, optimization), A2A is the clear choice as the primary protocol.
\ No newline at end of file
diff --git a/docs/architecture/a2a-recommendation.md b/docs/architecture/a2a-recommendation.md
new file mode 100644
index 0000000..a267412
--- /dev/null
+++ b/docs/architecture/a2a-recommendation.md
@@ -0,0 +1,176 @@
+# Recommendation: Build AdCP on A2A Protocol
+
+## Executive Summary
+
+After analyzing both protocols, we recommend building AdCP on Google's A2A protocol as the foundational layer, with MCP provided as a compatibility interface. A2A's Task abstraction is fundamentally better suited for advertising workflows than MCP's request/response model.
+
+## Key Reasons
+
+### 1. Tasks Are Perfect for Advertising Workflows
+
+Advertising operations are inherently task-based:
+- **Media Buy Creation**: Multi-step process with checkpoints
+- **Creative Review**: Iterative workflow with approvals
+- **Campaign Optimization**: Long-running analysis and adjustments
+
+A2A Tasks provide:
+- Native status progression (pending → working → completed)
+- Built-in human-in-the-loop states
+- Real-time progress updates via SSE
+- Context preservation across interactions
+
+### 2. Human-in-the-Loop is First-Class
+
+Current AdCP must build HITL on top of MCP:
+```javascript
+// MCP: Return error, build custom task system
+return { 
+  error: { 
+    code: "APPROVAL_REQUIRED", 
+    task_id: "custom_task_123" 
+  } 
+}
+```
+
+With A2A, it's native:
+```javascript
+// A2A: Natural task state
+await task.update({
+  status: { state: "pending_approval" },
+  message: "Awaiting compliance review"
+})
+```
+
+### 3. Context Management for Complex Workflows
+
+The `contextId` elegantly handles multi-step processes:
+- Upload creative → Get feedback → Make changes → Get approval
+- All in one conversational context
+- No manual state threading between API calls
+
+### 4. Real-Time Status Updates
+
+Clients can see what's happening:
+- "Checking inventory availability..."
+- "Validating targeting parameters..."
+- "Submitting to ad server..."
+- "Awaiting publisher approval..."
+
+This transparency is crucial for enterprise workflows.
+
+## Proposed Architecture
+
+```
+┌─────────────────────────────────────┐
+│        AdCP Agent (A2A Core)        │
+├─────────────────────────────────────┤
+│  ╔═══════════════════════════════╗  │
+│  ║   A2A Task Engine (Primary)   ║  │
+│  ║   - Task lifecycle            ║  │
+│  ║   - Context management        ║  │
+│  ║   - Status streaming          ║  │
+│  ║   - Artifact handling         ║  │
+│  ╚═══════════════════════════════╝  │
+│              │                       │
+│  ┌───────────┴────────────────────┐ │
+│  │   Advertising Business Logic   │ │
+│  │   - Media Buy workflows        │ │
+│  │   - Creative management        │ │
+│  │   - Signal discovery           │ │
+│  └───────────┬────────────────────┘ │
+│              │                       │
+│  ┌───────────┴────────────────────┐ │
+│  │  MCP Adapter (Compatibility)   │ │
+│  │  - Legacy support              │ │
+│  │  - Tool → Task translation    │ │
+│  └────────────────────────────────┘ │
+└─────────────────────────────────────┘
+```
+
+## Implementation Path
+
+### Phase 1: Build on A2A (Q2 2025)
+- Implement core workflows using A2A Tasks
+- Use contextId for campaign management
+- Native HITL support from day one
+
+### Phase 2: MCP Compatibility (Q3 2025)
+- Add MCP adapter for existing integrations
+- Translate MCP tools to A2A tasks
+- Maintain backward compatibility
+
+### Phase 3: Advanced Features (Q4 2025)
+- Multi-agent collaboration
+- Cross-platform orchestration
+- Advanced artifact handling
+
+## Example: Media Buy as A2A Task
+
+```javascript
+// Natural workflow with status updates
+Client: "Create $100K CTV campaign for sports fans"
+
+Agent: Task "task-mb-001" created
+  ↓ Status: "Analyzing requirements..."
+  ↓ Status: "Found 12 suitable products"
+  ↓ Status: "Optimizing budget allocation..."
+  ↓ Status: "Creating campaign..." 
+  ↓ Status: "Pending approval (compliance required)"
+  
+Client: "Approved"
+
+Agent: Task completed
+  → Artifact: media_buy_confirmation.json
+  → Artifact: insertion_order.pdf
+```
+
+## Risk Mitigation
+
+### Concern: "A2A is newer/less proven"
+**Mitigation**: 
+- Backed by Google and Linux Foundation
+- 100+ partners already committed
+- MCP compatibility ensures fallback option
+
+### Concern: "Existing MCP integrations"
+**Mitigation**:
+- MCP adapter provides full compatibility
+- No breaking changes for current users
+- Gradual migration path
+
+### Concern: "Implementation complexity"
+**Mitigation**:
+- A2A actually simplifies implementation
+- No need to build task management
+- Reference implementations available
+
+## Conclusion
+
+A2A's Task model is not just compatible with advertising workflows—it's designed for them. By building AdCP on A2A:
+
+1. **Immediate Benefits**:
+   - Native HITL support
+   - Real-time status updates
+   - Context-aware workflows
+   - Simplified implementation
+
+2. **Future Benefits**:
+   - Access to A2A ecosystem
+   - Multi-agent collaboration
+   - Advanced features (UI embedding, etc.)
+
+3. **No Downside**:
+   - MCP compatibility maintained
+   - Better architecture overall
+   - Future-proof design
+
+## Recommendation
+
+**Build AdCP agents on A2A protocol with MCP as a compatibility layer.** This positions AdCP at the forefront of agent interoperability while providing a superior developer and user experience.
+
+## Next Steps
+
+1. Engage with A2A community
+2. Build proof-of-concept A2A agent
+3. Update AdCP specification
+4. Create migration guide for existing implementations
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)


From 8b5b5a5ec73659dca0b7b1da9373453952a518d8 Mon Sep 17 00:00:00 2001
From: Brian O'Kelley <bokelley@scope3.com>
Date: Sun, 3 Aug 2025 08:01:00 +0100
Subject: [PATCH 4/7] docs: add architecture README summarizing A2A integration
 analysis
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Add index of all A2A integration documents
- Highlight key insight about task-based workflows
- Provide clear navigation for reviewers

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
---
 docs/architecture/README.md | 63 +++++++++++++++++++++++++++++++++++++
 1 file changed, 63 insertions(+)
 create mode 100644 docs/architecture/README.md

diff --git a/docs/architecture/README.md b/docs/architecture/README.md
new file mode 100644
index 0000000..2a43ab7
--- /dev/null
+++ b/docs/architecture/README.md
@@ -0,0 +1,63 @@
+# AdCP + A2A Integration Architecture
+
+This directory contains the architectural proposal and analysis for integrating Google's Agent2Agent (A2A) protocol with AdCP.
+
+## Documents
+
+### 1. [A2A Integration Proposal](./a2a-integration-proposal.md)
+Initial proposal exploring how AdCP could support both MCP and A2A protocols. Includes:
+- Background on both protocols
+- Dual-protocol agent architecture
+- Use cases and benefits
+- Implementation approach
+
+### 2. [A2A Integration Flow Examples](./a2a-integration-flow.md)
+Visual flow diagrams showing:
+- Cross-platform campaign coordination
+- MCP to A2A bridge scenarios
+- Human-in-the-loop approval flows
+- Protocol interaction patterns
+
+### 3. [A2A-First Architecture](./a2a-first-architecture.md) ⭐ **Key Document**
+Revised architecture based on the insight that A2A's Task model is fundamentally better for AdCP:
+- Why Tasks are perfect for advertising workflows
+- Native HITL support comparison
+- Context management for multi-step workflows
+- Real-world workflow examples
+
+### 4. [A2A vs MCP Comparison](./a2a-mcp-comparison.md)
+Detailed technical comparison showing why A2A is superior for AdCP use cases:
+- Feature comparison table
+- Code examples for common workflows
+- Strengths and weaknesses of each protocol
+
+### 5. [Recommendation](./a2a-recommendation.md)
+Executive summary recommending A2A as the primary protocol for AdCP with:
+- Key reasons for choosing A2A
+- Proposed architecture
+- Implementation path
+- Risk mitigation
+
+## Example Code
+
+See the [`examples/a2a-integration/`](../../examples/a2a-integration/) directory for:
+- Dual-protocol agent implementation
+- HITL comparison (MCP vs A2A)
+- Creative workflow with A2A context
+
+## Key Insight
+
+Advertising workflows are inherently **task-based** with:
+- Multi-step processes
+- Human approvals
+- Long-running operations
+- Context preservation needs
+
+A2A's Task abstraction provides these capabilities natively, while MCP would require building custom infrastructure. Therefore, we recommend building AdCP on A2A with MCP as a compatibility layer.
+
+## Next Steps
+
+1. Review with AdCP working group
+2. Engage with A2A community
+3. Build proof-of-concept
+4. Update specifications
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)


From 452a0b1e56661611448b68a0eb71f0042fdcf81d Mon Sep 17 00:00:00 2001
From: Brian O'Kelley <bokelley@scope3.com>
Date: Sun, 3 Aug 2025 15:46:35 +0100
Subject: [PATCH 5/7] feat: propose task-first architecture as final
 recommendation
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Add task-first architecture document showing protocol-agnostic approach
- Create simple example showing how developers just implement tasks
- Update README to position task-first as the recommended approach

Key insight: Instead of choosing between MCP and A2A, we use Tasks as the
core abstraction with protocol adapters. This gives implementers a clean
interface focused on business logic while supporting any protocol.

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
---
 docs/architecture/README.md                   |  73 ++-
 docs/architecture/task-first-architecture.md  | 421 ++++++++++++++++++
 .../task-first/simple-task-implementation.js  | 250 +++++++++++
 3 files changed, 726 insertions(+), 18 deletions(-)
 create mode 100644 docs/architecture/task-first-architecture.md
 create mode 100644 examples/task-first/simple-task-implementation.js

diff --git a/docs/architecture/README.md b/docs/architecture/README.md
index 2a43ab7..25415e3 100644
--- a/docs/architecture/README.md
+++ b/docs/architecture/README.md
@@ -1,8 +1,25 @@
-# AdCP + A2A Integration Architecture
+# AdCP Architecture: Task-First with Protocol Adapters
 
-This directory contains the architectural proposal and analysis for integrating Google's Agent2Agent (A2A) protocol with AdCP.
+This directory contains the architectural evolution and final recommendation for AdCP's core architecture.
 
-## Documents
+## Final Recommendation: Task-First Architecture ⭐
+
+### [Task-First Architecture](./task-first-architecture.md) ⭐ **RECOMMENDED APPROACH**
+The recommended architecture that uses Tasks as the core abstraction with protocol adapters:
+- Tasks as the fundamental building block
+- Protocol adapters (MCP, A2A, REST, etc.) as thin translation layers
+- Clean separation between business logic and protocol concerns
+- Future-proof design supporting any protocol
+
+**Key Benefits:**
+- Implementers only need to understand Tasks, not protocols
+- Automatic support for all protocols (current and future)
+- Consistent behavior across all interfaces
+- Simplified testing and development
+
+## Evolution of Thinking
+
+The documents below show how we arrived at the task-first architecture:
 
 ### 1. [A2A Integration Proposal](./a2a-integration-proposal.md)
 Initial proposal exploring how AdCP could support both MCP and A2A protocols. Includes:
@@ -18,8 +35,8 @@ Visual flow diagrams showing:
 - Human-in-the-loop approval flows
 - Protocol interaction patterns
 
-### 3. [A2A-First Architecture](./a2a-first-architecture.md) ⭐ **Key Document**
-Revised architecture based on the insight that A2A's Task model is fundamentally better for AdCP:
+### 3. [A2A-First Architecture](./a2a-first-architecture.md)
+Architecture based on the insight that A2A's Task model is fundamentally better for AdCP:
 - Why Tasks are perfect for advertising workflows
 - Native HITL support comparison
 - Context management for multi-step workflows
@@ -31,7 +48,7 @@ Detailed technical comparison showing why A2A is superior for AdCP use cases:
 - Code examples for common workflows
 - Strengths and weaknesses of each protocol
 
-### 5. [Recommendation](./a2a-recommendation.md)
+### 5. [A2A Recommendation](./a2a-recommendation.md)
 Executive summary recommending A2A as the primary protocol for AdCP with:
 - Key reasons for choosing A2A
 - Proposed architecture
@@ -40,24 +57,44 @@ Executive summary recommending A2A as the primary protocol for AdCP with:
 
 ## Example Code
 
-See the [`examples/a2a-integration/`](../../examples/a2a-integration/) directory for:
+See the example directories for implementation details:
+
+**[`examples/task-first/`](../../examples/task-first/)** - Task-first implementation
+- Simple task implementation showing how developers only need to focus on business logic
+
+**[`examples/a2a-integration/`](../../examples/a2a-integration/)** - Protocol comparisons
 - Dual-protocol agent implementation
 - HITL comparison (MCP vs A2A)
 - Creative workflow with A2A context
 
-## Key Insight
+## Key Evolution of Insights
+
+1. **Initial Insight**: A2A's Task model is superior to MCP's request/response for advertising workflows
+2. **Deeper Insight**: Tasks are the right abstraction regardless of protocol
+3. **Final Architecture**: Task-first design with protocol adapters provides:
+   - Clean separation of concerns
+   - Protocol independence for implementers
+   - Future-proof architecture
+   - Consistent behavior across all interfaces
+
+## Why Task-First?
 
-Advertising workflows are inherently **task-based** with:
-- Multi-step processes
-- Human approvals
-- Long-running operations
-- Context preservation needs
+Advertising workflows are inherently **task-based**:
+- Multi-step processes (inventory search → budget allocation → campaign creation)
+- Human approvals (compliance, creative review, budget approval)
+- Long-running operations (optimization, reporting)
+- Context preservation (creative iterations, campaign adjustments)
 
-A2A's Task abstraction provides these capabilities natively, while MCP would require building custom infrastructure. Therefore, we recommend building AdCP on A2A with MCP as a compatibility layer.
+By making Tasks the core abstraction, we:
+- Let implementers focus on business logic only
+- Handle protocol translation in adapters
+- Support any current or future protocol
+- Provide consistent features across all interfaces
 
 ## Next Steps
 
-1. Review with AdCP working group
-2. Engage with A2A community
-3. Build proof-of-concept
-4. Update specifications
\ No newline at end of file
+1. Define core Task interface specification
+2. Build reference Task implementations
+3. Create protocol adapters (MCP, A2A, REST)
+4. Update AdCP specification to be task-first
+5. Provide migration guide for existing implementations
\ No newline at end of file
diff --git a/docs/architecture/task-first-architecture.md b/docs/architecture/task-first-architecture.md
new file mode 100644
index 0000000..642df21
--- /dev/null
+++ b/docs/architecture/task-first-architecture.md
@@ -0,0 +1,421 @@
+# Task-First Architecture for AdCP
+
+## Core Insight
+
+Instead of building on A2A or MCP, we build on a **Task abstraction** with protocol adapters. This separates business logic from protocol concerns and provides maximum flexibility.
+
+## Architecture Overview
+
+```
+┌─────────────────────────────────────────────────┐
+│              Protocol Layer                      │
+├─────────────────────────────────────────────────┤
+│  ┌─────────────┐         ┌─────────────┐       │
+│  │ MCP Adapter │         │ A2A Adapter │       │
+│  └──────┬──────┘         └──────┬──────┘       │
+│         │                        │               │
+│         └────────┬───────────────┘               │
+│                  ▼                               │
+├─────────────────────────────────────────────────┤
+│           Task Engine (Core)                     │
+├─────────────────────────────────────────────────┤
+│  ┌────────────────────────────────────────┐    │
+│  │  Task Definition & Lifecycle            │    │
+│  │  - States: pending|working|paused|done │    │
+│  │  - Context management                   │    │
+│  │  - Status updates                       │    │
+│  │  - Artifact handling                    │    │
+│  └────────────────────────────────────────┘    │
+│                  ▼                               │
+├─────────────────────────────────────────────────┤
+│         Task Implementations                     │
+├─────────────────────────────────────────────────┤
+│  ┌──────────────┐  ┌───────────────┐          │
+│  │ MediaBuyTask │  │ CreativeTask  │          │
+│  └──────────────┘  └───────────────┘          │
+│  ┌──────────────┐  ┌───────────────┐          │
+│  │ SignalsTask  │  │ ReportingTask │          │
+│  └──────────────┘  └───────────────┘          │
+└─────────────────────────────────────────────────┘
+```
+
+## Core Task Model
+
+```typescript
+interface Task {
+  // Identity
+  id: string;
+  type: string;
+  contextId: string;
+  
+  // State
+  state: 'pending' | 'working' | 'paused' | 'pending_approval' | 
+         'pending_input' | 'completed' | 'failed';
+  
+  // Progress
+  progress?: {
+    message: string;
+    percentage?: number;
+    metadata?: Record<string, any>;
+  };
+  
+  // Results
+  artifacts?: Artifact[];
+  error?: TaskError;
+  
+  // Metadata
+  createdAt: Date;
+  updatedAt: Date;
+  metadata: Record<string, any>;
+}
+
+interface TaskHandler {
+  // Implement this to create a task
+  async execute(input: TaskInput, context: TaskContext): Promise<void>;
+  
+  // Optional: Handle task-specific events
+  async onPause?(context: TaskContext): Promise<void>;
+  async onResume?(context: TaskContext): Promise<void>;
+  async onCancel?(context: TaskContext): Promise<void>;
+}
+
+interface TaskContext {
+  // Identity
+  task: Task;
+  
+  // State management
+  async updateStatus(message: string, metadata?: any): Promise<void>;
+  async setState(state: Task['state']): Promise<void>;
+  async setProgress(progress: number, message?: string): Promise<void>;
+  
+  // Human-in-the-loop
+  async requestApproval(details: ApprovalRequest): Promise<void>;
+  async waitForInput(prompt: InputRequest): Promise<any>;
+  
+  // Results
+  async addArtifact(artifact: Artifact): Promise<void>;
+  async complete(artifacts?: Artifact[]): Promise<void>;
+  async fail(error: TaskError): Promise<void>;
+  
+  // Context
+  async getContext<T>(key: string): Promise<T>;
+  async setContext(key: string, value: any): Promise<void>;
+}
+```
+
+## Example: Media Buy Task Implementation
+
+```typescript
+class MediaBuyTask implements TaskHandler {
+  async execute(input: TaskInput, ctx: TaskContext) {
+    // Parse input (protocol-agnostic)
+    const params = this.parseParams(input);
+    
+    // Update status - protocol adapters handle delivery
+    await ctx.updateStatus('Validating campaign parameters...');
+    
+    // Business logic
+    const validation = await this.validateCampaign(params);
+    
+    if (validation.errors.length > 0) {
+      return ctx.fail({
+        code: 'VALIDATION_ERROR',
+        message: 'Campaign validation failed',
+        details: validation.errors
+      });
+    }
+    
+    // Check inventory
+    await ctx.updateStatus('Checking inventory availability...');
+    const inventory = await this.checkInventory(params);
+    
+    // Needs approval?
+    if (params.budget > 100000 || validation.requiresApproval) {
+      await ctx.setState('pending_approval');
+      await ctx.requestApproval({
+        type: 'budget_approval',
+        reason: 'Campaign exceeds automatic approval threshold',
+        details: {
+          budget: params.budget,
+          inventory: inventory.summary
+        }
+      });
+      
+      // Task engine handles waiting for approval
+      // When resumed, we continue here
+    }
+    
+    // Create campaign
+    await ctx.updateStatus('Creating campaign in ad server...');
+    await ctx.setProgress(75, 'Submitting to ad server');
+    
+    const campaign = await this.createInAdServer(params, inventory);
+    
+    // Add results
+    await ctx.addArtifact({
+      name: 'media_buy_confirmation',
+      type: 'application/json',
+      data: campaign
+    });
+    
+    await ctx.addArtifact({
+      name: 'insertion_order',
+      type: 'application/pdf',
+      uri: campaign.ioUrl
+    });
+    
+    // Complete
+    await ctx.complete();
+  }
+}
+```
+
+## Protocol Adapters
+
+### MCP Adapter
+
+```typescript
+class MCPAdapter {
+  constructor(private taskEngine: TaskEngine) {}
+  
+  // MCP tool call → Task
+  async handleToolCall(tool: string, params: any): Promise<any> {
+    // Map tool to task type
+    const taskType = this.mapToolToTask(tool);
+    
+    // Create task
+    const task = await this.taskEngine.createTask({
+      type: taskType,
+      input: params,
+      options: {
+        // MCP is synchronous by default
+        waitForCompletion: true,
+        timeout: 30000
+      }
+    });
+    
+    // For async operations, return task info
+    if (this.isAsyncTool(tool)) {
+      return {
+        task_id: task.id,
+        status: task.state,
+        status_url: `/tasks/${task.id}`
+      };
+    }
+    
+    // For sync operations, wait and return result
+    const result = await task.waitForCompletion();
+    
+    if (result.state === 'completed') {
+      // Extract result from artifacts
+      return this.extractResult(result.artifacts);
+    } else {
+      throw new Error(result.error?.message || 'Task failed');
+    }
+  }
+  
+  // Polling endpoint for async tasks
+  async getTaskStatus(taskId: string): Promise<any> {
+    const task = await this.taskEngine.getTask(taskId);
+    return {
+      status: task.state,
+      progress: task.progress,
+      result: task.state === 'completed' ? 
+        this.extractResult(task.artifacts) : null
+    };
+  }
+}
+```
+
+### A2A Adapter
+
+```typescript
+class A2AAdapter {
+  constructor(private taskEngine: TaskEngine) {}
+  
+  // A2A message → Task
+  async handleMessage(message: A2AMessage): Promise<A2AResponse> {
+    const { contextId, referenceTaskIds } = message;
+    
+    // Determine task type from message
+    const taskType = await this.inferTaskType(message);
+    
+    // Create or continue task
+    const task = await this.taskEngine.createTask({
+      type: taskType,
+      contextId: contextId,
+      input: {
+        message: message.parts,
+        referenceTaskIds
+      }
+    });
+    
+    // A2A expects immediate response with task info
+    return {
+      taskId: task.id,
+      contextId: task.contextId,
+      status: { state: this.mapTaskStateToA2A(task.state) }
+    };
+  }
+  
+  // Stream task updates via SSE
+  async streamTaskUpdates(taskId: string, stream: EventStream) {
+    const task = await this.taskEngine.getTask(taskId);
+    
+    // Subscribe to task events
+    task.on('statusUpdate', (update) => {
+      stream.send({
+        type: 'status',
+        data: {
+          message: update.message,
+          metadata: update.metadata
+        }
+      });
+    });
+    
+    task.on('stateChange', (state) => {
+      stream.send({
+        type: 'state',
+        data: { state: this.mapTaskStateToA2A(state) }
+      });
+    });
+    
+    task.on('complete', (artifacts) => {
+      stream.send({
+        type: 'complete',
+        data: {
+          artifacts: this.mapArtifactsToA2A(artifacts)
+        }
+      });
+      stream.close();
+    });
+  }
+}
+```
+
+## Benefits of Task-First Architecture
+
+### 1. **Protocol Independence**
+Implementers only need to understand the Task interface, not protocol specifics:
+```typescript
+// Developer implements this
+class MyTask implements TaskHandler {
+  async execute(input, ctx) {
+    // Just focus on business logic
+    await ctx.updateStatus('Doing something...');
+    // ...
+  }
+}
+
+// Framework handles protocol translation automatically
+```
+
+### 2. **Future-Proof**
+Adding a new protocol is just adding a new adapter:
+```typescript
+class GraphQLAdapter {
+  // Maps GraphQL subscriptions to task events
+}
+
+class WebSocketAdapter {
+  // Real-time task updates over WebSocket
+}
+```
+
+### 3. **Consistent Behavior**
+All protocols get the same features:
+- Status updates
+- Progress tracking
+- HITL support
+- Context management
+- Artifact handling
+
+### 4. **Easier Testing**
+Test tasks directly without protocol overhead:
+```typescript
+const task = new MediaBuyTask();
+const ctx = new TestTaskContext();
+await task.execute(input, ctx);
+expect(ctx.artifacts).toHaveLength(2);
+```
+
+### 5. **Clean Separation of Concerns**
+- **Task Layer**: Business logic only
+- **Protocol Layer**: Translation only
+- **Engine Layer**: State management, persistence, events
+
+## Implementation Path
+
+### Phase 1: Define Core Task Model
+- Task interface and lifecycle
+- Context management
+- Event system
+- Artifact handling
+
+### Phase 2: Build Task Implementations
+- MediaBuyTask
+- CreativeTask
+- SignalsTask
+- ReportingTask
+
+### Phase 3: Add Protocol Adapters
+- MCP adapter (for compatibility)
+- A2A adapter (for rich features)
+- REST adapter (for simple integrations)
+
+### Phase 4: Advanced Features
+- Task composition (workflows)
+- Task dependencies
+- Parallel execution
+- Retry policies
+
+## Example: Complete Flow
+
+```typescript
+// 1. A2A Request comes in
+POST /a2a
+{
+  "method": "message/send",
+  "params": {
+    "message": {
+      "parts": [{"text": "Create $50K CTV campaign"}]
+    }
+  }
+}
+
+// 2. A2A Adapter creates task
+const task = taskEngine.createTask({
+  type: 'media_buy',
+  input: { brief: "Create $50K CTV campaign" }
+});
+
+// 3. MediaBuyTask executes
+// - Updates status
+// - Requests approval if needed
+// - Creates campaign
+// - Returns artifacts
+
+// 4. A2A Adapter streams updates
+SSE: {"message": "Checking inventory..."}
+SSE: {"message": "Pending approval..."}
+SSE: {"state": "completed", "artifacts": [...]}
+
+// Same task works with MCP!
+POST /mcp
+{
+  "method": "create_media_buy",
+  "params": { "budget": 50000, "type": "ctv" }
+}
+// Returns when complete or task_id if async
+```
+
+## Conclusion
+
+A task-first architecture provides:
+- **Clean abstraction** for implementers
+- **Protocol flexibility** for clients  
+- **Future-proofing** for new standards
+- **Consistent features** across protocols
+- **Simpler implementation** overall
+
+Instead of choosing between MCP and A2A, we get both—plus the ability to add more protocols as needed—all while keeping the implementation clean and focused on business logic.
\ No newline at end of file
diff --git a/examples/task-first/simple-task-implementation.js b/examples/task-first/simple-task-implementation.js
new file mode 100644
index 0000000..751d9dd
--- /dev/null
+++ b/examples/task-first/simple-task-implementation.js
@@ -0,0 +1,250 @@
+/**
+ * Example: Implementing an AdCP Task
+ * 
+ * This shows how simple it is for developers to implement AdCP functionality
+ * when using the task-first architecture. No protocol knowledge required!
+ */
+
+// ==============================================
+// What developers implement (just business logic)
+// ==============================================
+
+class InventoryDiscoveryTask {
+  async execute(input, ctx) {
+    // Parse the input
+    const { brief, filters = {} } = input;
+    
+    // Let users know what's happening
+    await ctx.updateStatus('Analyzing your requirements...');
+    
+    // Extract intent from brief if provided
+    if (brief) {
+      const intent = await this.analyzeBrief(brief);
+      await ctx.updateStatus(`Looking for ${intent.type} inventory...`);
+      
+      // Merge with explicit filters
+      filters.formats = filters.formats || intent.suggestedFormats;
+      filters.targeting = { ...intent.targeting, ...filters.targeting };
+    }
+    
+    // Search inventory
+    await ctx.setProgress(25, 'Searching across platforms...');
+    const results = await this.searchInventory(filters);
+    
+    await ctx.setProgress(50, `Found ${results.length} products`);
+    
+    // Score and rank results
+    await ctx.updateStatus('Ranking by relevance and performance...');
+    const scored = await this.scoreResults(results, brief);
+    
+    await ctx.setProgress(75, 'Preparing recommendations...');
+    
+    // Prepare response
+    const recommendations = scored.slice(0, 10).map(product => ({
+      ...product,
+      recommendation: this.generateRecommendation(product, brief)
+    }));
+    
+    // Add artifacts
+    await ctx.addArtifact({
+      name: 'inventory_recommendations',
+      type: 'application/json',
+      data: {
+        query: { brief, filters },
+        total_found: results.length,
+        products: recommendations
+      }
+    });
+    
+    // Add human-readable summary
+    await ctx.addArtifact({
+      name: 'summary',
+      type: 'text/plain',
+      data: this.generateSummary(recommendations, brief)
+    });
+    
+    // Complete the task
+    await ctx.complete();
+  }
+  
+  // Business logic methods
+  async analyzeBrief(brief) {
+    // NLP or LLM analysis
+    return {
+      type: 'video',
+      suggestedFormats: ['video_standard_30s'],
+      targeting: { content_categories: ['sports'] }
+    };
+  }
+  
+  async searchInventory(filters) {
+    // Query inventory systems
+    return [/* products */];
+  }
+  
+  async scoreResults(results, brief) {
+    // Rank by relevance
+    return results.sort((a, b) => b.score - a.score);
+  }
+  
+  generateRecommendation(product, brief) {
+    return `Recommended because: ${product.match_reason}`;
+  }
+  
+  generateSummary(products, brief) {
+    return `Found ${products.length} products matching "${brief}":\n` +
+           products.map(p => `- ${p.name}: $${p.cpm} CPM`).join('\n');
+  }
+}
+
+// ==============================================
+// Another example: Creative Review Task
+// ==============================================
+
+class CreativeReviewTask {
+  async execute(input, ctx) {
+    const { creativeUrl, mediaBuyId } = input;
+    
+    // Download and analyze
+    await ctx.updateStatus('Downloading creative...');
+    const creative = await this.downloadCreative(creativeUrl);
+    
+    await ctx.updateStatus('Running automated checks...');
+    await ctx.setProgress(20);
+    
+    // Technical validation
+    const technical = await this.validateTechnical(creative);
+    await ctx.setProgress(40);
+    
+    // Policy check
+    const policy = await this.checkPolicy(creative);
+    await ctx.setProgress(60);
+    
+    // Brand safety
+    const brandSafety = await this.checkBrandSafety(creative);
+    await ctx.setProgress(80);
+    
+    // Compile results
+    const review = {
+      technical,
+      policy,
+      brandSafety,
+      overallStatus: this.determineStatus(technical, policy, brandSafety)
+    };
+    
+    // Add review artifact
+    await ctx.addArtifact({
+      name: 'creative_review',
+      type: 'application/json',
+      data: review
+    });
+    
+    // Need human review?
+    if (review.overallStatus === 'needs_human_review') {
+      await ctx.setState('pending_approval');
+      await ctx.requestApproval({
+        type: 'creative_review',
+        reason: review.flaggedIssues[0],
+        details: review
+      });
+      
+      // When resumed after approval, continue...
+    }
+    
+    // Auto-approved or human-approved
+    if (review.overallStatus === 'approved' || ctx.task.state === 'working') {
+      await ctx.updateStatus('Generating format variations...');
+      
+      const variations = await this.generateVariations(creative);
+      
+      await ctx.addArtifact({
+        name: 'creative_package',
+        type: 'application/json',
+        data: {
+          original: creative.id,
+          variations: variations,
+          assignedTo: mediaBuyId
+        }
+      });
+    }
+    
+    await ctx.complete();
+  }
+  
+  async downloadCreative(url) {
+    // Download logic
+  }
+  
+  async validateTechnical(creative) {
+    // Check format, duration, resolution, etc.
+    return { status: 'pass', details: {} };
+  }
+  
+  async checkPolicy(creative) {
+    // Check against ad policies
+    return { status: 'pass', details: {} };
+  }
+  
+  async checkBrandSafety(creative) {
+    // Brand safety checks
+    return { status: 'warning', issues: ['music_similarity'] };
+  }
+  
+  determineStatus(technical, policy, brandSafety) {
+    if (technical.status === 'fail' || policy.status === 'fail') {
+      return 'rejected';
+    }
+    if (brandSafety.status === 'warning') {
+      return 'needs_human_review';
+    }
+    return 'approved';
+  }
+  
+  async generateVariations(creative) {
+    // Create different sizes/formats
+    return [
+      { format: '16:9', url: '...' },
+      { format: '9:16', url: '...' },
+      { format: '1:1', url: '...' }
+    ];
+  }
+}
+
+// ==============================================
+// Task Registry (Framework provides this)
+// ==============================================
+
+const taskRegistry = {
+  'inventory_discovery': InventoryDiscoveryTask,
+  'creative_review': CreativeReviewTask,
+  'media_buy': MediaBuyTask,
+  'performance_report': PerformanceReportTask
+};
+
+// ==============================================
+// That's it! Developers just implement tasks.
+// The framework handles:
+// - Protocol translation (MCP/A2A/REST/etc)
+// - State management
+// - Status delivery
+// - Error handling
+// - Context persistence
+// - Event streaming
+// ==============================================
+
+/**
+ * Benefits for developers:
+ * 
+ * 1. No protocol knowledge needed
+ * 2. Clear, simple interface (execute method)
+ * 3. Built-in status/progress/HITL support
+ * 4. Focus on business logic only
+ * 5. Testable without protocol overhead
+ * 
+ * The same task automatically works with:
+ * - MCP clients (sync or async)
+ * - A2A agents (with streaming)
+ * - REST APIs
+ * - GraphQL
+ * - Future protocols
+ */
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)


From dba6834e8de51c34c0a3bab255a19d4cf0573f9c Mon Sep 17 00:00:00 2001
From: Brian O'Kelley <bokelley@scope3.com>
Date: Sun, 3 Aug 2025 15:47:11 +0100
Subject: [PATCH 6/7] docs: add executive summary for task-first architecture
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Summarize the journey from protocol integration to task-first design
- Highlight key benefits and implementation simplicity
- Provide clear next steps for adoption

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
---
 docs/architecture/executive-summary.md | 133 +++++++++++++++++++++++++
 1 file changed, 133 insertions(+)
 create mode 100644 docs/architecture/executive-summary.md

diff --git a/docs/architecture/executive-summary.md b/docs/architecture/executive-summary.md
new file mode 100644
index 0000000..37e2e6f
--- /dev/null
+++ b/docs/architecture/executive-summary.md
@@ -0,0 +1,133 @@
+# Executive Summary: Task-First Architecture for AdCP
+
+## The Journey
+
+We started by exploring how AdCP could support Google's Agent2Agent (A2A) protocol alongside MCP. Through our analysis, we discovered something more fundamental: **the right abstraction for AdCP is Tasks, not protocols**.
+
+## Final Recommendation: Task-First Architecture
+
+Build AdCP with a **Task Engine** at its core, with protocol adapters for MCP, A2A, and future protocols.
+
+```
+         ┌──────────┐ ┌──────────┐ ┌──────────┐
+         │   MCP    │ │   A2A    │ │   REST   │
+         │ Adapter  │ │ Adapter  │ │ Adapter  │
+         └────┬─────┘ └────┬─────┘ └────┬─────┘
+              └────────┬────┴────────────┘
+                       ▼
+              ┌─────────────────┐
+              │   Task Engine   │
+              └────────┬────────┘
+                       ▼
+         ┌─────────────┴──────────────┐
+         │    Task Implementations    │
+         │ (MediaBuy, Creative, etc.) │
+         └────────────────────────────┘
+```
+
+## Why Task-First?
+
+### 1. Perfect Match for Advertising
+Advertising operations are naturally task-based:
+- **Media Buying**: Multi-step workflow with approvals
+- **Creative Review**: Iterative process with human feedback
+- **Campaign Optimization**: Long-running analysis and adjustments
+
+### 2. Protocol Independence
+Developers implement a simple interface:
+```javascript
+class MyTask {
+  async execute(input, ctx) {
+    await ctx.updateStatus('Processing...');
+    // Business logic here
+    await ctx.complete(results);
+  }
+}
+```
+
+The framework handles all protocol translation automatically.
+
+### 3. Built-in Features
+Every task gets these for free across all protocols:
+- Status updates and progress tracking
+- Human-in-the-loop support
+- Context management
+- Error handling and retry
+- Artifact management
+
+### 4. Future-Proof
+Adding support for a new protocol is just writing an adapter. Task implementations remain unchanged.
+
+## Benefits Over Protocol-First Approaches
+
+| Aspect | Protocol-First | Task-First |
+|--------|---------------|------------|
+| **Developer Experience** | Must understand protocol specifics | Just implement business logic |
+| **Code Reuse** | Different implementations per protocol | Write once, works everywhere |
+| **Feature Parity** | Features vary by protocol | Consistent features across all protocols |
+| **Testing** | Test with protocol overhead | Test tasks directly |
+| **Future Protocols** | Rewrite implementations | Add adapter only |
+
+## Implementation Simplicity
+
+Here's a complete task implementation:
+
+```javascript
+class InventoryDiscoveryTask {
+  async execute(input, ctx) {
+    await ctx.updateStatus('Searching inventory...');
+    
+    const results = await this.searchInventory(input.filters);
+    
+    await ctx.addArtifact({
+      name: 'inventory_results',
+      type: 'application/json',
+      data: results
+    });
+    
+    await ctx.complete();
+  }
+}
+```
+
+This automatically works with:
+- MCP (synchronous or async with polling)
+- A2A (with streaming updates and context)
+- REST APIs
+- Future protocols
+
+## Evolution of Our Thinking
+
+1. **Started**: How can AdCP support both MCP and A2A?
+2. **Discovered**: A2A's Task model is superior for advertising workflows
+3. **Realized**: Tasks are the right abstraction regardless of protocol
+4. **Conclusion**: Task-first architecture with protocol adapters
+
+## Next Steps
+
+1. **Immediate**
+   - Define Task interface specification
+   - Create reference implementations
+   - Build MCP and A2A adapters
+
+2. **Short Term**
+   - Update AdCP specification
+   - Provide migration guide
+   - Release reference implementation
+
+3. **Long Term**
+   - Add more protocol adapters
+   - Build task composition features
+   - Create visual workflow builder
+
+## Conclusion
+
+The task-first architecture transforms AdCP from a protocol specification into a **workflow platform** that happens to support multiple protocols. This positions AdCP for long-term success in the evolving landscape of AI-powered advertising.
+
+By focusing on Tasks rather than protocols, we:
+- Simplify implementation for developers
+- Provide consistent behavior for users
+- Future-proof against protocol changes
+- Enable innovation at the workflow level
+
+**Recommendation**: Adopt the task-first architecture as the foundation for AdCP v2.
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)


From 205a9034bf5dcc9e0b376f9c50d23c833bfa193e Mon Sep 17 00:00:00 2001
From: Brian O'Kelley <bokelley@scope3.com>
Date: Sun, 3 Aug 2025 18:19:32 +0100
Subject: [PATCH 7/7] refactor: update AdCP docs to be task-based and
 multi-protocol
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Update Signals and Media Buy protocols to describe capabilities as tasks
- Add Protocols section explaining MCP and A2A support options
- Update Getting Started to mention multi-protocol flexibility
- Remove overwhelming architecture analysis documents
- Consolidate activate_signal to include status monitoring

Key changes:
- Tasks instead of tools throughout documentation
- Clear protocol options without implementation complexity
- Focus on what users need to know, not architectural theory

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
---
 docs/architecture/README.md                   | 100 -----
 docs/architecture/a2a-first-architecture.md   | 336 --------------
 docs/architecture/a2a-integration-flow.md     | 175 --------
 docs/architecture/a2a-integration-proposal.md | 324 --------------
 docs/architecture/a2a-mcp-comparison.md       | 162 -------
 docs/architecture/a2a-recommendation.md       | 176 --------
 docs/architecture/executive-summary.md        | 133 ------
 docs/architecture/task-first-architecture.md  | 421 ------------------
 docs/intro.md                                 |  21 +-
 docs/media-buy/api-reference.md               |  18 +-
 docs/media-buy/index.md                       |   2 +-
 docs/protocols/a2a.md                         | 251 +++++++++++
 docs/protocols/mcp.md                         | 173 +++++++
 docs/protocols/overview.md                    |  91 ++++
 docs/signals/overview.md                      |  11 +-
 docs/signals/specification.md                 |  58 +--
 .../a2a-integration/creative-workflow-a2a.md  | 325 --------------
 .../a2a-integration/dual-protocol-agent.js    | 354 ---------------
 examples/a2a-integration/hitl-comparison.js   | 378 ----------------
 .../task-first/simple-task-implementation.js  | 250 -----------
 sidebars.ts                                   |   9 +
 21 files changed, 590 insertions(+), 3178 deletions(-)
 delete mode 100644 docs/architecture/README.md
 delete mode 100644 docs/architecture/a2a-first-architecture.md
 delete mode 100644 docs/architecture/a2a-integration-flow.md
 delete mode 100644 docs/architecture/a2a-integration-proposal.md
 delete mode 100644 docs/architecture/a2a-mcp-comparison.md
 delete mode 100644 docs/architecture/a2a-recommendation.md
 delete mode 100644 docs/architecture/executive-summary.md
 delete mode 100644 docs/architecture/task-first-architecture.md
 create mode 100644 docs/protocols/a2a.md
 create mode 100644 docs/protocols/mcp.md
 create mode 100644 docs/protocols/overview.md
 delete mode 100644 examples/a2a-integration/creative-workflow-a2a.md
 delete mode 100644 examples/a2a-integration/dual-protocol-agent.js
 delete mode 100644 examples/a2a-integration/hitl-comparison.js
 delete mode 100644 examples/task-first/simple-task-implementation.js

diff --git a/docs/architecture/README.md b/docs/architecture/README.md
deleted file mode 100644
index 25415e3..0000000
--- a/docs/architecture/README.md
+++ /dev/null
@@ -1,100 +0,0 @@
-# AdCP Architecture: Task-First with Protocol Adapters
-
-This directory contains the architectural evolution and final recommendation for AdCP's core architecture.
-
-## Final Recommendation: Task-First Architecture ⭐
-
-### [Task-First Architecture](./task-first-architecture.md) ⭐ **RECOMMENDED APPROACH**
-The recommended architecture that uses Tasks as the core abstraction with protocol adapters:
-- Tasks as the fundamental building block
-- Protocol adapters (MCP, A2A, REST, etc.) as thin translation layers
-- Clean separation between business logic and protocol concerns
-- Future-proof design supporting any protocol
-
-**Key Benefits:**
-- Implementers only need to understand Tasks, not protocols
-- Automatic support for all protocols (current and future)
-- Consistent behavior across all interfaces
-- Simplified testing and development
-
-## Evolution of Thinking
-
-The documents below show how we arrived at the task-first architecture:
-
-### 1. [A2A Integration Proposal](./a2a-integration-proposal.md)
-Initial proposal exploring how AdCP could support both MCP and A2A protocols. Includes:
-- Background on both protocols
-- Dual-protocol agent architecture
-- Use cases and benefits
-- Implementation approach
-
-### 2. [A2A Integration Flow Examples](./a2a-integration-flow.md)
-Visual flow diagrams showing:
-- Cross-platform campaign coordination
-- MCP to A2A bridge scenarios
-- Human-in-the-loop approval flows
-- Protocol interaction patterns
-
-### 3. [A2A-First Architecture](./a2a-first-architecture.md)
-Architecture based on the insight that A2A's Task model is fundamentally better for AdCP:
-- Why Tasks are perfect for advertising workflows
-- Native HITL support comparison
-- Context management for multi-step workflows
-- Real-world workflow examples
-
-### 4. [A2A vs MCP Comparison](./a2a-mcp-comparison.md)
-Detailed technical comparison showing why A2A is superior for AdCP use cases:
-- Feature comparison table
-- Code examples for common workflows
-- Strengths and weaknesses of each protocol
-
-### 5. [A2A Recommendation](./a2a-recommendation.md)
-Executive summary recommending A2A as the primary protocol for AdCP with:
-- Key reasons for choosing A2A
-- Proposed architecture
-- Implementation path
-- Risk mitigation
-
-## Example Code
-
-See the example directories for implementation details:
-
-**[`examples/task-first/`](../../examples/task-first/)** - Task-first implementation
-- Simple task implementation showing how developers only need to focus on business logic
-
-**[`examples/a2a-integration/`](../../examples/a2a-integration/)** - Protocol comparisons
-- Dual-protocol agent implementation
-- HITL comparison (MCP vs A2A)
-- Creative workflow with A2A context
-
-## Key Evolution of Insights
-
-1. **Initial Insight**: A2A's Task model is superior to MCP's request/response for advertising workflows
-2. **Deeper Insight**: Tasks are the right abstraction regardless of protocol
-3. **Final Architecture**: Task-first design with protocol adapters provides:
-   - Clean separation of concerns
-   - Protocol independence for implementers
-   - Future-proof architecture
-   - Consistent behavior across all interfaces
-
-## Why Task-First?
-
-Advertising workflows are inherently **task-based**:
-- Multi-step processes (inventory search → budget allocation → campaign creation)
-- Human approvals (compliance, creative review, budget approval)
-- Long-running operations (optimization, reporting)
-- Context preservation (creative iterations, campaign adjustments)
-
-By making Tasks the core abstraction, we:
-- Let implementers focus on business logic only
-- Handle protocol translation in adapters
-- Support any current or future protocol
-- Provide consistent features across all interfaces
-
-## Next Steps
-
-1. Define core Task interface specification
-2. Build reference Task implementations
-3. Create protocol adapters (MCP, A2A, REST)
-4. Update AdCP specification to be task-first
-5. Provide migration guide for existing implementations
\ No newline at end of file
diff --git a/docs/architecture/a2a-first-architecture.md b/docs/architecture/a2a-first-architecture.md
deleted file mode 100644
index 9120043..0000000
--- a/docs/architecture/a2a-first-architecture.md
+++ /dev/null
@@ -1,336 +0,0 @@
-# A2A-First Architecture for AdCP
-
-## Key Insight: Tasks as First-Class Citizens
-
-After deeper analysis, it's clear that A2A's Task abstraction is fundamentally better suited for advertising workflows than MCP's request/response model. AdCP should be built on A2A's Task model with MCP as a compatibility layer.
-
-## Why A2A Tasks Are Perfect for AdCP
-
-### 1. Native Human-in-the-Loop Support
-
-```javascript
-// A2A Task naturally handles HITL
-{
-  "taskId": "task-media-buy-123",
-  "status": {
-    "state": "pending_approval",
-    "message": "Awaiting human approval for $1M campaign"
-  },
-  "metadata": {
-    "approvalRequired": true,
-    "approver": "compliance@agency.com"
-  }
-}
-
-// vs MCP requiring explicit HITL implementation
-{
-  "error": {
-    "code": "APPROVAL_REQUIRED",
-    "task_id": "task_123"  // Must build our own task system
-  }
-}
-```
-
-### 2. Progressive Status Updates
-
-A2A Tasks can stream status updates as work progresses:
-
-```javascript
-// Creating a media buy with real-time updates
-Task: "task-mb-456"
-├── Status: "working" - "Checking inventory availability..."
-├── Status: "working" - "Validating targeting parameters..."
-├── Status: "working" - "Calculating optimal budget allocation..."
-├── Status: "working" - "Submitting to ad server..."
-├── Status: "pending_approval" - "Awaiting publisher approval..."
-└── Status: "completed" - Media buy created: mb_789
-```
-
-### 3. Context Management for Multi-Step Workflows
-
-The `contextId` naturally handles iterative workflows like creative management:
-
-```javascript
-// Initial creative upload
-{
-  "contextId": "ctx-campaign-abc",
-  "taskId": "task-creative-upload-1",
-  "artifacts": [{
-    "name": "hero_video.mp4",
-    "artifactId": "art-video-v1"
-  }]
-}
-
-// Request variations (same context)
-{
-  "contextId": "ctx-campaign-abc",  // Same context
-  "referenceTaskIds": ["task-creative-upload-1"],
-  "message": "Create vertical version for mobile"
-}
-
-// Get new artifact in same context
-{
-  "contextId": "ctx-campaign-abc",
-  "taskId": "task-creative-adapt-2",
-  "artifacts": [{
-    "name": "hero_video_vertical.mp4",
-    "artifactId": "art-video-v2"
-  }]
-}
-```
-
-## Revised Architecture: A2A Core with MCP Adapter
-
-```
-┌─────────────────────────────────────────────┐
-│           AdCP Agent (A2A-First)            │
-├─────────────────────────────────────────────┤
-│  ┌────────────────────────────────────────┐│
-│  │          A2A Task Engine               ││
-│  │  - Task lifecycle management           ││
-│  │  - Context persistence                 ││
-│  │  - Artifact handling                   ││
-│  │  - Status streaming (SSE)              ││
-│  └────────────────────────────────────────┘│
-│                    │                        │
-│  ┌─────────────────┴──────────────────┐   │
-│  │      Core Business Logic           │   │
-│  │  - Media Buy workflows             │   │
-│  │  - Signal discovery                │   │
-│  │  - Creative management             │   │
-│  │  - HITL operations                 │   │
-│  └─────────────────┬──────────────────┘   │
-│                    │                        │
-│  ┌────────────────┴───────────────────┐   │
-│  │       MCP Compatibility Layer      │   │
-│  │  - Translates tools to tasks       │   │
-│  │  - Maintains backward compat       │   │
-│  └────────────────────────────────────┘   │
-└─────────────────────────────────────────────┘
-```
-
-## Real-World AdCP Workflows as A2A Tasks
-
-### Media Buy Creation with Natural Status Updates
-
-```javascript
-class MediaBuyTask {
-  async execute(params, task) {
-    // Update: Starting
-    await task.update({
-      status: { state: "working" },
-      message: "Analyzing campaign requirements..."
-    });
-
-    // Check inventory
-    await task.update({
-      message: "Checking inventory availability across 5 platforms..."
-    });
-    const inventory = await this.checkInventory(params.brief);
-
-    // Validate targeting
-    await task.update({
-      message: "Validating targeting parameters and compliance..."
-    });
-    const validation = await this.validateTargeting(params.targeting);
-
-    if (validation.requiresApproval) {
-      // Natural HITL state
-      await task.update({
-        status: { state: "pending_approval" },
-        message: "Campaign requires compliance approval",
-        metadata: {
-          approvalType: "compliance",
-          reason: validation.reason
-        }
-      });
-      
-      // Wait for approval (via webhook or polling)
-      await this.waitForApproval(task.id);
-    }
-
-    // Create the buy
-    await task.update({
-      message: "Creating media buy in ad server..."
-    });
-    const mediaBuy = await this.createInAdServer(params);
-
-    // Return with artifacts
-    return {
-      status: { state: "completed" },
-      artifacts: [{
-        name: "media_buy_confirmation",
-        parts: [{
-          kind: "application/json",
-          data: mediaBuy
-        }, {
-          kind: "application/pdf",
-          uri: mediaBuy.contractUrl
-        }]
-      }]
-    };
-  }
-}
-```
-
-### Creative Workflow with Context
-
-```javascript
-// Task 1: Upload initial creative
-{
-  "method": "message/send",
-  "params": {
-    "message": {
-      "parts": [{
-        "kind": "text",
-        "text": "Upload creative for pet food campaign"
-      }, {
-        "kind": "file",
-        "uri": "https://cdn.example.com/pet_food_hero.mp4"
-      }]
-    }
-  }
-}
-
-// Response: Task with context
-{
-  "taskId": "task-creative-001",
-  "contextId": "ctx-petfood-campaign",
-  "status": { "state": "completed" },
-  "artifacts": [{
-    "artifactId": "art-creative-v1",
-    "name": "pet_food_hero.mp4"
-  }]
-}
-
-// Task 2: Request adaptation (same context)
-{
-  "method": "message/send",
-  "params": {
-    "contextId": "ctx-petfood-campaign",  // Continue conversation
-    "message": {
-      "parts": [{
-        "kind": "text",
-        "text": "Create a 15-second version and add captions"
-      }]
-    }
-  }
-}
-
-// Status updates via SSE
-data: {"status": {"state": "working"}, "message": "Analyzing video content..."}
-data: {"status": {"state": "working"}, "message": "Generating 15s cut..."}
-data: {"status": {"state": "working"}, "message": "Adding captions..."}
-data: {"status": {"state": "completed"}, "artifacts": [...]}
-```
-
-## MCP Compatibility Layer
-
-For backward compatibility, we provide an MCP interface that translates to A2A tasks:
-
-```javascript
-class MCPCompatibilityLayer {
-  async handleToolCall(tool, params) {
-    // Create an A2A task
-    const task = await this.a2aEngine.createTask({
-      type: 'mcp_tool_call',
-      tool: tool,
-      params: params
-    });
-
-    // Wait for completion (blocking mode)
-    const result = await task.waitForCompletion();
-
-    // Return MCP-style response
-    if (result.status.state === 'completed') {
-      return this.extractMCPResponse(result.artifacts);
-    } else {
-      throw new Error(result.status.message);
-    }
-  }
-
-  // Special handling for async operations
-  async handleAsyncTool(tool, params) {
-    const task = await this.a2aEngine.createTask({
-      type: 'mcp_async_tool',
-      tool: tool,
-      params: params
-    });
-
-    // Return task ID for polling
-    return {
-      task_id: task.id,
-      status: 'pending',
-      poll_url: `/tasks/${task.id}/status`
-    };
-  }
-}
-```
-
-## Benefits of A2A-First Architecture
-
-### 1. Natural Workflow Representation
-- Media buys naturally progress through states
-- Creative workflows maintain context
-- HITL is a first-class citizen
-
-### 2. Better User Experience
-- Real-time progress updates
-- Clear status communication
-- Contextual error handling
-
-### 3. Simplified Implementation
-- No need to build task management on top of MCP
-- Status updates are built-in
-- Artifact handling is native
-
-### 4. Future-Proof
-- Aligns with Google's vision for agent communication
-- Supports complex multi-agent workflows
-- Ready for advanced features like UI embedding
-
-## Migration Strategy
-
-### Phase 1: Internal A2A Implementation
-- Build core workflows on A2A Task model
-- Use contextId for campaign management
-- Implement status streaming
-
-### Phase 2: MCP Compatibility
-- Add MCP adapter for existing clients
-- Map tools to task types
-- Provide polling for async operations
-
-### Phase 3: Full A2A Exposure
-- Expose native A2A endpoints
-- Enable cross-agent collaboration
-- Support advanced A2A features
-
-## Example: Complete Media Buy Flow
-
-```javascript
-// 1. Start campaign planning
-Client -> Agent: "Plan a $100K campaign for pet food"
-Agent -> Client: taskId: "task-plan-001", status: "working"
-
-// 2. Stream progress updates
-SSE: "Analyzing market conditions..."
-SSE: "Found 15 suitable products across 3 platforms"
-SSE: "Optimizing budget allocation..."
-
-// 3. Present plan (with artifact)
-Agent -> Client: status: "completed", artifact: "campaign_plan.pdf"
-
-// 4. Continue in same context
-Client -> Agent: "Looks good, but increase CTV budget by 20%"
-Agent -> Client: taskId: "task-plan-002", contextId: (same)
-
-// 5. Execute with HITL
-Client -> Agent: "Execute this plan"
-Agent -> Client: status: "pending_approval", "Requires compliance review"
-
-// 6. After approval
-Agent -> Client: status: "completed", artifacts: [media_buy_ids]
-```
-
-This A2A-first approach makes AdCP workflows more natural, powerful, and future-proof while maintaining compatibility with existing MCP clients.
\ No newline at end of file
diff --git a/docs/architecture/a2a-integration-flow.md b/docs/architecture/a2a-integration-flow.md
deleted file mode 100644
index 2388120..0000000
--- a/docs/architecture/a2a-integration-flow.md
+++ /dev/null
@@ -1,175 +0,0 @@
-# A2A Integration Flow Examples
-
-## Example 1: Cross-Platform Campaign Coordination
-
-This example shows how an A2A orchestrator could coordinate a campaign across multiple AdCP-enabled platforms.
-
-```mermaid
-sequenceDiagram
-    participant User
-    participant A2A_Orchestrator as A2A Orchestrator
-    participant AdCP_GAM as AdCP Agent<br/>(Google Ad Manager)
-    participant AdCP_TTD as AdCP Agent<br/>(The Trade Desk)
-    participant AdCP_Signals as AdCP Signals<br/>(Scope3)
-
-    User->>A2A_Orchestrator: "Create $100K campaign for sports fans"
-    
-    Note over A2A_Orchestrator: Parse intent and plan workflow
-    
-    par Parallel Discovery
-        A2A_Orchestrator->>AdCP_Signals: A2A: "Find sports audience signals"
-        AdCP_Signals-->>A2A_Orchestrator: Sports signals found
-    and
-        A2A_Orchestrator->>AdCP_GAM: A2A: "Get CTV inventory for sports"
-        AdCP_GAM-->>A2A_Orchestrator: 5 products available
-    and
-        A2A_Orchestrator->>AdCP_TTD: A2A: "Get display inventory for sports"
-        AdCP_TTD-->>A2A_Orchestrator: 3 products available
-    end
-    
-    Note over A2A_Orchestrator: Optimize budget allocation
-    
-    par Execute Campaigns
-        A2A_Orchestrator->>AdCP_GAM: A2A: "Create $60K CTV campaign"
-        AdCP_GAM-->>A2A_Orchestrator: media_buy_id: gam_12345
-    and
-        A2A_Orchestrator->>AdCP_TTD: A2A: "Create $40K display campaign"
-        AdCP_TTD-->>A2A_Orchestrator: media_buy_id: ttd_67890
-    end
-    
-    A2A_Orchestrator->>User: Campaigns created across platforms
-```
-
-## Example 2: MCP to A2A Bridge Scenario
-
-This shows how a traditional MCP orchestrator could leverage A2A agents through a bridge.
-
-```mermaid
-sequenceDiagram
-    participant MCP_Client as MCP Orchestrator
-    participant AdCP_Agent as AdCP Sales Agent<br/>(Dual Protocol)
-    participant A2A_Analytics as A2A Analytics Agent<br/>(External)
-    participant A2A_Creative as A2A Creative Agent<br/>(External)
-
-    MCP_Client->>AdCP_Agent: MCP: create_media_buy(...)
-    
-    Note over AdCP_Agent: Need performance data
-    
-    AdCP_Agent->>A2A_Analytics: A2A: "Analyze performance for similar campaigns"
-    A2A_Analytics-->>AdCP_Agent: Performance insights
-    
-    Note over AdCP_Agent: Need creative adaptations
-    
-    AdCP_Agent->>A2A_Creative: A2A: "Generate variations for CTV campaign"
-    
-    Note over A2A_Creative: Long-running task
-    A2A_Creative-->>AdCP_Agent: task_id: task_123, status: working
-    A2A_Creative-->>AdCP_Agent: SSE: Progress update (50%)
-    A2A_Creative-->>AdCP_Agent: SSE: Task completed
-    
-    AdCP_Agent-->>MCP_Client: Media buy created with optimizations
-```
-
-## Example 3: Human-in-the-Loop Approval Flow
-
-This demonstrates how A2A's async model supports AdCP's HITL operations.
-
-```mermaid
-sequenceDiagram
-    participant A2A_Client as A2A Client
-    participant AdCP_Agent as AdCP Sales Agent
-    participant Human as Human Approver
-    participant Webhook as Approval System
-
-    A2A_Client->>AdCP_Agent: A2A: "Create $1M campaign (requires approval)"
-    
-    AdCP_Agent->>AdCP_Agent: Validate campaign parameters
-    
-    AdCP_Agent-->>A2A_Client: task_id: task_456, status: pending_approval
-    
-    AdCP_Agent->>Webhook: POST: Approval required notification
-    
-    Webhook->>Human: Email/Slack notification
-    
-    Human->>Webhook: Approve campaign
-    
-    Webhook->>AdCP_Agent: POST: Approval granted
-    
-    AdCP_Agent->>AdCP_Agent: Execute campaign creation
-    
-    AdCP_Agent-->>A2A_Client: SSE: Task completed, media_buy_id: mb_789
-```
-
-## Protocol Interaction Patterns
-
-### Pattern 1: Protocol Selection
-
-```javascript
-// Client can choose protocol based on capabilities
-if (agent.supports('a2a') && needsAsyncWorkflow) {
-  // Use A2A for complex, long-running tasks
-  await agent.a2a.send({
-    message: "Analyze and optimize all active campaigns"
-  });
-} else if (agent.supports('mcp')) {
-  // Use MCP for direct tool execution
-  await agent.mcp.call('get_media_buy_delivery', {
-    media_buy_id: 'mb_123'
-  });
-}
-```
-
-### Pattern 2: Protocol Translation
-
-```javascript
-// A2A request translated to MCP tools
-async function handleA2ARequest(message) {
-  const intent = parseIntent(message);
-  
-  switch(intent.action) {
-    case 'create_campaign':
-      // Map to MCP tools
-      const products = await mcp.call('get_products', {
-        brief: intent.brief
-      });
-      
-      return await mcp.call('create_media_buy', {
-        packages: products.map(p => p.product_id),
-        total_budget: intent.budget
-      });
-  }
-}
-```
-
-### Pattern 3: Cross-Protocol Context
-
-```javascript
-// Maintain context across protocols
-class ContextManager {
-  async handleMCPCall(tool, params, context) {
-    // Store context from MCP interaction
-    this.storeContext(context.sessionId, {
-      protocol: 'mcp',
-      tool,
-      params,
-      timestamp: Date.now()
-    });
-  }
-  
-  async handleA2ATask(task, context) {
-    // Retrieve context from previous interactions
-    const history = this.getContext(context.sessionId);
-    
-    // Use history to provide continuity
-    return this.processWithContext(task, history);
-  }
-}
-```
-
-## Benefits of Integration
-
-1. **Flexibility**: Clients can choose the most appropriate protocol
-2. **Interoperability**: AdCP agents can work with the broader A2A ecosystem
-3. **Scalability**: A2A's async model handles complex workflows
-4. **Backward Compatibility**: Existing MCP clients continue to work
-5. **Innovation**: Enables new multi-agent collaborative workflows
\ No newline at end of file
diff --git a/docs/architecture/a2a-integration-proposal.md b/docs/architecture/a2a-integration-proposal.md
deleted file mode 100644
index 8dda4a6..0000000
--- a/docs/architecture/a2a-integration-proposal.md
+++ /dev/null
@@ -1,324 +0,0 @@
-# AdCP + A2A Integration: Architectural Proposal
-
-## Executive Summary
-
-This document proposes an architecture for integrating Google's Agent2Agent (A2A) protocol with the Advertising Context Protocol (AdCP). The integration would enable AdCP agents to communicate with other A2A-compatible agents, expanding the ecosystem and enabling new collaborative workflows.
-
-## Background
-
-### Current State
-
-**AdCP** (Advertising Context Protocol):
-- Built on Anthropic's Model Context Protocol (MCP)
-- Focused on advertising workflows (media buying, signals, curation)
-- Uses `.well-known/adcp.json` for agent discovery
-- Agents expose MCP endpoints with specific tools
-
-**A2A** (Agent2Agent Protocol):
-- Open protocol by Google with Linux Foundation governance
-- Uses JSON-RPC 2.0 over HTTP
-- Agent Cards at `.well-known/agent.json`
-- Supports async tasks with Server-Sent Events (SSE)
-- Vendor-neutral, modality-agnostic
-
-### Complementary Nature
-
-As noted by Google's Rao Surapaneni: "We see MCP and A2A as complementary capabilities. The way we are looking at Agent2Agent is at a higher layer of abstraction to enable applications and agents to talk to each other."
-
-## Proposed Architecture
-
-### 1. Dual-Protocol Agent Architecture
-
-AdCP agents would support both MCP (for tool interactions) and A2A (for agent-to-agent communication):
-
-```
-┌─────────────────────────────────────────┐
-│           AdCP Agent                     │
-├─────────────────────────────────────────┤
-│  ┌───────────────┐  ┌────────────────┐ │
-│  │  MCP Server   │  │  A2A Server    │ │
-│  │  (Tools)      │  │  (Tasks)       │ │
-│  └───────────────┘  └────────────────┘ │
-│           │                │            │
-│           ▼                ▼            │
-│  ┌────────────────────────────────────┐│
-│  │     Core Business Logic            ││
-│  │  (Media Buy, Signals, Curation)    ││
-│  └────────────────────────────────────┘│
-└─────────────────────────────────────────┘
-```
-
-### 2. Discovery Integration
-
-Extend the AdCP discovery document to include A2A endpoints:
-
-```json
-{
-  "sales": {
-    "mcp": "https://salesagent.example.com/mcp",
-    "a2a": "https://salesagent.example.com/a2a"
-  },
-  "signals": {
-    "mcp": "https://signals.example.com/mcp",
-    "a2a": "https://signals.example.com/a2a"
-  }
-}
-```
-
-Additionally, provide an A2A Agent Card at `.well-known/agent.json`:
-
-```json
-{
-  "name": "AdCP Sales Agent",
-  "description": "AI-powered media buying agent supporting AdCP and A2A protocols",
-  "url": "https://salesagent.example.com/a2a",
-  "authentication": ["bearer", "oauth2"],
-  "supportedInputFormats": ["text/plain", "application/json"],
-  "supportedOutputFormats": ["text/plain", "application/json", "application/pdf"],
-  "skills": [
-    {
-      "name": "media_buy_planning",
-      "description": "Plan and optimize media buying campaigns",
-      "examples": [
-        "Create a $50K CTV campaign targeting sports enthusiasts",
-        "Optimize my current campaigns for better performance"
-      ]
-    },
-    {
-      "name": "inventory_discovery",
-      "description": "Discover available advertising inventory",
-      "examples": [
-        "Find premium video inventory in California",
-        "What audio inventory is available for drive time?"
-      ]
-    }
-  ]
-}
-```
-
-### 3. Protocol Bridging
-
-Create a bridge layer that translates between MCP tool calls and A2A tasks:
-
-```javascript
-// Example: MCP tool call → A2A task
-class AdCPBridge {
-  async handleMCPToolCall(tool, params) {
-    // MCP tool call from orchestrator
-    if (tool === 'create_media_buy') {
-      // Execute locally
-      return this.createMediaBuy(params);
-    }
-  }
-
-  async handleA2ATask(message) {
-    // A2A task from external agent
-    const intent = this.parseIntent(message);
-    
-    if (intent.type === 'media_buy_request') {
-      // Convert to internal format
-      const result = await this.createMediaBuy(intent.params);
-      
-      // Return A2A response
-      return {
-        artifacts: [{
-          name: "media_buy_result",
-          parts: [{
-            kind: "application/json",
-            data: result
-          }]
-        }]
-      };
-    }
-  }
-}
-```
-
-### 4. Use Cases Enabled
-
-#### Cross-Platform Campaign Coordination
-
-An A2A orchestrator could coordinate campaigns across multiple AdCP-enabled platforms:
-
-```
-A2A Orchestrator
-    │
-    ├──A2A──> AdCP Sales Agent (Google Ad Manager)
-    ├──A2A──> AdCP Sales Agent (The Trade Desk)
-    └──A2A──> AdCP Signals Agent (Scope3)
-```
-
-#### Intent-Based Workflows
-
-Natural language intents could be processed by specialized agents:
-
-```
-User: "I need to reach sports fans with a $100K budget"
-    │
-    ▼
-A2A Intent Processor
-    │
-    ├──A2A──> AdCP Signals Agent: "Find sports audience signals"
-    ├──A2A──> AdCP Sales Agent: "Get CTV inventory for sports"
-    └──A2A──> AdCP Curation Agent: "Create sports package"
-```
-
-#### Human-in-the-Loop Approval
-
-A2A's async task model aligns well with AdCP's HITL operations:
-
-```json
-{
-  "method": "message/send",
-  "params": {
-    "message": {
-      "parts": [{
-        "kind": "text",
-        "text": "Create $50K campaign pending human approval"
-      }]
-    },
-    "configuration": {
-      "pushNotificationConfig": {
-        "url": "https://approvals.example.com/webhook"
-      }
-    }
-  }
-}
-```
-
-## Implementation Approach
-
-### Phase 1: A2A Wrapper for Existing Agents
-
-Create an A2A server wrapper that exposes existing MCP tools as A2A tasks:
-
-```javascript
-class A2AWrapper {
-  constructor(mcpAgent) {
-    this.mcpAgent = mcpAgent;
-    this.setupA2AServer();
-  }
-
-  async handleTask(message) {
-    // Parse natural language or structured request
-    const intent = await this.parseIntent(message);
-    
-    // Map to MCP tool
-    const tool = this.mapIntentToTool(intent);
-    
-    // Execute via MCP
-    const result = await this.mcpAgent.execute(tool, intent.params);
-    
-    // Return A2A response
-    return this.formatA2AResponse(result);
-  }
-}
-```
-
-### Phase 2: Native A2A Integration
-
-Build A2A support directly into AdCP agents:
-
-1. **Shared Context Management**: Maintain conversation context across protocols
-2. **Task Orchestration**: Support complex multi-step workflows
-3. **Cross-Agent Collaboration**: Enable agents to delegate subtasks
-
-### Phase 3: Advanced Features
-
-1. **Multi-Modal Support**: Handle PDFs, images, and other artifacts
-2. **Streaming Updates**: Use SSE for real-time campaign monitoring
-3. **Agent Marketplace**: Discovery service for A2A-enabled AdCP agents
-
-## Technical Considerations
-
-### Authentication
-
-A2A supports standard authentication methods that align with AdCP:
-- Bearer tokens (current AdCP approach)
-- OAuth2 (for enterprise integrations)
-
-### Error Handling
-
-Map AdCP error codes to A2A JSON-RPC errors:
-
-```javascript
-// AdCP error
-{
-  "error": {
-    "code": "INVALID_PARAMETER",
-    "message": "Start date must be in the future"
-  }
-}
-
-// A2A JSON-RPC error
-{
-  "jsonrpc": "2.0",
-  "error": {
-    "code": -32602,
-    "message": "Invalid params",
-    "data": {
-      "field": "start_date",
-      "reason": "Start date must be in the future"
-    }
-  }
-}
-```
-
-### Performance
-
-- A2A's async model suits AdCP's long-running operations
-- SSE enables efficient status updates without polling
-- Task IDs allow tracking across system boundaries
-
-## Migration Path
-
-1. **Compatibility Mode**: Existing MCP clients continue working unchanged
-2. **Dual Support**: New agents support both protocols
-3. **Gradual Adoption**: Orchestrators can mix MCP and A2A agents
-4. **Feature Parity**: Ensure all MCP tools have A2A equivalents
-
-## Benefits
-
-### For Publishers
-
-- **Broader Reach**: Connect with A2A ecosystem (100+ partners)
-- **Flexibility**: Support multiple orchestrator types
-- **Innovation**: Enable new collaborative workflows
-
-### For Orchestrators
-
-- **Unified Interface**: Single protocol for diverse agents
-- **Scalability**: A2A's async model handles complex workflows
-- **Ecosystem**: Access to growing A2A agent marketplace
-
-### For the Industry
-
-- **Interoperability**: AdCP agents work with any A2A system
-- **Standards Alignment**: Two major protocols working together
-- **Future-Proof**: Prepared for multi-agent AI future
-
-## Recommendations
-
-1. **Start with Wrappers**: Build A2A wrappers for existing agents to test integration
-2. **Extend Discovery**: Update `.well-known/adcp.json` to include A2A endpoints
-3. **Pilot Programs**: Work with key partners to validate use cases
-4. **Community Feedback**: Engage both AdCP and A2A communities
-5. **Reference Implementation**: Create open-source bridge implementation
-
-## Conclusion
-
-Integrating A2A support into AdCP would:
-- Expand the addressable ecosystem
-- Enable new multi-agent workflows
-- Position AdCP at the forefront of agent interoperability
-- Maintain backward compatibility with existing MCP implementations
-
-The complementary nature of MCP (for tools) and A2A (for agent communication) creates a powerful combination for the future of AI-powered advertising.
-
-## Next Steps
-
-1. Review proposal with AdCP working group
-2. Engage with A2A community for feedback
-3. Build proof-of-concept integration
-4. Define formal specification for dual-protocol agents
-5. Update AdCP documentation with A2A guidelines
\ No newline at end of file
diff --git a/docs/architecture/a2a-mcp-comparison.md b/docs/architecture/a2a-mcp-comparison.md
deleted file mode 100644
index cabb746..0000000
--- a/docs/architecture/a2a-mcp-comparison.md
+++ /dev/null
@@ -1,162 +0,0 @@
-# A2A vs MCP: Technical Comparison for AdCP
-
-## Quick Comparison Table
-
-| Feature | MCP | A2A | Winner for AdCP |
-|---------|-----|-----|-----------------|
-| **Request Model** | Request/Response | Task-based with lifecycle | A2A ✅ |
-| **Human-in-the-Loop** | Build yourself | Native states (pending_approval) | A2A ✅ |
-| **Status Updates** | Poll or custom webhooks | Native SSE streaming | A2A ✅ |
-| **Context Management** | Pass IDs manually | contextId maintains conversation | A2A ✅ |
-| **Long-Running Operations** | Return task ID, poll | Native async with updates | A2A ✅ |
-| **Error Handling** | Immediate or fail | Can pause, await input, resume | A2A ✅ |
-| **Multi-Step Workflows** | Chain API calls | Natural conversation flow | A2A ✅ |
-| **Artifact Handling** | Return in response | Structured artifacts with metadata | A2A ✅ |
-| **Protocol Complexity** | Simple | More comprehensive | MCP ✅ |
-| **Current Adoption** | Anthropic ecosystem | Google + 100+ partners | A2A ✅ |
-
-## Detailed Comparison
-
-### Creating a Media Buy
-
-#### MCP Approach
-```javascript
-// Step 1: Try to create
-const result = await mcp.call('create_media_buy', params);
-
-// Step 2: Handle approval needed
-if (result.error?.code === 'APPROVAL_REQUIRED') {
-  // Must implement:
-  // - Task storage
-  // - Webhook system  
-  // - Polling endpoints
-  // - State management
-  const taskId = result.error.task_id;
-  
-  // Step 3: Poll for updates
-  while (true) {
-    const status = await getTaskStatus(taskId);
-    if (status !== 'pending') break;
-    await sleep(5000);
-  }
-}
-```
-
-#### A2A Approach
-```javascript
-// Step 1: Send task
-const task = await a2a.send({
-  message: { text: "Create $100K campaign" }
-});
-
-// Step 2: Automatic updates via SSE
-// "Checking inventory..."
-// "Validating budget..."  
-// "Pending approval..."
-
-// Step 3: Continue in same context when approved
-// No polling, no custom task system needed
-```
-
-### Creative Review Workflow
-
-#### MCP: Multiple Disconnected Calls
-```javascript
-// Upload
-const upload = await mcp.call('upload_creative', {
-  file: 'video.mp4',
-  media_buy_id: 'mb_123'  // Must pass context
-});
-
-// Analyze  
-const analysis = await mcp.call('analyze_creative', {
-  creative_id: upload.creative_id,  // Thread ID
-  media_buy_id: 'mb_123'           // Thread context
-});
-
-// Request changes
-const variations = await mcp.call('create_variations', {
-  creative_id: upload.creative_id,  // Thread ID again
-  media_buy_id: 'mb_123',          // Thread context again
-  variations: ['15s', 'captions']
-});
-
-// If human review needed - build custom system
-```
-
-#### A2A: Natural Conversation
-```javascript
-// Upload in context
-const task1 = await a2a.send({
-  message: { 
-    text: "Upload creative for campaign",
-    file: "video.mp4"
-  }
-});
-// Returns: contextId: "ctx-creative-123"
-
-// Continue conversation
-const task2 = await a2a.send({
-  contextId: "ctx-creative-123",  // Same context!
-  message: { text: "Create 15s version with captions" }
-});
-
-// Human review - native support
-// Status: "pending_review"
-// Reviewer responds in same context
-```
-
-## Why A2A is Better for AdCP
-
-### 1. **Advertising is Task-Based**
-- Campaigns take time to create
-- Multiple approval steps
-- Long-running optimizations
-- A2A models this naturally
-
-### 2. **HITL is Essential**
-- Compliance reviews
-- Budget approvals  
-- Creative reviews
-- A2A has this built-in
-
-### 3. **Context is Critical**
-- Creative → Campaign → Performance
-- Multi-step workflows
-- Team collaboration
-- A2A's contextId handles this
-
-### 4. **Transparency Matters**
-- Clients need progress updates
-- "What's happening with my campaign?"
-- A2A streams status natively
-
-### 5. **Errors Aren't Fatal**
-- "Fix this targeting issue"
-- "Add this creative"
-- "Change the budget"
-- A2A tasks can pause and resume
-
-## MCP Strengths (Where It's Better)
-
-1. **Simplicity**: Easier to implement basic tools
-2. **Immediate Response**: Good for quick lookups
-3. **Anthropic Ecosystem**: Deep integration with Claude
-
-## Recommendation
-
-Use A2A as the core protocol for AdCP because:
-
-1. **Natural Fit**: Task model matches advertising workflows
-2. **Less Code**: Don't build what A2A provides
-3. **Better UX**: Real-time updates, natural conversations
-4. **Future-Proof**: Broader ecosystem support
-
-Provide MCP compatibility for:
-1. Simple tool queries (get_products)
-2. Backward compatibility  
-3. Anthropic ecosystem integration
-
-## The Verdict
-
-**A2A for workflows, MCP for tools.** Since AdCP is primarily about workflows (media buying, creative management, optimization), A2A is the clear choice as the primary protocol.
\ No newline at end of file
diff --git a/docs/architecture/a2a-recommendation.md b/docs/architecture/a2a-recommendation.md
deleted file mode 100644
index a267412..0000000
--- a/docs/architecture/a2a-recommendation.md
+++ /dev/null
@@ -1,176 +0,0 @@
-# Recommendation: Build AdCP on A2A Protocol
-
-## Executive Summary
-
-After analyzing both protocols, we recommend building AdCP on Google's A2A protocol as the foundational layer, with MCP provided as a compatibility interface. A2A's Task abstraction is fundamentally better suited for advertising workflows than MCP's request/response model.
-
-## Key Reasons
-
-### 1. Tasks Are Perfect for Advertising Workflows
-
-Advertising operations are inherently task-based:
-- **Media Buy Creation**: Multi-step process with checkpoints
-- **Creative Review**: Iterative workflow with approvals
-- **Campaign Optimization**: Long-running analysis and adjustments
-
-A2A Tasks provide:
-- Native status progression (pending → working → completed)
-- Built-in human-in-the-loop states
-- Real-time progress updates via SSE
-- Context preservation across interactions
-
-### 2. Human-in-the-Loop is First-Class
-
-Current AdCP must build HITL on top of MCP:
-```javascript
-// MCP: Return error, build custom task system
-return { 
-  error: { 
-    code: "APPROVAL_REQUIRED", 
-    task_id: "custom_task_123" 
-  } 
-}
-```
-
-With A2A, it's native:
-```javascript
-// A2A: Natural task state
-await task.update({
-  status: { state: "pending_approval" },
-  message: "Awaiting compliance review"
-})
-```
-
-### 3. Context Management for Complex Workflows
-
-The `contextId` elegantly handles multi-step processes:
-- Upload creative → Get feedback → Make changes → Get approval
-- All in one conversational context
-- No manual state threading between API calls
-
-### 4. Real-Time Status Updates
-
-Clients can see what's happening:
-- "Checking inventory availability..."
-- "Validating targeting parameters..."
-- "Submitting to ad server..."
-- "Awaiting publisher approval..."
-
-This transparency is crucial for enterprise workflows.
-
-## Proposed Architecture
-
-```
-┌─────────────────────────────────────┐
-│        AdCP Agent (A2A Core)        │
-├─────────────────────────────────────┤
-│  ╔═══════════════════════════════╗  │
-│  ║   A2A Task Engine (Primary)   ║  │
-│  ║   - Task lifecycle            ║  │
-│  ║   - Context management        ║  │
-│  ║   - Status streaming          ║  │
-│  ║   - Artifact handling         ║  │
-│  ╚═══════════════════════════════╝  │
-│              │                       │
-│  ┌───────────┴────────────────────┐ │
-│  │   Advertising Business Logic   │ │
-│  │   - Media Buy workflows        │ │
-│  │   - Creative management        │ │
-│  │   - Signal discovery           │ │
-│  └───────────┬────────────────────┘ │
-│              │                       │
-│  ┌───────────┴────────────────────┐ │
-│  │  MCP Adapter (Compatibility)   │ │
-│  │  - Legacy support              │ │
-│  │  - Tool → Task translation    │ │
-│  └────────────────────────────────┘ │
-└─────────────────────────────────────┘
-```
-
-## Implementation Path
-
-### Phase 1: Build on A2A (Q2 2025)
-- Implement core workflows using A2A Tasks
-- Use contextId for campaign management
-- Native HITL support from day one
-
-### Phase 2: MCP Compatibility (Q3 2025)
-- Add MCP adapter for existing integrations
-- Translate MCP tools to A2A tasks
-- Maintain backward compatibility
-
-### Phase 3: Advanced Features (Q4 2025)
-- Multi-agent collaboration
-- Cross-platform orchestration
-- Advanced artifact handling
-
-## Example: Media Buy as A2A Task
-
-```javascript
-// Natural workflow with status updates
-Client: "Create $100K CTV campaign for sports fans"
-
-Agent: Task "task-mb-001" created
-  ↓ Status: "Analyzing requirements..."
-  ↓ Status: "Found 12 suitable products"
-  ↓ Status: "Optimizing budget allocation..."
-  ↓ Status: "Creating campaign..." 
-  ↓ Status: "Pending approval (compliance required)"
-  
-Client: "Approved"
-
-Agent: Task completed
-  → Artifact: media_buy_confirmation.json
-  → Artifact: insertion_order.pdf
-```
-
-## Risk Mitigation
-
-### Concern: "A2A is newer/less proven"
-**Mitigation**: 
-- Backed by Google and Linux Foundation
-- 100+ partners already committed
-- MCP compatibility ensures fallback option
-
-### Concern: "Existing MCP integrations"
-**Mitigation**:
-- MCP adapter provides full compatibility
-- No breaking changes for current users
-- Gradual migration path
-
-### Concern: "Implementation complexity"
-**Mitigation**:
-- A2A actually simplifies implementation
-- No need to build task management
-- Reference implementations available
-
-## Conclusion
-
-A2A's Task model is not just compatible with advertising workflows—it's designed for them. By building AdCP on A2A:
-
-1. **Immediate Benefits**:
-   - Native HITL support
-   - Real-time status updates
-   - Context-aware workflows
-   - Simplified implementation
-
-2. **Future Benefits**:
-   - Access to A2A ecosystem
-   - Multi-agent collaboration
-   - Advanced features (UI embedding, etc.)
-
-3. **No Downside**:
-   - MCP compatibility maintained
-   - Better architecture overall
-   - Future-proof design
-
-## Recommendation
-
-**Build AdCP agents on A2A protocol with MCP as a compatibility layer.** This positions AdCP at the forefront of agent interoperability while providing a superior developer and user experience.
-
-## Next Steps
-
-1. Engage with A2A community
-2. Build proof-of-concept A2A agent
-3. Update AdCP specification
-4. Create migration guide for existing implementations
\ No newline at end of file
diff --git a/docs/architecture/executive-summary.md b/docs/architecture/executive-summary.md
deleted file mode 100644
index 37e2e6f..0000000
--- a/docs/architecture/executive-summary.md
+++ /dev/null
@@ -1,133 +0,0 @@
-# Executive Summary: Task-First Architecture for AdCP
-
-## The Journey
-
-We started by exploring how AdCP could support Google's Agent2Agent (A2A) protocol alongside MCP. Through our analysis, we discovered something more fundamental: **the right abstraction for AdCP is Tasks, not protocols**.
-
-## Final Recommendation: Task-First Architecture
-
-Build AdCP with a **Task Engine** at its core, with protocol adapters for MCP, A2A, and future protocols.
-
-```
-         ┌──────────┐ ┌──────────┐ ┌──────────┐
-         │   MCP    │ │   A2A    │ │   REST   │
-         │ Adapter  │ │ Adapter  │ │ Adapter  │
-         └────┬─────┘ └────┬─────┘ └────┬─────┘
-              └────────┬────┴────────────┘
-                       ▼
-              ┌─────────────────┐
-              │   Task Engine   │
-              └────────┬────────┘
-                       ▼
-         ┌─────────────┴──────────────┐
-         │    Task Implementations    │
-         │ (MediaBuy, Creative, etc.) │
-         └────────────────────────────┘
-```
-
-## Why Task-First?
-
-### 1. Perfect Match for Advertising
-Advertising operations are naturally task-based:
-- **Media Buying**: Multi-step workflow with approvals
-- **Creative Review**: Iterative process with human feedback
-- **Campaign Optimization**: Long-running analysis and adjustments
-
-### 2. Protocol Independence
-Developers implement a simple interface:
-```javascript
-class MyTask {
-  async execute(input, ctx) {
-    await ctx.updateStatus('Processing...');
-    // Business logic here
-    await ctx.complete(results);
-  }
-}
-```
-
-The framework handles all protocol translation automatically.
-
-### 3. Built-in Features
-Every task gets these for free across all protocols:
-- Status updates and progress tracking
-- Human-in-the-loop support
-- Context management
-- Error handling and retry
-- Artifact management
-
-### 4. Future-Proof
-Adding support for a new protocol is just writing an adapter. Task implementations remain unchanged.
-
-## Benefits Over Protocol-First Approaches
-
-| Aspect | Protocol-First | Task-First |
-|--------|---------------|------------|
-| **Developer Experience** | Must understand protocol specifics | Just implement business logic |
-| **Code Reuse** | Different implementations per protocol | Write once, works everywhere |
-| **Feature Parity** | Features vary by protocol | Consistent features across all protocols |
-| **Testing** | Test with protocol overhead | Test tasks directly |
-| **Future Protocols** | Rewrite implementations | Add adapter only |
-
-## Implementation Simplicity
-
-Here's a complete task implementation:
-
-```javascript
-class InventoryDiscoveryTask {
-  async execute(input, ctx) {
-    await ctx.updateStatus('Searching inventory...');
-    
-    const results = await this.searchInventory(input.filters);
-    
-    await ctx.addArtifact({
-      name: 'inventory_results',
-      type: 'application/json',
-      data: results
-    });
-    
-    await ctx.complete();
-  }
-}
-```
-
-This automatically works with:
-- MCP (synchronous or async with polling)
-- A2A (with streaming updates and context)
-- REST APIs
-- Future protocols
-
-## Evolution of Our Thinking
-
-1. **Started**: How can AdCP support both MCP and A2A?
-2. **Discovered**: A2A's Task model is superior for advertising workflows
-3. **Realized**: Tasks are the right abstraction regardless of protocol
-4. **Conclusion**: Task-first architecture with protocol adapters
-
-## Next Steps
-
-1. **Immediate**
-   - Define Task interface specification
-   - Create reference implementations
-   - Build MCP and A2A adapters
-
-2. **Short Term**
-   - Update AdCP specification
-   - Provide migration guide
-   - Release reference implementation
-
-3. **Long Term**
-   - Add more protocol adapters
-   - Build task composition features
-   - Create visual workflow builder
-
-## Conclusion
-
-The task-first architecture transforms AdCP from a protocol specification into a **workflow platform** that happens to support multiple protocols. This positions AdCP for long-term success in the evolving landscape of AI-powered advertising.
-
-By focusing on Tasks rather than protocols, we:
-- Simplify implementation for developers
-- Provide consistent behavior for users
-- Future-proof against protocol changes
-- Enable innovation at the workflow level
-
-**Recommendation**: Adopt the task-first architecture as the foundation for AdCP v2.
\ No newline at end of file
diff --git a/docs/architecture/task-first-architecture.md b/docs/architecture/task-first-architecture.md
deleted file mode 100644
index 642df21..0000000
--- a/docs/architecture/task-first-architecture.md
+++ /dev/null
@@ -1,421 +0,0 @@
-# Task-First Architecture for AdCP
-
-## Core Insight
-
-Instead of building on A2A or MCP, we build on a **Task abstraction** with protocol adapters. This separates business logic from protocol concerns and provides maximum flexibility.
-
-## Architecture Overview
-
-```
-┌─────────────────────────────────────────────────┐
-│              Protocol Layer                      │
-├─────────────────────────────────────────────────┤
-│  ┌─────────────┐         ┌─────────────┐       │
-│  │ MCP Adapter │         │ A2A Adapter │       │
-│  └──────┬──────┘         └──────┬──────┘       │
-│         │                        │               │
-│         └────────┬───────────────┘               │
-│                  ▼                               │
-├─────────────────────────────────────────────────┤
-│           Task Engine (Core)                     │
-├─────────────────────────────────────────────────┤
-│  ┌────────────────────────────────────────┐    │
-│  │  Task Definition & Lifecycle            │    │
-│  │  - States: pending|working|paused|done │    │
-│  │  - Context management                   │    │
-│  │  - Status updates                       │    │
-│  │  - Artifact handling                    │    │
-│  └────────────────────────────────────────┘    │
-│                  ▼                               │
-├─────────────────────────────────────────────────┤
-│         Task Implementations                     │
-├─────────────────────────────────────────────────┤
-│  ┌──────────────┐  ┌───────────────┐          │
-│  │ MediaBuyTask │  │ CreativeTask  │          │
-│  └──────────────┘  └───────────────┘          │
-│  ┌──────────────┐  ┌───────────────┐          │
-│  │ SignalsTask  │  │ ReportingTask │          │
-│  └──────────────┘  └───────────────┘          │
-└─────────────────────────────────────────────────┘
-```
-
-## Core Task Model
-
-```typescript
-interface Task {
-  // Identity
-  id: string;
-  type: string;
-  contextId: string;
-  
-  // State
-  state: 'pending' | 'working' | 'paused' | 'pending_approval' | 
-         'pending_input' | 'completed' | 'failed';
-  
-  // Progress
-  progress?: {
-    message: string;
-    percentage?: number;
-    metadata?: Record<string, any>;
-  };
-  
-  // Results
-  artifacts?: Artifact[];
-  error?: TaskError;
-  
-  // Metadata
-  createdAt: Date;
-  updatedAt: Date;
-  metadata: Record<string, any>;
-}
-
-interface TaskHandler {
-  // Implement this to create a task
-  async execute(input: TaskInput, context: TaskContext): Promise<void>;
-  
-  // Optional: Handle task-specific events
-  async onPause?(context: TaskContext): Promise<void>;
-  async onResume?(context: TaskContext): Promise<void>;
-  async onCancel?(context: TaskContext): Promise<void>;
-}
-
-interface TaskContext {
-  // Identity
-  task: Task;
-  
-  // State management
-  async updateStatus(message: string, metadata?: any): Promise<void>;
-  async setState(state: Task['state']): Promise<void>;
-  async setProgress(progress: number, message?: string): Promise<void>;
-  
-  // Human-in-the-loop
-  async requestApproval(details: ApprovalRequest): Promise<void>;
-  async waitForInput(prompt: InputRequest): Promise<any>;
-  
-  // Results
-  async addArtifact(artifact: Artifact): Promise<void>;
-  async complete(artifacts?: Artifact[]): Promise<void>;
-  async fail(error: TaskError): Promise<void>;
-  
-  // Context
-  async getContext<T>(key: string): Promise<T>;
-  async setContext(key: string, value: any): Promise<void>;
-}
-```
-
-## Example: Media Buy Task Implementation
-
-```typescript
-class MediaBuyTask implements TaskHandler {
-  async execute(input: TaskInput, ctx: TaskContext) {
-    // Parse input (protocol-agnostic)
-    const params = this.parseParams(input);
-    
-    // Update status - protocol adapters handle delivery
-    await ctx.updateStatus('Validating campaign parameters...');
-    
-    // Business logic
-    const validation = await this.validateCampaign(params);
-    
-    if (validation.errors.length > 0) {
-      return ctx.fail({
-        code: 'VALIDATION_ERROR',
-        message: 'Campaign validation failed',
-        details: validation.errors
-      });
-    }
-    
-    // Check inventory
-    await ctx.updateStatus('Checking inventory availability...');
-    const inventory = await this.checkInventory(params);
-    
-    // Needs approval?
-    if (params.budget > 100000 || validation.requiresApproval) {
-      await ctx.setState('pending_approval');
-      await ctx.requestApproval({
-        type: 'budget_approval',
-        reason: 'Campaign exceeds automatic approval threshold',
-        details: {
-          budget: params.budget,
-          inventory: inventory.summary
-        }
-      });
-      
-      // Task engine handles waiting for approval
-      // When resumed, we continue here
-    }
-    
-    // Create campaign
-    await ctx.updateStatus('Creating campaign in ad server...');
-    await ctx.setProgress(75, 'Submitting to ad server');
-    
-    const campaign = await this.createInAdServer(params, inventory);
-    
-    // Add results
-    await ctx.addArtifact({
-      name: 'media_buy_confirmation',
-      type: 'application/json',
-      data: campaign
-    });
-    
-    await ctx.addArtifact({
-      name: 'insertion_order',
-      type: 'application/pdf',
-      uri: campaign.ioUrl
-    });
-    
-    // Complete
-    await ctx.complete();
-  }
-}
-```
-
-## Protocol Adapters
-
-### MCP Adapter
-
-```typescript
-class MCPAdapter {
-  constructor(private taskEngine: TaskEngine) {}
-  
-  // MCP tool call → Task
-  async handleToolCall(tool: string, params: any): Promise<any> {
-    // Map tool to task type
-    const taskType = this.mapToolToTask(tool);
-    
-    // Create task
-    const task = await this.taskEngine.createTask({
-      type: taskType,
-      input: params,
-      options: {
-        // MCP is synchronous by default
-        waitForCompletion: true,
-        timeout: 30000
-      }
-    });
-    
-    // For async operations, return task info
-    if (this.isAsyncTool(tool)) {
-      return {
-        task_id: task.id,
-        status: task.state,
-        status_url: `/tasks/${task.id}`
-      };
-    }
-    
-    // For sync operations, wait and return result
-    const result = await task.waitForCompletion();
-    
-    if (result.state === 'completed') {
-      // Extract result from artifacts
-      return this.extractResult(result.artifacts);
-    } else {
-      throw new Error(result.error?.message || 'Task failed');
-    }
-  }
-  
-  // Polling endpoint for async tasks
-  async getTaskStatus(taskId: string): Promise<any> {
-    const task = await this.taskEngine.getTask(taskId);
-    return {
-      status: task.state,
-      progress: task.progress,
-      result: task.state === 'completed' ? 
-        this.extractResult(task.artifacts) : null
-    };
-  }
-}
-```
-
-### A2A Adapter
-
-```typescript
-class A2AAdapter {
-  constructor(private taskEngine: TaskEngine) {}
-  
-  // A2A message → Task
-  async handleMessage(message: A2AMessage): Promise<A2AResponse> {
-    const { contextId, referenceTaskIds } = message;
-    
-    // Determine task type from message
-    const taskType = await this.inferTaskType(message);
-    
-    // Create or continue task
-    const task = await this.taskEngine.createTask({
-      type: taskType,
-      contextId: contextId,
-      input: {
-        message: message.parts,
-        referenceTaskIds
-      }
-    });
-    
-    // A2A expects immediate response with task info
-    return {
-      taskId: task.id,
-      contextId: task.contextId,
-      status: { state: this.mapTaskStateToA2A(task.state) }
-    };
-  }
-  
-  // Stream task updates via SSE
-  async streamTaskUpdates(taskId: string, stream: EventStream) {
-    const task = await this.taskEngine.getTask(taskId);
-    
-    // Subscribe to task events
-    task.on('statusUpdate', (update) => {
-      stream.send({
-        type: 'status',
-        data: {
-          message: update.message,
-          metadata: update.metadata
-        }
-      });
-    });
-    
-    task.on('stateChange', (state) => {
-      stream.send({
-        type: 'state',
-        data: { state: this.mapTaskStateToA2A(state) }
-      });
-    });
-    
-    task.on('complete', (artifacts) => {
-      stream.send({
-        type: 'complete',
-        data: {
-          artifacts: this.mapArtifactsToA2A(artifacts)
-        }
-      });
-      stream.close();
-    });
-  }
-}
-```
-
-## Benefits of Task-First Architecture
-
-### 1. **Protocol Independence**
-Implementers only need to understand the Task interface, not protocol specifics:
-```typescript
-// Developer implements this
-class MyTask implements TaskHandler {
-  async execute(input, ctx) {
-    // Just focus on business logic
-    await ctx.updateStatus('Doing something...');
-    // ...
-  }
-}
-
-// Framework handles protocol translation automatically
-```
-
-### 2. **Future-Proof**
-Adding a new protocol is just adding a new adapter:
-```typescript
-class GraphQLAdapter {
-  // Maps GraphQL subscriptions to task events
-}
-
-class WebSocketAdapter {
-  // Real-time task updates over WebSocket
-}
-```
-
-### 3. **Consistent Behavior**
-All protocols get the same features:
-- Status updates
-- Progress tracking
-- HITL support
-- Context management
-- Artifact handling
-
-### 4. **Easier Testing**
-Test tasks directly without protocol overhead:
-```typescript
-const task = new MediaBuyTask();
-const ctx = new TestTaskContext();
-await task.execute(input, ctx);
-expect(ctx.artifacts).toHaveLength(2);
-```
-
-### 5. **Clean Separation of Concerns**
-- **Task Layer**: Business logic only
-- **Protocol Layer**: Translation only
-- **Engine Layer**: State management, persistence, events
-
-## Implementation Path
-
-### Phase 1: Define Core Task Model
-- Task interface and lifecycle
-- Context management
-- Event system
-- Artifact handling
-
-### Phase 2: Build Task Implementations
-- MediaBuyTask
-- CreativeTask
-- SignalsTask
-- ReportingTask
-
-### Phase 3: Add Protocol Adapters
-- MCP adapter (for compatibility)
-- A2A adapter (for rich features)
-- REST adapter (for simple integrations)
-
-### Phase 4: Advanced Features
-- Task composition (workflows)
-- Task dependencies
-- Parallel execution
-- Retry policies
-
-## Example: Complete Flow
-
-```typescript
-// 1. A2A Request comes in
-POST /a2a
-{
-  "method": "message/send",
-  "params": {
-    "message": {
-      "parts": [{"text": "Create $50K CTV campaign"}]
-    }
-  }
-}
-
-// 2. A2A Adapter creates task
-const task = taskEngine.createTask({
-  type: 'media_buy',
-  input: { brief: "Create $50K CTV campaign" }
-});
-
-// 3. MediaBuyTask executes
-// - Updates status
-// - Requests approval if needed
-// - Creates campaign
-// - Returns artifacts
-
-// 4. A2A Adapter streams updates
-SSE: {"message": "Checking inventory..."}
-SSE: {"message": "Pending approval..."}
-SSE: {"state": "completed", "artifacts": [...]}
-
-// Same task works with MCP!
-POST /mcp
-{
-  "method": "create_media_buy",
-  "params": { "budget": 50000, "type": "ctv" }
-}
-// Returns when complete or task_id if async
-```
-
-## Conclusion
-
-A task-first architecture provides:
-- **Clean abstraction** for implementers
-- **Protocol flexibility** for clients  
-- **Future-proofing** for new standards
-- **Consistent features** across protocols
-- **Simpler implementation** overall
-
-Instead of choosing between MCP and A2A, we get both—plus the ability to add more protocols as needed—all while keeping the implementation clean and focused on business logic.
\ No newline at end of file
diff --git a/docs/intro.md b/docs/intro.md
index dc2d750..5eff183 100644
--- a/docs/intro.md
+++ b/docs/intro.md
@@ -9,11 +9,17 @@ Welcome to the Ad Context Protocol (AdCP) documentation. AdCP enables AI assista
 
 ## What is Ad Context Protocol?
 
-Ad Context Protocol is an open standard based on the Model Context Protocol (MCP) that allows:
+Ad Context Protocol is an open standard that enables AI-powered advertising workflows through:
 
 - **Natural Language Interaction**: Describe what you want in plain English
 - **Platform Agnostic**: Works with any compatible advertising platform
-- **AI-Powered**: Designed for integration with AI assistants like Claude, GPT, and others
+- **Multi-Protocol Support**: Access AdCP through MCP, A2A, or future protocols
+- **AI-Powered**: Designed for integration with AI assistants and agents
+
+AdCP uses a task-first architecture where core advertising tasks (like creating media buys or discovering signals) can be accessed through multiple protocols:
+- **MCP (Model Context Protocol)**: For direct AI assistant integration
+- **A2A (Agent2Agent Protocol)**: For complex workflows and agent collaboration
+- **REST API**: Coming soon for traditional integrations
 
 ## Protocol Architecture
 
@@ -148,9 +154,20 @@ If you want to use AdCP with your AI assistant:
 2. Configure your AI assistant with AdCP-enabled platforms
 3. Start using natural language for your campaigns
 
+## Protocol Flexibility
+
+AdCP's task-first architecture means you can access the same functionality through different protocols:
+
+- **Using MCP**: Ideal for Claude and other AI assistants with direct tool integration
+- **Using A2A**: Perfect for complex workflows with approvals and multi-agent collaboration
+- **Protocol Agnostic**: Implementers write tasks once, support all protocols automatically
+
+Learn more in the [Protocols section](./protocols/overview).
+
 ## Next Steps
 
 - **Platform Providers**: Start with the [Signals Protocol Specification](./signals/specification)
+- **Developers**: Review the [Protocol Support](./protocols/overview) options
 - **Everyone**: Join the [community discussion](https://github.com/adcontextprotocol/adcp/discussions)
 
 ## Need Help?
diff --git a/docs/media-buy/api-reference.md b/docs/media-buy/api-reference.md
index f3051c6..58f9c4d 100644
--- a/docs/media-buy/api-reference.md
+++ b/docs/media-buy/api-reference.md
@@ -58,11 +58,13 @@ A package represents a specific advertising product within a media buy:
 
 **For Industry Discussion**: Should we support multiple flights per package?
 
-## API Tools Reference
+## Tasks
+
+The Media Buy Protocol defines the following tasks that agents can perform:
 
 ### 1. list_creative_formats
 
-Lists all supported creative formats in the system.
+**Task**: Discover all supported creative formats in the system.
 
 **Request:**
 ```json
@@ -130,7 +132,7 @@ Lists all supported creative formats in the system.
 
 ### 2. create_media_buy
 
-Creates a media buy from selected packages.
+**Task**: Create a media buy from selected packages. This task handles the complete workflow including validation, approval if needed, and campaign creation.
 
 **Request:**
 ```json
@@ -175,7 +177,7 @@ Creates a media buy from selected packages.
 
 ### 3. add_creative_assets
 
-Uploads creative assets and assigns to packages.
+**Task**: Upload creative assets and assign them to packages. This task includes validation, policy review, and format adaptation suggestions.
 
 **Request:**
 ```json
@@ -250,7 +252,7 @@ Uploads creative assets and assigns to packages.
 
 ### 4. check_media_buy_status
 
-Monitors the status of a media buy.
+**Task**: Monitor the current status and delivery progress of a media buy.
 
 **Request:**
 ```json
@@ -293,7 +295,7 @@ Monitors the status of a media buy.
 
 ### 5. get_media_buy_delivery
 
-Retrieves delivery metrics for reporting.
+**Task**: Retrieve comprehensive delivery metrics and performance data for reporting.
 
 **Request:**
 ```json
@@ -350,7 +352,7 @@ Retrieves delivery metrics for reporting.
 
 ### 6. update_media_buy
 
-Updates campaign and package settings using PATCH semantics.
+**Task**: Update campaign and package settings. This task supports partial updates and handles any required approvals.
 
 **Request Example 1 - Campaign Pause:**
 ```json
@@ -674,7 +676,7 @@ Retrieves delivery data for all active media buys across all principals.
 
 ### 16. get_products
 
-Lists available advertising products for the authenticated principal with optional natural language brief and filtering.
+**Task**: Discover available advertising products based on campaign requirements, using natural language briefs or structured filters.
 
 **Request:**
 ```json
diff --git a/docs/media-buy/index.md b/docs/media-buy/index.md
index dd7b9b8..3eeaf48 100644
--- a/docs/media-buy/index.md
+++ b/docs/media-buy/index.md
@@ -110,7 +110,7 @@ Running successful campaigns:
 ### Technical Reference
 Detailed implementation guidance:
 
-- **[API Reference](api-reference.md)** - Complete tool documentation with examples
+- **[API Reference](api-reference.md)** - Complete task documentation with examples
 - **[Design Decisions](design-decisions.md)** - Architectural choices and rationale
 
 ## Getting Started
diff --git a/docs/protocols/a2a.md b/docs/protocols/a2a.md
new file mode 100644
index 0000000..6f80879
--- /dev/null
+++ b/docs/protocols/a2a.md
@@ -0,0 +1,251 @@
+---
+sidebar_position: 3
+title: A2A Integration
+---
+
+# A2A (Agent2Agent) Integration
+
+AdCP's A2A integration enables rich agent-to-agent collaboration with native support for complex workflows.
+
+## Overview
+
+A2A is Google's protocol designed for agent communication. It provides task-based interactions with built-in support for:
+- Asynchronous operations
+- Real-time status updates
+- Human-in-the-loop workflows
+- Context preservation
+
+## How AdCP Tasks Work in A2A
+
+AdCP tasks map naturally to A2A's task model:
+
+```json
+// A2A Request
+{
+  "method": "message/send",
+  "params": {
+    "message": {
+      "parts": [{
+        "kind": "text",
+        "text": "Create a $50K CTV campaign for pet food"
+      }]
+    }
+  }
+}
+
+// A2A Response with Task
+{
+  "taskId": "task-mb-001",
+  "contextId": "ctx-campaign-123",
+  "status": { "state": "working" }
+}
+```
+
+## Status Updates via SSE
+
+A2A provides real-time updates through Server-Sent Events:
+
+```javascript
+// Client subscribes to updates
+const events = new EventSource('/a2a/tasks/task-mb-001/events');
+
+events.onmessage = (event) => {
+  const update = JSON.parse(event.data);
+  console.log(update.message);
+  // "Validating campaign parameters..."
+  // "Checking inventory availability..."
+  // "Creating in ad server..."
+};
+```
+
+## Context Management
+
+A2A's `contextId` maintains conversation state across interactions:
+
+```json
+// First interaction: Upload creative
+{
+  "message": {
+    "parts": [{
+      "kind": "text",
+      "text": "Upload creative for campaign"
+    }, {
+      "kind": "file",
+      "uri": "https://cdn.example.com/video.mp4"
+    }]
+  }
+}
+// Response includes contextId: "ctx-creative-456"
+
+// Second interaction: Request changes (same context)
+{
+  "contextId": "ctx-creative-456",
+  "message": {
+    "parts": [{
+      "kind": "text", 
+      "text": "Create a 15-second version"
+    }]
+  }
+}
+```
+
+## Human-in-the-Loop Workflows
+
+A2A handles HITL natively with task states:
+
+```json
+// Task enters pending_approval state
+{
+  "taskId": "task-mb-002",
+  "status": {
+    "state": "pending_approval",
+    "metadata": {
+      "approvalType": "budget_approval",
+      "reason": "Exceeds automatic approval threshold"
+    }
+  }
+}
+
+// Approver responds in same context
+{
+  "contextId": "ctx-campaign-123",
+  "message": {
+    "parts": [{
+      "kind": "text",
+      "text": "Approved - proceed with campaign"
+    }]
+  }
+}
+
+// Task resumes automatically
+{
+  "status": { "state": "working" },
+  "message": "Creating campaign with approved budget..."
+}
+```
+
+## Example: Complete Media Buy Flow
+
+```javascript
+// 1. Natural language request
+const task = await a2a.send({
+  message: {
+    parts: [{
+      kind: "text",
+      text: "I need a $100K connected TV campaign targeting sports fans in California"
+    }]
+  }
+});
+
+// 2. Receive streaming updates
+// "Analyzing your requirements..."
+// "Found 12 suitable CTV products"
+// "Optimizing budget allocation..."
+// "Pending compliance approval..."
+
+// 3. Handle approval in context
+await a2a.send({
+  contextId: task.contextId,
+  message: {
+    parts: [{
+      kind: "text",
+      text: "Approved by compliance team"
+    }]
+  }
+});
+
+// 4. Continue with creatives (same context)
+await a2a.send({
+  contextId: task.contextId,
+  message: {
+    parts: [{
+      kind: "text",
+      text: "Upload our hero creative"
+    }, {
+      kind: "file",
+      uri: "https://cdn.example.com/hero.mp4"
+    }]
+  }
+});
+```
+
+## Artifacts
+
+A2A returns structured results as artifacts:
+
+```json
+{
+  "status": { "state": "completed" },
+  "artifacts": [{
+    "name": "media_buy_confirmation",
+    "parts": [
+      {
+        "kind": "application/json",
+        "data": {
+          "media_buy_id": "mb_123",
+          "status": "active",
+          "packages": [...]
+        }
+      },
+      {
+        "kind": "application/pdf",
+        "uri": "https://contracts.example.com/io_123.pdf"
+      }
+    ]
+  }]
+}
+```
+
+## Best Practices
+
+1. **Leverage Context**: Use `contextId` for multi-step workflows
+2. **Subscribe to Updates**: Use SSE for real-time progress
+3. **Natural Language**: A2A works well with conversational requests
+4. **Handle All States**: Design for pending, working, and failed states
+
+## A2A-Specific Features
+
+### Push Notifications
+Configure webhooks for task updates:
+```json
+{
+  "configuration": {
+    "pushNotificationConfig": {
+      "url": "https://myapp.com/webhooks/a2a",
+      "token": "secure-token"
+    }
+  }
+}
+```
+
+### Multi-Modal Support
+A2A handles various content types:
+- Text instructions
+- File uploads (images, videos, PDFs)
+- Structured data (JSON)
+- Mixed content in single message
+
+### Agent Capabilities
+Agents advertise capabilities via Agent Cards:
+```json
+{
+  "name": "AdCP Media Buy Agent",
+  "skills": [
+    {
+      "name": "campaign_creation",
+      "examples": [
+        "Create a $50K CTV campaign",
+        "Launch a holiday audio campaign"
+      ]
+    }
+  ]
+}
+```
+
+## Advantages Over MCP
+
+- **Native Async**: No polling required
+- **Built-in HITL**: Task states handle approvals naturally
+- **Context Preservation**: Conversations maintain state
+- **Richer Interactions**: Multi-modal messages with files and data
+- **Real-time Updates**: SSE provides immediate feedback
\ No newline at end of file
diff --git a/docs/protocols/mcp.md b/docs/protocols/mcp.md
new file mode 100644
index 0000000..93bdb9b
--- /dev/null
+++ b/docs/protocols/mcp.md
@@ -0,0 +1,173 @@
+---
+sidebar_position: 2
+title: MCP Integration
+---
+
+# MCP (Model Context Protocol) Integration
+
+AdCP's MCP integration provides a direct interface for AI assistants to interact with advertising platforms.
+
+## Overview
+
+MCP is Anthropic's protocol designed for AI-to-application communication. In AdCP, MCP exposes tasks as tools that AI assistants can call directly.
+
+## How Tasks Map to MCP Tools
+
+Each AdCP task becomes an MCP tool:
+
+```javascript
+// AdCP Task
+create_media_buy
+
+// MCP Tool Definition
+{
+  "name": "create_media_buy",
+  "description": "Create a media buy from selected packages",
+  "parameters": {
+    "type": "object",
+    "properties": {
+      "packages": { "type": "array" },
+      "total_budget": { "type": "number" },
+      "targeting_overlay": { "type": "object" }
+    }
+  }
+}
+```
+
+## Synchronous vs Asynchronous Operations
+
+### Synchronous Operations
+Quick tasks return immediately:
+
+```json
+// Request
+{
+  "tool": "get_products",
+  "arguments": {
+    "brief": "Premium video inventory"
+  }
+}
+
+// Response (immediate)
+{
+  "products": [...]
+}
+```
+
+### Asynchronous Operations
+Long-running tasks return a task ID for polling:
+
+```json
+// Request
+{
+  "tool": "create_media_buy",
+  "arguments": {
+    "packages": ["pkg_123"],
+    "total_budget": 50000
+  }
+}
+
+// Response (immediate)
+{
+  "task_id": "task_456",
+  "status": "pending",
+  "poll_url": "/tasks/task_456"
+}
+```
+
+## Handling Human-in-the-Loop
+
+When human approval is required, MCP returns an error with task information:
+
+```json
+{
+  "error": {
+    "code": "PENDING_APPROVAL",
+    "message": "Campaign requires compliance approval",
+    "task_id": "task_789",
+    "poll_url": "/tasks/task_789"
+  }
+}
+```
+
+Clients must poll or register webhooks to track task completion.
+
+## Example: Media Buy Workflow
+
+```javascript
+// 1. Discover products
+const products = await mcp.call('get_products', {
+  brief: "Sports inventory for Nike",
+  filters: { formats: ["video"] }
+});
+
+// 2. Create media buy (async)
+const result = await mcp.call('create_media_buy', {
+  packages: products.slice(0, 3).map(p => p.product_id),
+  total_budget: 100000
+});
+
+// 3. Handle async response
+if (result.task_id) {
+  // Poll for completion
+  let status;
+  do {
+    await sleep(5000);
+    status = await fetch(result.poll_url);
+  } while (status.state === 'pending');
+}
+
+// 4. Add creatives
+await mcp.call('add_creative_assets', {
+  media_buy_id: result.media_buy_id,
+  assets: [...]
+});
+```
+
+## MCP-Specific Considerations
+
+### Error Handling
+MCP uses standard error responses:
+```json
+{
+  "error": {
+    "code": "INVALID_PARAMETER",
+    "message": "Budget must be positive",
+    "field": "total_budget"
+  }
+}
+```
+
+### Timeouts
+- Default timeout: 30 seconds for synchronous operations
+- Async operations return immediately with task ID
+- Long polling timeout: 60 seconds
+
+### Authentication
+MCP uses header-based authentication:
+```
+x-adcp-auth: Bearer <token>
+```
+
+## Best Practices
+
+1. **Use Async for Long Operations**: Operations that might take >5 seconds should be async
+2. **Handle Pending States**: Many operations require approval - handle these gracefully
+3. **Batch When Possible**: Use bulk operations to reduce round trips
+4. **Check Capabilities First**: Use `list_creative_formats` before uploading creatives
+
+## Limitations
+
+- No built-in streaming for status updates
+- Manual context management between calls
+- Polling required for async operations
+- Custom implementation needed for complex workflows
+
+## Migration from Direct API
+
+If migrating from a REST API:
+
+1. Wrap API calls in MCP tool handlers
+2. Convert webhooks to polling or MCP-compatible callbacks
+3. Map error codes to MCP error format
+4. Add tool descriptions for AI discovery
\ No newline at end of file
diff --git a/docs/protocols/overview.md b/docs/protocols/overview.md
new file mode 100644
index 0000000..0bf568a
--- /dev/null
+++ b/docs/protocols/overview.md
@@ -0,0 +1,91 @@
+---
+sidebar_position: 1
+title: Protocol Support
+---
+
+# Protocol Support
+
+AdCP is designed to work with multiple communication protocols, allowing implementers to choose the best fit for their use case. All AdCP tasks can be accessed through any supported protocol.
+
+## Supported Protocols
+
+### Model Context Protocol (MCP)
+
+MCP is Anthropic's protocol for AI-to-application communication. It provides:
+- Synchronous request/response model
+- Tool-based interactions
+- Simple integration with Claude and other AI assistants
+
+**Best for:**
+- Direct AI assistant integration
+- Simple request/response workflows
+- Existing MCP ecosystems
+
+**Learn more:** [MCP Integration Guide](./mcp.md)
+
+### Agent2Agent Protocol (A2A)
+
+A2A is Google's protocol for agent-to-agent communication. It provides:
+- Task-based asynchronous workflows
+- Native human-in-the-loop support
+- Real-time status updates via SSE
+- Context management across interactions
+
+**Best for:**
+- Complex multi-step workflows
+- Operations requiring approvals
+- Cross-agent collaboration
+- Long-running operations
+
+**Learn more:** [A2A Integration Guide](./a2a.md)
+
+### REST API (Coming Soon)
+
+Traditional REST endpoints for direct HTTP integration.
+
+**Best for:**
+- Simple integrations
+- Existing REST infrastructure
+- Direct API access
+
+## How It Works
+
+AdCP uses a task-first architecture where:
+
+1. **Core Tasks**: Business logic is implemented as tasks (e.g., `create_media_buy`, `get_signals`)
+2. **Protocol Adapters**: Thin translation layers expose tasks through different protocols
+3. **Consistent Behavior**: The same task works identically across all protocols
+
+```
+         ┌──────────┐ ┌──────────┐ ┌──────────┐
+         │   MCP    │ │   A2A    │ │   REST   │
+         │ Adapter  │ │ Adapter  │ │ Adapter  │
+         └────┬─────┘ └────┬─────┘ └────┬─────┘
+              └────────┬────┴────────────┘
+                       ▼
+              ┌─────────────────┐
+              │  AdCP Tasks     │
+              │                 │
+              │ • get_signals   │
+              │ • activate_signal│
+              │ • create_media_buy│
+              │ • add_creatives │
+              └─────────────────┘
+```
+
+## Choosing a Protocol
+
+| Feature | MCP | A2A | REST |
+|---------|-----|-----|------|
+| **Async Operations** | Polling | Native | Polling |
+| **Status Updates** | Manual | Streaming | Manual |
+| **Human-in-the-Loop** | Custom | Native | Custom |
+| **Context Management** | Manual | Automatic | Manual |
+| **Complexity** | Low | Medium | Low |
+
+## Implementation Notes
+
+- All protocols provide access to the same underlying tasks
+- Protocol choice doesn't affect functionality, only the interaction model
+- Implementers can support multiple protocols simultaneously
+- New protocols can be added without changing core task implementations
\ No newline at end of file
diff --git a/docs/signals/overview.md b/docs/signals/overview.md
index 8636322..26522da 100644
--- a/docs/signals/overview.md
+++ b/docs/signals/overview.md
@@ -41,16 +41,15 @@ Discover signals across multiple platforms in a single request:
 - **Devices**: Cookies and device IDs (largest reach)
 - **Households**: Unique households (B2B and family targeting)
 
-## The Four Essential Tools
+## Core Tasks
+
+The Signals Activation Protocol supports two primary tasks:
 
 ### 1. get_signals
-Discover signals based on your campaign needs across one or many platforms.
+**Task**: Discover signals based on your campaign needs across one or many platforms.
 
 ### 2. activate_signal  
-Turn on signals for specific platforms and accounts.
-
-### 3. check_signal_status
-Monitor activation progress and deployment status.
+**Task**: Activate signals for specific platforms and accounts. This task handles the complete activation lifecycle including progress monitoring and status updates.
 
 
 ## Use Cases
diff --git a/docs/signals/specification.md b/docs/signals/specification.md
index 804afe2..034396d 100644
--- a/docs/signals/specification.md
+++ b/docs/signals/specification.md
@@ -170,11 +170,13 @@ This is relative to each signal agent's capabilities - a 50% coverage signal fro
 - **Both**: Some signals offer choice between models
 - **Included**: No additional cost (e.g., with media buys)
 
-## Protocol Specification
+## Tasks
+
+The Signals Activation Protocol defines the following tasks that agents can perform:
 
 ### get_signals
 
-Discovers relevant signals based on a marketing specification across multiple platforms.
+**Task**: Discover relevant signals based on a marketing specification across multiple platforms.
 
 #### Request
 
@@ -272,7 +274,12 @@ Discovers relevant signals based on a marketing specification across multiple pl
 
 ### activate_signal
 
-Activates a signal for use on a specific platform/account.
+**Task**: Activate a signal for use on a specific platform/account.
+
+This task handles the entire activation lifecycle, including:
+- Initiating the activation request
+- Monitoring activation progress
+- Returning the final deployment status
 
 #### Request
 
@@ -286,37 +293,40 @@ Activates a signal for use on a specific platform/account.
 
 #### Response
 
+The task provides status updates as the activation progresses:
+
+**Initial Response** (immediate):
 ```json
 {
+  "task_id": "activation_12345",
+  "status": "pending",
   "decisioning_platform_segment_id": "pm_brand456_peer39_lux_auto",
   "estimated_activation_duration_minutes": 60
 }
 ```
 
-### check_signal_status
-
-Checks the deployment status of a signal on a decisioning platform.
-
-#### Request
-
+**Status Updates** (streamed or polled):
 ```json
 {
-  "signal_agent_segment_id": "peer39_luxury_auto",
-  "decisioning_platform": "index-exchange",
-  "account": "agency-123-ix"                // Optional - only for account-specific segments
+  "task_id": "activation_12345",
+  "status": "processing",
+  "message": "Validating signal access permissions..."
 }
 ```
 
-#### Response
-
+**Final Response** (when complete):
 ```json
 {
+  "task_id": "activation_12345",
   "status": "deployed",
-  "deployed_at": "2025-01-15T14:30:00Z"
+  "decisioning_platform_segment_id": "pm_brand456_peer39_lux_auto",
+  "deployed_at": "2025-01-15T14:30:00Z",
+  "message": "Signal successfully activated on PubMatic"
 }
 ```
 
 
+
 ## Typical Flow
 
 ### Data Provider Multi-Platform Flow (e.g., Peer39)
@@ -329,11 +339,9 @@ Checks the deployment status of a signal on a decisioning platform.
 
 4. **Activate**: For any platforms where signals aren't live, call `activate_signal`
 
-5. **Monitor**: Use `check_signal_status` to track activation progress
+5. **Launch**: Run campaigns across multiple SSPs using the platform-specific segment IDs
 
-6. **Launch**: Run campaigns across multiple SSPs using the platform-specific segment IDs
-
-7. **Report**: Report usage separately for each platform where the signal was used
+6. **Report**: Report usage separately for each platform where the signal was used
 
 ### Marketplace Signal Agent Flow
 
@@ -343,11 +351,9 @@ Checks the deployment status of a signal on a decisioning platform.
 
 3. **Commit**: Principal decides to proceed with specific signals for their media execution
 
-4. **Activate**: For account-specific segments that aren't live, call `activate_audience` to deploy from audience agent to decisioning platform
-
-5. **Monitor**: Use `check_signal_status` to track activation progress between agents
+4. **Activate**: For account-specific segments that aren't live, call `activate_signal` to deploy from signal agent to decisioning platform (the task handles monitoring progress automatically)
 
-6. **Launch**: Once deployed, launch the media execution (campaigns, PMPs, direct buys, etc.) on the decisioning platform using the activated signals
+5. **Launch**: Once deployed, launch the media execution (campaigns, PMPs, direct buys, etc.) on the decisioning platform using the activated signals
 
 
 ### Private Signal Agent Flow
@@ -358,11 +364,9 @@ Checks the deployment status of a signal on a decisioning platform.
 
 3. **Commit**: Principal decides to proceed with owned signals for their media execution
 
-4. **Activate**: If not live, call `activate_audience` for workflow orchestration from owned agent to decisioning platform
-
-5. **Monitor**: Use `check_signal_status` to track activation progress
+4. **Activate**: If not live, call `activate_signal` for workflow orchestration from owned agent to decisioning platform (the task handles monitoring progress automatically)
 
-6. **Launch**: Once deployed, launch the media execution using owned signals
+5. **Launch**: Once deployed, launch the media execution using owned signals
 
 
 ## Error Codes
diff --git a/examples/a2a-integration/creative-workflow-a2a.md b/examples/a2a-integration/creative-workflow-a2a.md
deleted file mode 100644
index 28be9d6..0000000
--- a/examples/a2a-integration/creative-workflow-a2a.md
+++ /dev/null
@@ -1,325 +0,0 @@
-# Creative Workflow with A2A Context Management
-
-This example shows how A2A's `contextId` perfectly handles the iterative nature of creative workflows in advertising.
-
-## The Workflow
-
-A typical creative workflow involves multiple steps:
-1. Initial creative upload
-2. Automated review and feedback
-3. Request for variations (different sizes, formats)
-4. Approval cycles
-5. Final asset delivery
-
-With A2A's context model, this becomes a natural conversation.
-
-## Complete Example: Adding Creatives to a Campaign
-
-### Step 1: Initial Creative Upload
-
-```json
-// Client sends creative
-{
-  "method": "message/send",
-  "params": {
-    "message": {
-      "role": "user",
-      "parts": [
-        {
-          "kind": "text",
-          "text": "Upload creative for the pet food campaign media buy mb_12345"
-        },
-        {
-          "kind": "file",
-          "uri": "https://cdn.agency.com/creatives/petfood_hero_30s.mp4",
-          "metadata": {
-            "filename": "petfood_hero_30s.mp4",
-            "mimeType": "video/mp4",
-            "duration": 30,
-            "dimensions": { "width": 1920, "height": 1080 }
-          }
-        }
-      ]
-    }
-  }
-}
-```
-
-### Step 2: Agent Response with Context
-
-```json
-// Agent creates task and establishes context
-{
-  "taskId": "task-creative-001",
-  "contextId": "ctx-creative-petfood-mb12345",  // Context for this creative workflow
-  "status": {
-    "state": "working"
-  },
-  "message": "Analyzing creative and checking policy compliance..."
-}
-
-// Status updates via SSE
-data: {"message": "✓ Duration check passed (30s)"}
-data: {"message": "✓ Resolution check passed (1920x1080)"}
-data: {"message": "✓ Audio levels within range"}
-data: {"message": "⚠️ Missing captions for accessibility"}
-
-// Final response
-{
-  "taskId": "task-creative-001",
-  "contextId": "ctx-creative-petfood-mb12345",
-  "status": {
-    "state": "completed"
-  },
-  "artifacts": [{
-    "artifactId": "art-creative-v1",
-    "name": "creative_analysis",
-    "parts": [{
-      "kind": "application/json",
-      "data": {
-        "creativeId": "creative_petfood_30s_v1",
-        "status": "approved_with_suggestions",
-        "analysis": {
-          "technical": "pass",
-          "policy": "pass",
-          "accessibility": "warning"
-        },
-        "suggestions": [
-          {
-            "type": "accessibility",
-            "priority": "high",
-            "description": "Add captions for hearing-impaired viewers",
-            "impact": "Required for some platforms"
-          },
-          {
-            "type": "optimization",
-            "priority": "medium",
-            "description": "Create 15s version for better inventory match",
-            "impact": "Could access 40% more inventory"
-          },
-          {
-            "type": "format",
-            "priority": "medium", 
-            "description": "Create vertical (9:16) version for mobile",
-            "impact": "Mobile inventory has 35% better performance"
-          }
-        ]
-      }
-    }]
-  }]
-}
-```
-
-### Step 3: Client Requests Variations (Same Context)
-
-```json
-// Client continues in same context
-{
-  "method": "message/send",
-  "params": {
-    "contextId": "ctx-creative-petfood-mb12345",  // Same context!
-    "referenceTaskIds": ["task-creative-001"],     // Reference previous task
-    "message": {
-      "role": "user",
-      "parts": [{
-        "kind": "text",
-        "text": "Please create the 15s version and add captions to both versions"
-      }]
-    }
-  }
-}
-```
-
-### Step 4: Agent Processes Request with Context
-
-```json
-// Agent has full context and can reference previous artifacts
-{
-  "taskId": "task-creative-002",
-  "contextId": "ctx-creative-petfood-mb12345",  // Maintains context
-  "status": {
-    "state": "working"
-  },
-  "message": "Creating variations based on your request..."
-}
-
-// Progress updates
-data: {"message": "Generating 15-second cut..."}
-data: {"message": "Identifying key moments for shorter version..."}
-data: {"message": "Adding captions to 30s version..."}
-data: {"message": "Adding captions to 15s version..."}
-data: {"message": "Validating all versions..."}
-
-// Completion with new artifacts
-{
-  "taskId": "task-creative-002",
-  "contextId": "ctx-creative-petfood-mb12345",
-  "status": {
-    "state": "completed"
-  },
-  "artifacts": [{
-    "artifactId": "art-creative-v2",
-    "name": "creative_package",
-    "parts": [
-      {
-        "kind": "file",
-        "uri": "https://cdn.publisher.com/processed/petfood_hero_30s_captioned.mp4",
-        "metadata": {
-          "creativeId": "creative_petfood_30s_v2",
-          "version": 2,
-          "duration": 30,
-          "hasCaptions": true,
-          "format": "video_standard_30s"
-        }
-      },
-      {
-        "kind": "file", 
-        "uri": "https://cdn.publisher.com/processed/petfood_hero_15s_captioned.mp4",
-        "metadata": {
-          "creativeId": "creative_petfood_15s_v1",
-          "version": 1,
-          "duration": 15,
-          "hasCaptions": true,
-          "format": "video_standard_15s"
-        }
-      }
-    ]
-  }],
-  "message": "Created 2 versions with captions. Both are ready for the campaign."
-}
-```
-
-### Step 5: Human Review Required (Same Context)
-
-```json
-// Something requires human review
-{
-  "taskId": "task-creative-003",
-  "contextId": "ctx-creative-petfood-mb12345",
-  "status": {
-    "state": "pending_review",
-    "metadata": {
-      "reviewType": "brand_safety",
-      "flaggedElement": "Background music similarity",
-      "reviewer": "legal@publisher.com"
-    }
-  },
-  "message": "Creative requires legal review due to potential music copyright concern",
-  "artifacts": [{
-    "name": "review_package",
-    "parts": [{
-      "kind": "application/json",
-      "data": {
-        "concern": "Background music has 87% similarity to copyrighted track",
-        "track": "Popular Song by Famous Artist",
-        "timestamp": "0:12-0:28",
-        "recommendation": "Replace audio track or obtain license"
-      }
-    }]
-  }]
-}
-```
-
-### Step 6: Approval/Resolution (Same Context)
-
-```json
-// Legal team responds in the same context
-{
-  "method": "message/send", 
-  "params": {
-    "contextId": "ctx-creative-petfood-mb12345",
-    "message": {
-      "role": "user",
-      "parts": [{
-        "kind": "text",
-        "text": "Approved - we have licensing rights for this track. Document attached.",
-      }, {
-        "kind": "file",
-        "uri": "https://legal.publisher.com/licenses/track_license_2024.pdf"
-      }]
-    }
-  }
-}
-
-// Agent continues with approval
-{
-  "taskId": "task-creative-004",
-  "contextId": "ctx-creative-petfood-mb12345",
-  "status": {
-    "state": "completed"
-  },
-  "message": "All creatives approved and assigned to media buy mb_12345",
-  "artifacts": [{
-    "name": "final_creative_assignment",
-    "parts": [{
-      "kind": "application/json",
-      "data": {
-        "mediaBuyId": "mb_12345",
-        "creatives": [
-          {
-            "creativeId": "creative_petfood_30s_v2",
-            "packageAssignments": ["pkg_ctv_premium"],
-            "status": "active"
-          },
-          {
-            "creativeId": "creative_petfood_15s_v1", 
-            "packageAssignments": ["pkg_ctv_standard", "pkg_mobile_video"],
-            "status": "active"
-          }
-        ],
-        "legalClearance": {
-          "status": "approved",
-          "documentId": "doc_license_456",
-          "approvedBy": "legal@publisher.com"
-        }
-      }
-    }]
-  }]
-}
-```
-
-## Why This Is Powerful
-
-### 1. **Natural Conversation Flow**
-The entire creative workflow happens in one context, like a conversation thread. No need to pass state between disconnected API calls.
-
-### 2. **Automatic State Management**
-The agent maintains the context - it knows which media buy, which creatives, what's been discussed.
-
-### 3. **Multi-Party Collaboration**
-Different users (creative team, legal, account manager) can all participate in the same context.
-
-### 4. **Audit Trail**
-The complete conversation history is maintained, perfect for compliance and debugging.
-
-### 5. **Flexible Workflow**
-Can handle unexpected paths (like legal review) without breaking the flow.
-
-## Comparison with MCP
-
-With MCP, this same workflow would require:
-
-```javascript
-// Multiple disconnected API calls
-const creative1 = await mcp.call('upload_creative', {...});
-const analysis = await mcp.call('analyze_creative', {creative_id: creative1.id});
-const variations = await mcp.call('create_variations', {
-  creative_id: creative1.id,
-  variations: ['15s', 'add_captions']
-});
-
-// If human review needed, must implement custom task system
-if (analysis.requires_review) {
-  const taskId = await mcp.call('create_review_task', {...});
-  // Poll or webhook for completion
-  // Lose conversational context
-}
-
-// Must manually thread IDs through each call
-const assignment = await mcp.call('assign_creatives', {
-  media_buy_id: 'mb_12345',
-  creative_ids: [creative1.id, ...variations.ids]
-});
-```
-
-With A2A, it's just a natural conversation in one context.
\ No newline at end of file
diff --git a/examples/a2a-integration/dual-protocol-agent.js b/examples/a2a-integration/dual-protocol-agent.js
deleted file mode 100644
index 3d5db36..0000000
--- a/examples/a2a-integration/dual-protocol-agent.js
+++ /dev/null
@@ -1,354 +0,0 @@
-/**
- * Proof of Concept: AdCP Agent with Dual Protocol Support (MCP + A2A)
- * 
- * This example shows how an AdCP Sales Agent could support both:
- * - MCP for tool-based interactions
- * - A2A for agent-to-agent communication
- */
-
-import express from 'express';
-import { MCPServer } from '@modelcontextprotocol/server';
-import { A2AServer } from '@a2a/server'; // Hypothetical A2A SDK
-
-class DualProtocolAdCPAgent {
-  constructor() {
-    this.app = express();
-    this.setupMCPServer();
-    this.setupA2AServer();
-    this.setupDiscovery();
-  }
-
-  /**
-   * MCP Server - Exposes tools for direct integration
-   */
-  setupMCPServer() {
-    this.mcpServer = new MCPServer({
-      name: 'AdCP Sales Agent',
-      version: '1.0.0',
-    });
-
-    // Register AdCP tools
-    this.mcpServer.tool('get_products', {
-      description: 'List available advertising products',
-      parameters: {
-        type: 'object',
-        properties: {
-          brief: { type: 'string' },
-          filters: { type: 'object' }
-        }
-      },
-      handler: async (params) => this.getProducts(params)
-    });
-
-    this.mcpServer.tool('create_media_buy', {
-      description: 'Create a media buy from selected packages',
-      parameters: {
-        type: 'object',
-        properties: {
-          packages: { type: 'array' },
-          total_budget: { type: 'number' },
-          targeting_overlay: { type: 'object' }
-        }
-      },
-      handler: async (params) => this.createMediaBuy(params)
-    });
-
-    // Mount MCP endpoint
-    this.app.use('/mcp', this.mcpServer.handler());
-  }
-
-  /**
-   * A2A Server - Enables agent-to-agent communication
-   */
-  setupA2AServer() {
-    this.a2aServer = new A2AServer({
-      agentCard: {
-        name: 'AdCP Sales Agent',
-        description: 'AI-powered media buying agent for programmatic advertising',
-        url: 'https://salesagent.example.com/a2a',
-        authentication: ['bearer'],
-        supportedInputFormats: ['text/plain', 'application/json'],
-        supportedOutputFormats: ['text/plain', 'application/json'],
-        skills: [
-          {
-            name: 'campaign_planning',
-            description: 'Plan and create advertising campaigns',
-            examples: [
-              'Create a $50K CTV campaign targeting sports fans',
-              'Plan a holiday campaign with audio and display'
-            ]
-          },
-          {
-            name: 'inventory_discovery', 
-            description: 'Find available advertising inventory',
-            examples: [
-              'What premium video inventory is available?',
-              'Find audio inventory for drive time'
-            ]
-          }
-        ]
-      }
-    });
-
-    // Handle A2A tasks
-    this.a2aServer.on('task', async (task) => {
-      return this.handleA2ATask(task);
-    });
-
-    // Mount A2A endpoint
-    this.app.use('/a2a', this.a2aServer.handler());
-  }
-
-  /**
-   * Discovery endpoints for both protocols
-   */
-  setupDiscovery() {
-    // AdCP discovery with A2A extension
-    this.app.get('/.well-known/adcp.json', (req, res) => {
-      res.json({
-        sales: {
-          mcp: 'https://salesagent.example.com/mcp',
-          a2a: 'https://salesagent.example.com/a2a'
-        }
-      });
-    });
-
-    // A2A Agent Card
-    this.app.get('/.well-known/agent.json', (req, res) => {
-      res.json(this.a2aServer.agentCard);
-    });
-  }
-
-  /**
-   * Handle A2A tasks by mapping to internal operations
-   */
-  async handleA2ATask(task) {
-    const { message } = task;
-    const intent = await this.parseIntent(message);
-
-    switch (intent.type) {
-      case 'inventory_search':
-        return this.handleInventorySearch(intent, task);
-      
-      case 'campaign_creation':
-        return this.handleCampaignCreation(intent, task);
-      
-      case 'performance_report':
-        return this.handlePerformanceReport(intent, task);
-      
-      default:
-        return this.handleGeneralQuery(message, task);
-    }
-  }
-
-  /**
-   * Example: Handle inventory search via A2A
-   */
-  async handleInventorySearch(intent, task) {
-    // Use the same logic as MCP tool
-    const products = await this.getProducts({
-      brief: intent.query,
-      filters: intent.filters
-    });
-
-    // Return A2A response with artifacts
-    return {
-      status: { state: 'completed' },
-      artifacts: [{
-        name: 'inventory_results',
-        parts: [{
-          kind: 'application/json',
-          data: products
-        }, {
-          kind: 'text',
-          text: `Found ${products.length} matching products:\n` +
-                products.map(p => `- ${p.name}: $${p.cpm} CPM`).join('\n')
-        }]
-      }]
-    };
-  }
-
-  /**
-   * Example: Handle campaign creation via A2A (async with updates)
-   */
-  async handleCampaignCreation(intent, task) {
-    const { taskId } = task;
-
-    // Send initial acknowledgment
-    await task.update({
-      status: { state: 'working' },
-      message: 'Analyzing campaign requirements...'
-    });
-
-    // Discover inventory
-    const products = await this.getProducts({
-      brief: intent.brief,
-      filters: { formats: intent.formats }
-    });
-
-    await task.update({
-      message: `Found ${products.length} suitable products. Creating media buy...`
-    });
-
-    // Create the media buy
-    const mediaBuy = await this.createMediaBuy({
-      packages: products.slice(0, 3).map(p => p.product_id),
-      total_budget: intent.budget,
-      targeting_overlay: intent.targeting
-    });
-
-    // Return completed task with results
-    return {
-      status: { state: 'completed' },
-      artifacts: [{
-        name: 'media_buy_confirmation',
-        parts: [{
-          kind: 'application/json',
-          data: mediaBuy
-        }, {
-          kind: 'text',
-          text: `Campaign created successfully!\n` +
-                `Media Buy ID: ${mediaBuy.media_buy_id}\n` +
-                `Status: ${mediaBuy.status}\n` +
-                `Next steps: ${mediaBuy.next_steps.join(', ')}`
-        }]
-      }]
-    };
-  }
-
-  /**
-   * Parse natural language or structured messages into intents
-   */
-  async parseIntent(message) {
-    // In production, this would use NLP or LLM
-    const text = message.parts[0]?.text || '';
-    
-    if (text.includes('inventory') || text.includes('available')) {
-      return { 
-        type: 'inventory_search',
-        query: text,
-        filters: this.extractFilters(text)
-      };
-    }
-    
-    if (text.includes('create') || text.includes('campaign')) {
-      return {
-        type: 'campaign_creation',
-        brief: text,
-        budget: this.extractBudget(text),
-        formats: this.extractFormats(text),
-        targeting: this.extractTargeting(text)
-      };
-    }
-
-    return { type: 'general', query: text };
-  }
-
-  /**
-   * Core business logic (shared between protocols)
-   */
-  async getProducts(params) {
-    // Implementation would connect to actual ad platforms
-    return [
-      {
-        product_id: 'ctv_premium_sports',
-        name: 'Connected TV - Sports Premium',
-        description: 'Premium CTV inventory on sports content',
-        formats: [{ format_id: 'video_standard', name: 'Standard Video' }],
-        cpm: 45.00,
-        min_spend: 10000,
-        brief_relevance: 'Matches sports audience request'
-      },
-      // ... more products
-    ];
-  }
-
-  async createMediaBuy(params) {
-    // Implementation would create actual campaigns
-    return {
-      media_buy_id: 'mb_' + Date.now(),
-      status: 'pending_activation',
-      creative_deadline: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
-      detail: 'Media buy created successfully',
-      next_steps: [
-        'Upload creative assets before deadline',
-        'Assets will be reviewed by ad server',
-        'Campaign will auto-activate after approval'
-      ]
-    };
-  }
-
-  // Helper methods
-  extractBudget(text) {
-    const match = text.match(/\$?([\d,]+)k?/i);
-    if (match) {
-      const value = parseFloat(match[1].replace(/,/g, ''));
-      return text.toLowerCase().includes('k') ? value * 1000 : value;
-    }
-    return 50000; // default
-  }
-
-  extractFormats(text) {
-    const formats = [];
-    if (text.includes('video') || text.includes('ctv')) formats.push('video');
-    if (text.includes('audio')) formats.push('audio');
-    if (text.includes('display')) formats.push('display');
-    return formats.length ? formats : ['video'];
-  }
-
-  extractTargeting(text) {
-    // Simple extraction - in production would be more sophisticated
-    const targeting = {};
-    
-    if (text.includes('sports')) {
-      targeting.content_category_any_of = ['IAB17']; // Sports
-    }
-    
-    const geoMatch = text.match(/in (\w+)/i);
-    if (geoMatch) {
-      targeting.geo_region_any_of = [geoMatch[1].toUpperCase()];
-    }
-    
-    return targeting;
-  }
-
-  start(port = 3000) {
-    this.app.listen(port, () => {
-      console.log(`Dual-protocol AdCP agent running on port ${port}`);
-      console.log(`- MCP endpoint: http://localhost:${port}/mcp`);
-      console.log(`- A2A endpoint: http://localhost:${port}/a2a`);
-      console.log(`- Discovery: http://localhost:${port}/.well-known/adcp.json`);
-      console.log(`- Agent Card: http://localhost:${port}/.well-known/agent.json`);
-    });
-  }
-}
-
-// Start the server
-const agent = new DualProtocolAdCPAgent();
-agent.start();
-
-/**
- * Example usage from different clients:
- * 
- * 1. MCP Client (current AdCP orchestrators):
- *    POST /mcp
- *    {
- *      "method": "get_products",
- *      "params": { "brief": "sports inventory" }
- *    }
- * 
- * 2. A2A Client (any A2A-compatible agent):
- *    POST /a2a
- *    {
- *      "jsonrpc": "2.0",
- *      "method": "message/send",
- *      "params": {
- *        "message": {
- *          "parts": [{ 
- *            "kind": "text", 
- *            "text": "Find sports inventory for a $50K campaign"
- *          }]
- *        }
- *      }
- *    }
- */
\ No newline at end of file
diff --git a/examples/a2a-integration/hitl-comparison.js b/examples/a2a-integration/hitl-comparison.js
deleted file mode 100644
index 8c0c812..0000000
--- a/examples/a2a-integration/hitl-comparison.js
+++ /dev/null
@@ -1,378 +0,0 @@
-/**
- * Comparison: Human-in-the-Loop Implementation
- * 
- * Shows how A2A's native Task model simplifies HITL compared to 
- * implementing it on top of MCP
- */
-
-// ============================================
-// CURRENT: MCP-based HITL (Complex)
-// ============================================
-
-class MCPBasedHITL {
-  constructor() {
-    // Need to build our own task management
-    this.tasks = new Map();
-    this.webhooks = new Map();
-  }
-
-  async createMediaBuy(params) {
-    try {
-      // Try to create
-      const result = await this.adServer.createCampaign(params);
-      return result;
-    } catch (error) {
-      if (error.code === 'APPROVAL_REQUIRED') {
-        // Need to create our own task system
-        const taskId = this.generateTaskId();
-        
-        // Store task state
-        this.tasks.set(taskId, {
-          id: taskId,
-          type: 'media_buy_approval',
-          status: 'pending',
-          params: params,
-          created: new Date()
-        });
-
-        // Send webhook notification
-        await this.notifyApprover(taskId);
-
-        // Return error with task ID
-        return {
-          error: {
-            code: 'PENDING_APPROVAL',
-            message: 'Manual approval required',
-            task_id: taskId,
-            // Client must poll or register webhook
-            poll_url: `/tasks/${taskId}/status`
-          }
-        };
-      }
-      throw error;
-    }
-  }
-
-  // Need separate endpoints for task management
-  async getTaskStatus(taskId) {
-    const task = this.tasks.get(taskId);
-    if (!task) throw new Error('Task not found');
-    return task;
-  }
-
-  async approveTask(taskId, approver) {
-    const task = this.tasks.get(taskId);
-    if (!task) throw new Error('Task not found');
-    
-    // Update task
-    task.status = 'approved';
-    task.approvedBy = approver;
-    
-    // Execute the original operation
-    const result = await this.adServer.createCampaign(task.params);
-    
-    // Notify webhook if registered
-    const webhook = this.webhooks.get(taskId);
-    if (webhook) {
-      await fetch(webhook.url, {
-        method: 'POST',
-        body: JSON.stringify({ taskId, status: 'completed', result })
-      });
-    }
-    
-    return result;
-  }
-}
-
-// ============================================
-// NEW: A2A-based HITL (Native)
-// ============================================
-
-class A2ABasedHITL {
-  async handleMediaBuyTask(message, task) {
-    const params = this.parseParams(message);
-    
-    // Update task status as we progress
-    await task.update({
-      status: { state: 'working' },
-      message: 'Validating campaign parameters...'
-    });
-
-    // Check if approval needed
-    const validation = await this.validateCampaign(params);
-    
-    if (validation.requiresApproval) {
-      // A2A handles this natively
-      await task.update({
-        status: { 
-          state: 'pending_approval',
-          metadata: {
-            approvalType: 'compliance',
-            reason: validation.reason,
-            approver: 'compliance@agency.com'
-          }
-        },
-        message: `Campaign requires ${validation.approvalType} approval`,
-        // Client can subscribe to updates
-        pushNotificationConfig: {
-          url: message.configuration?.pushNotificationConfig?.url
-        }
-      });
-
-      // Task is now in pending state
-      // A2A protocol handles:
-      // - State persistence
-      // - Status queries
-      // - Update notifications
-      // - Context preservation
-      
-      // When approved (via separate A2A message or webhook)
-      // the task continues in the same context
-      return;
-    }
-
-    // If no approval needed, continue
-    await task.update({
-      message: 'Creating campaign in ad server...'
-    });
-
-    const result = await this.adServer.createCampaign(params);
-
-    // Return completed task with artifacts
-    return {
-      status: { state: 'completed' },
-      artifacts: [{
-        name: 'media_buy_confirmation',
-        parts: [{
-          kind: 'application/json',
-          data: result
-        }]
-      }]
-    };
-  }
-
-  // Approval is just another A2A message in the same context
-  async handleApprovalMessage(message, task) {
-    const { contextId, referenceTaskIds } = message;
-    
-    // Find the pending task in this context
-    const pendingTask = await this.findPendingTask(contextId, referenceTaskIds);
-    
-    if (message.parts[0].text.includes('approved')) {
-      // Continue the original task
-      await pendingTask.update({
-        status: { state: 'working' },
-        message: 'Approval received, creating campaign...'
-      });
-      
-      // Execute the campaign
-      const result = await this.adServer.createCampaign(pendingTask.params);
-      
-      // Complete with result
-      await pendingTask.update({
-        status: { state: 'completed' },
-        artifacts: [{
-          name: 'media_buy_confirmation',
-          parts: [{
-            kind: 'application/json',
-            data: result
-          }]
-        }]
-      });
-    } else {
-      // Rejection
-      await pendingTask.update({
-        status: { 
-          state: 'failed',
-          error: {
-            code: 'APPROVAL_REJECTED',
-            message: 'Campaign rejected by approver'
-          }
-        }
-      });
-    }
-  }
-}
-
-// ============================================
-// USAGE COMPARISON
-// ============================================
-
-// MCP: Complex polling/webhook pattern
-const mcpClient = {
-  async createCampaignWithApproval() {
-    // 1. Try to create
-    const response = await mcp.call('create_media_buy', params);
-    
-    if (response.error?.code === 'PENDING_APPROVAL') {
-      // 2. Register webhook or start polling
-      const taskId = response.error.task_id;
-      
-      // Option A: Polling
-      while (true) {
-        const status = await fetch(`/tasks/${taskId}/status`);
-        if (status.status !== 'pending') break;
-        await sleep(5000);
-      }
-      
-      // Option B: Webhook
-      await fetch('/webhooks/register', {
-        method: 'POST',
-        body: JSON.stringify({
-          task_id: taskId,
-          url: 'https://myapp.com/webhooks/task-updates'
-        })
-      });
-    }
-  }
-};
-
-// A2A: Native task handling
-const a2aClient = {
-  async createCampaignWithApproval() {
-    // 1. Send message (with optional notification URL)
-    const response = await a2a.send({
-      message: {
-        parts: [{
-          kind: 'text',
-          text: 'Create $100K CTV campaign for pet food'
-        }]
-      },
-      configuration: {
-        pushNotificationConfig: {
-          url: 'https://myapp.com/a2a/notifications'
-        }
-      }
-    });
-
-    // 2. A2A handles everything
-    // - Returns task with status
-    // - Streams updates via SSE if connected
-    // - Sends webhook notifications if configured
-    // - Maintains context for follow-ups
-    
-    // 3. Can check status anytime
-    const status = await a2a.getTask(response.taskId);
-    
-    // 4. Can continue in same context
-    if (status.state === 'pending_approval') {
-      // Approver can respond in same context
-      await a2a.send({
-        contextId: response.contextId,
-        message: {
-          parts: [{ kind: 'text', text: 'Approved' }]
-        }
-      });
-    }
-  }
-};
-
-// ============================================
-// REAL EXAMPLE: Creative Review Workflow
-// ============================================
-
-class CreativeReviewWorkflow {
-  async handleCreativeSubmission(message, task) {
-    const { contextId } = task;
-    
-    // Extract creative from message
-    const creative = message.parts.find(p => p.kind === 'file');
-    
-    await task.update({
-      status: { state: 'working' },
-      message: 'Analyzing creative for policy compliance...'
-    });
-
-    // Run automated checks
-    const autoReview = await this.runAutomatedChecks(creative);
-    
-    await task.update({
-      message: `Automated checks: ${autoReview.passed ? 'Passed' : 'Failed'}`,
-      artifacts: [{
-        name: 'automated_review',
-        parts: [{
-          kind: 'application/json',
-          data: autoReview
-        }]
-      }]
-    });
-
-    if (!autoReview.passed || autoReview.requiresHumanReview) {
-      // Need human review
-      await task.update({
-        status: { 
-          state: 'pending_review',
-          metadata: {
-            reviewType: 'creative_policy',
-            autoReviewResult: autoReview,
-            assignedTo: 'creative-review@publisher.com'
-          }
-        },
-        message: 'Creative requires human review',
-        // Include preview for reviewer
-        artifacts: [{
-          name: 'review_package',
-          parts: [
-            { kind: 'file', uri: creative.uri },
-            { kind: 'application/json', data: autoReview }
-          ]
-        }]
-      });
-      
-      // Task pauses here naturally
-      // Reviewer can respond in same context with approval/rejection
-      return;
-    }
-
-    // Auto-approved
-    await this.approveCreative(creative, task);
-  }
-
-  async handleReviewerResponse(message, task) {
-    const { contextId, referenceTaskIds } = message;
-    const decision = this.parseDecision(message);
-    
-    if (decision.approved) {
-      await task.update({
-        status: { state: 'working' },
-        message: 'Creative approved, generating variations...'
-      });
-      
-      // Generate required formats
-      const variations = await this.generateVariations(task.originalCreative);
-      
-      await task.update({
-        status: { state: 'completed' },
-        message: 'Creative approved and variations generated',
-        artifacts: [{
-          name: 'approved_creatives',
-          parts: variations.map(v => ({
-            kind: 'file',
-            uri: v.uri,
-            metadata: { format: v.format }
-          }))
-        }]
-      });
-    } else {
-      await task.update({
-        status: { state: 'rejected' },
-        message: `Creative rejected: ${decision.reason}`,
-        metadata: {
-          rejectionReason: decision.reason,
-          suggestedChanges: decision.suggestions
-        }
-      });
-    }
-  }
-}
-
-/**
- * Key Advantages of A2A for HITL:
- * 
- * 1. **Native Status Model**: pending_approval, pending_review are first-class states
- * 2. **Context Preservation**: Approvals happen in the same conversation context
- * 3. **No Polling Required**: SSE provides real-time updates
- * 4. **Simpler Implementation**: No need to build task management infrastructure
- * 5. **Better UX**: Natural conversation flow for multi-step processes
- * 6. **Audit Trail**: Task history maintained automatically
- */
\ No newline at end of file
diff --git a/examples/task-first/simple-task-implementation.js b/examples/task-first/simple-task-implementation.js
deleted file mode 100644
index 751d9dd..0000000
--- a/examples/task-first/simple-task-implementation.js
+++ /dev/null
@@ -1,250 +0,0 @@
-/**
- * Example: Implementing an AdCP Task
- * 
- * This shows how simple it is for developers to implement AdCP functionality
- * when using the task-first architecture. No protocol knowledge required!
- */
-
-// ==============================================
-// What developers implement (just business logic)
-// ==============================================
-
-class InventoryDiscoveryTask {
-  async execute(input, ctx) {
-    // Parse the input
-    const { brief, filters = {} } = input;
-    
-    // Let users know what's happening
-    await ctx.updateStatus('Analyzing your requirements...');
-    
-    // Extract intent from brief if provided
-    if (brief) {
-      const intent = await this.analyzeBrief(brief);
-      await ctx.updateStatus(`Looking for ${intent.type} inventory...`);
-      
-      // Merge with explicit filters
-      filters.formats = filters.formats || intent.suggestedFormats;
-      filters.targeting = { ...intent.targeting, ...filters.targeting };
-    }
-    
-    // Search inventory
-    await ctx.setProgress(25, 'Searching across platforms...');
-    const results = await this.searchInventory(filters);
-    
-    await ctx.setProgress(50, `Found ${results.length} products`);
-    
-    // Score and rank results
-    await ctx.updateStatus('Ranking by relevance and performance...');
-    const scored = await this.scoreResults(results, brief);
-    
-    await ctx.setProgress(75, 'Preparing recommendations...');
-    
-    // Prepare response
-    const recommendations = scored.slice(0, 10).map(product => ({
-      ...product,
-      recommendation: this.generateRecommendation(product, brief)
-    }));
-    
-    // Add artifacts
-    await ctx.addArtifact({
-      name: 'inventory_recommendations',
-      type: 'application/json',
-      data: {
-        query: { brief, filters },
-        total_found: results.length,
-        products: recommendations
-      }
-    });
-    
-    // Add human-readable summary
-    await ctx.addArtifact({
-      name: 'summary',
-      type: 'text/plain',
-      data: this.generateSummary(recommendations, brief)
-    });
-    
-    // Complete the task
-    await ctx.complete();
-  }
-  
-  // Business logic methods
-  async analyzeBrief(brief) {
-    // NLP or LLM analysis
-    return {
-      type: 'video',
-      suggestedFormats: ['video_standard_30s'],
-      targeting: { content_categories: ['sports'] }
-    };
-  }
-  
-  async searchInventory(filters) {
-    // Query inventory systems
-    return [/* products */];
-  }
-  
-  async scoreResults(results, brief) {
-    // Rank by relevance
-    return results.sort((a, b) => b.score - a.score);
-  }
-  
-  generateRecommendation(product, brief) {
-    return `Recommended because: ${product.match_reason}`;
-  }
-  
-  generateSummary(products, brief) {
-    return `Found ${products.length} products matching "${brief}":\n` +
-           products.map(p => `- ${p.name}: $${p.cpm} CPM`).join('\n');
-  }
-}
-
-// ==============================================
-// Another example: Creative Review Task
-// ==============================================
-
-class CreativeReviewTask {
-  async execute(input, ctx) {
-    const { creativeUrl, mediaBuyId } = input;
-    
-    // Download and analyze
-    await ctx.updateStatus('Downloading creative...');
-    const creative = await this.downloadCreative(creativeUrl);
-    
-    await ctx.updateStatus('Running automated checks...');
-    await ctx.setProgress(20);
-    
-    // Technical validation
-    const technical = await this.validateTechnical(creative);
-    await ctx.setProgress(40);
-    
-    // Policy check
-    const policy = await this.checkPolicy(creative);
-    await ctx.setProgress(60);
-    
-    // Brand safety
-    const brandSafety = await this.checkBrandSafety(creative);
-    await ctx.setProgress(80);
-    
-    // Compile results
-    const review = {
-      technical,
-      policy,
-      brandSafety,
-      overallStatus: this.determineStatus(technical, policy, brandSafety)
-    };
-    
-    // Add review artifact
-    await ctx.addArtifact({
-      name: 'creative_review',
-      type: 'application/json',
-      data: review
-    });
-    
-    // Need human review?
-    if (review.overallStatus === 'needs_human_review') {
-      await ctx.setState('pending_approval');
-      await ctx.requestApproval({
-        type: 'creative_review',
-        reason: review.flaggedIssues[0],
-        details: review
-      });
-      
-      // When resumed after approval, continue...
-    }
-    
-    // Auto-approved or human-approved
-    if (review.overallStatus === 'approved' || ctx.task.state === 'working') {
-      await ctx.updateStatus('Generating format variations...');
-      
-      const variations = await this.generateVariations(creative);
-      
-      await ctx.addArtifact({
-        name: 'creative_package',
-        type: 'application/json',
-        data: {
-          original: creative.id,
-          variations: variations,
-          assignedTo: mediaBuyId
-        }
-      });
-    }
-    
-    await ctx.complete();
-  }
-  
-  async downloadCreative(url) {
-    // Download logic
-  }
-  
-  async validateTechnical(creative) {
-    // Check format, duration, resolution, etc.
-    return { status: 'pass', details: {} };
-  }
-  
-  async checkPolicy(creative) {
-    // Check against ad policies
-    return { status: 'pass', details: {} };
-  }
-  
-  async checkBrandSafety(creative) {
-    // Brand safety checks
-    return { status: 'warning', issues: ['music_similarity'] };
-  }
-  
-  determineStatus(technical, policy, brandSafety) {
-    if (technical.status === 'fail' || policy.status === 'fail') {
-      return 'rejected';
-    }
-    if (brandSafety.status === 'warning') {
-      return 'needs_human_review';
-    }
-    return 'approved';
-  }
-  
-  async generateVariations(creative) {
-    // Create different sizes/formats
-    return [
-      { format: '16:9', url: '...' },
-      { format: '9:16', url: '...' },
-      { format: '1:1', url: '...' }
-    ];
-  }
-}
-
-// ==============================================
-// Task Registry (Framework provides this)
-// ==============================================
-
-const taskRegistry = {
-  'inventory_discovery': InventoryDiscoveryTask,
-  'creative_review': CreativeReviewTask,
-  'media_buy': MediaBuyTask,
-  'performance_report': PerformanceReportTask
-};
-
-// ==============================================
-// That's it! Developers just implement tasks.
-// The framework handles:
-// - Protocol translation (MCP/A2A/REST/etc)
-// - State management
-// - Status delivery
-// - Error handling
-// - Context persistence
-// - Event streaming
-// ==============================================
-
-/**
- * Benefits for developers:
- * 
- * 1. No protocol knowledge needed
- * 2. Clear, simple interface (execute method)
- * 3. Built-in status/progress/HITL support
- * 4. Focus on business logic only
- * 5. Testable without protocol overhead
- * 
- * The same task automatically works with:
- * - MCP clients (sync or async)
- * - A2A agents (with streaming)
- * - REST APIs
- * - GraphQL
- * - Future protocols
- */
\ No newline at end of file
diff --git a/sidebars.ts b/sidebars.ts
index da97c2c..859a90e 100644
--- a/sidebars.ts
+++ b/sidebars.ts
@@ -15,6 +15,15 @@ import type {SidebarsConfig} from '@docusaurus/plugin-content-docs';
 const sidebars: SidebarsConfig = {
   tutorialSidebar: [
     'intro',
+    {
+      type: 'category',
+      label: 'Protocols',
+      items: [
+        'protocols/overview',
+        'protocols/mcp',
+        'protocols/a2a',
+      ],
+    },
     {
       type: 'category',
       label: 'Signals',
-- 
2.39.5 (Apple Git-154)

