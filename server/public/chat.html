<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat with Addie - Agentic Advertising</title>
  <link rel="icon" type="image/svg+xml" href="/AAo.svg">
  <link rel="stylesheet" href="/design-system.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-family-sans);
      background: var(--color-bg-page);
      color: var(--color-text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 800px;
      margin: 0 auto;
      width: 100%;
      padding: 0 16px;
    }

    .chat-header {
      text-align: center;
      padding: 32px 16px;
      border-bottom: 1px solid var(--color-border);
      background: var(--color-bg-card);
      margin: 0 -16px;
      padding-left: 32px;
      padding-right: 32px;
    }

    .chat-header h1 {
      font-size: 24px;
      font-weight: 600;
      color: var(--color-text-heading);
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }

    .chat-header h1 .addie-avatar {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, var(--color-brand) 0%, var(--color-primary-600) 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    .chat-header p {
      color: var(--color-text-secondary);
      font-size: 14px;
    }

    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 24px 0;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .message {
      display: flex;
      gap: 12px;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .message--user {
      flex-direction: row-reverse;
    }

    .message-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }

    .message--assistant .message-avatar {
      background: linear-gradient(135deg, var(--color-brand) 0%, var(--color-primary-600) 100%);
    }

    .message--user .message-avatar {
      background: var(--color-gray-200);
    }

    .message-content {
      max-width: 70%;
      padding: 12px 16px;
      border-radius: 16px;
      line-height: 1.5;
      font-size: 14px;
    }

    .message--assistant .message-content {
      background: var(--color-bg-card);
      border: 1px solid var(--color-border);
      border-radius: 16px 16px 16px 4px;
    }

    .message--user .message-content {
      background: var(--color-brand);
      color: white;
      border-radius: 16px 16px 4px 16px;
    }

    .message-content p {
      margin-bottom: 8px;
    }

    .message-content p:last-child {
      margin-bottom: 0;
    }

    .message-content code {
      background: var(--color-bg-subtle);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: var(--font-family-mono);
      font-size: 13px;
    }

    .message--user .message-content code {
      background: rgba(255, 255, 255, 0.2);
    }

    .message-content pre {
      background: var(--color-gray-900);
      color: var(--color-gray-100);
      padding: 12px;
      border-radius: 8px;
      overflow-x: auto;
      margin: 8px 0;
    }

    .message-content pre code {
      background: none;
      padding: 0;
      color: inherit;
    }

    .message-content a {
      color: var(--color-brand);
      text-decoration: underline;
    }

    .message--user .message-content a {
      color: white;
    }

    /* Image support */
    .message-content img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      margin: 8px 0;
      display: block;
    }

    .message-content img:hover {
      cursor: pointer;
    }

    /* iframe support for creative previews */
    .message-content .creative-preview-container {
      position: relative;
      width: 100%;
      margin: 12px 0;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--color-border);
      background: var(--color-bg-subtle);
    }

    .message-content .creative-preview-container iframe {
      width: 100%;
      min-height: 200px;
      border: none;
      display: block;
    }

    .message-content .creative-preview-label {
      font-size: 11px;
      color: var(--color-text-muted);
      padding: 4px 8px;
      background: var(--color-bg-card);
      border-top: 1px solid var(--color-border);
    }

    /* Inline HTML creative container */
    .message-content .creative-html-container {
      margin: 12px 0;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--color-border);
      background: white;
      padding: 16px;
    }

    /* Member cards from search results */
    .member-cards-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 12px;
      margin: 12px 0;
    }

    .member-card {
      background: var(--color-bg-card);
      border: 1px solid var(--color-border);
      border-radius: 12px;
      padding: 16px;
      text-decoration: none;
      color: inherit;
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: all 0.2s;
    }

    .member-card:hover {
      border-color: var(--color-brand);
      box-shadow: 0 4px 12px rgba(26, 54, 180, 0.1);
      transform: translateY(-2px);
    }

    .member-card-header {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .member-card-logo {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      object-fit: contain;
      background: var(--color-bg-subtle);
      flex-shrink: 0;
    }

    .member-card-logo-placeholder {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      background: linear-gradient(135deg, var(--color-brand) 0%, var(--color-primary-600) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 18px;
      flex-shrink: 0;
    }

    .member-card-title {
      flex: 1;
      min-width: 0;
    }

    .member-card-name {
      font-weight: 600;
      font-size: 15px;
      color: var(--color-text-heading);
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .member-card-tagline {
      font-size: 13px;
      color: var(--color-text-secondary);
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .member-card-description {
      font-size: 13px;
      color: var(--color-text-secondary);
      line-height: 1.4;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      margin: 0;
    }

    .member-card-offerings {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }

    .member-card-offering {
      font-size: 11px;
      padding: 2px 8px;
      background: var(--color-primary-50, #eef2ff);
      color: var(--color-brand);
      border-radius: 12px;
      white-space: nowrap;
    }

    .member-card-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: auto;
      padding-top: 8px;
      border-top: 1px solid var(--color-border);
    }

    .member-card-location {
      font-size: 12px;
      color: var(--color-text-muted);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .member-card-cta {
      font-size: 12px;
      color: var(--color-brand);
      font-weight: 500;
    }

    @media (max-width: 600px) {
      .member-cards-container {
        grid-template-columns: 1fr;
      }
    }

    .message-content ul, .message-content ol {
      margin: 8px 0;
      padding-left: 20px;
    }

    .message-content li {
      margin-bottom: 4px;
    }

    .typing-indicator {
      display: flex;
      gap: 4px;
      padding: 8px 0;
    }

    .typing-indicator span {
      width: 8px;
      height: 8px;
      background: var(--color-text-muted);
      border-radius: 50%;
      animation: bounce 1.4s ease-in-out infinite;
    }

    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes bounce {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-4px); }
    }

    /* Streaming cursor animation */
    .streaming-cursor {
      display: inline-block;
      animation: blink 0.7s infinite;
      color: var(--color-brand);
      font-weight: bold;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .chat-input-container {
      padding: 16px 0 24px;
      border-top: 1px solid var(--color-border);
      background: var(--color-bg-page);
    }

    .chat-input-wrapper {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .chat-input {
      flex: 1;
      padding: 12px 16px;
      border: 1px solid var(--color-border);
      border-radius: 24px;
      font-size: 14px;
      font-family: inherit;
      background: var(--color-bg-card);
      color: var(--color-text);
      resize: none;
      min-height: 48px;
      max-height: 200px;
      line-height: 1.5;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .chat-input:focus {
      outline: none;
      border-color: var(--color-brand);
      box-shadow: 0 0 0 3px var(--color-primary-100);
    }

    .chat-input::placeholder {
      color: var(--color-text-muted);
    }

    .send-button {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: none;
      background: var(--color-brand);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, transform 0.1s;
      flex-shrink: 0;
    }

    .send-button:hover:not(:disabled) {
      background: var(--color-brand-hover);
    }

    .send-button:active:not(:disabled) {
      transform: scale(0.95);
    }

    .send-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .send-button svg {
      width: 20px;
      height: 20px;
    }

    .suggested-prompts {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
    }

    .suggested-prompt {
      padding: 8px 16px;
      background: var(--color-bg-card);
      border: 1px solid var(--color-border);
      border-radius: 20px;
      font-size: 13px;
      color: var(--color-text-secondary);
      cursor: pointer;
      transition: all 0.2s;
    }

    .suggested-prompt:hover {
      background: var(--color-bg-subtle);
      border-color: var(--color-brand);
      color: var(--color-brand);
    }

    .welcome-message {
      text-align: center;
      padding: 48px 24px;
      color: var(--color-text-secondary);
    }

    .welcome-message h2 {
      font-size: 20px;
      font-weight: 600;
      color: var(--color-text-heading);
      margin-bottom: 8px;
    }

    .welcome-message p {
      margin-bottom: 24px;
    }

    /* Addie Home Section */
    .addie-home-container {
      display: none;
      padding: 16px 0;
    }

    .addie-home-container.visible {
      display: block;
    }

    .addie-home-loading {
      text-align: center;
      padding: 24px;
      color: var(--color-text-muted);
    }

    .addie-home-error {
      text-align: center;
      padding: 16px;
      color: var(--color-error-600);
      background: var(--color-error-50);
      border-radius: var(--radius-lg);
      margin-bottom: 16px;
    }

    .error-toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--color-error-600);
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 14px;
      box-shadow: var(--shadow-lg);
      z-index: 1000;
      animation: slideUp 0.3s ease;
    }

    @keyframes slideUp {
      from { opacity: 0; transform: translate(-50%, 20px); }
      to { opacity: 1; transform: translate(-50%, 0); }
    }

    /* Impersonation banner */
    .impersonation-banner {
      background: var(--color-warning-100);
      border-bottom: 2px solid var(--color-warning-500);
      padding: 12px 16px;
      text-align: center;
      font-size: 14px;
      color: var(--color-warning-800);
      display: none;
    }

    .impersonation-banner.active {
      display: block;
    }

    .impersonation-banner strong {
      font-weight: 600;
    }

    .impersonation-banner .reason {
      font-style: italic;
      color: var(--color-warning-700);
    }

    /* Status indicator */
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--color-text-muted);
      margin-top: 8px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--color-success-500);
    }

    .status-dot--offline {
      background: var(--color-error-500);
    }

    /* Feedback controls */
    .message-feedback {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--color-border);
      font-size: 12px;
    }

    .feedback-label {
      color: var(--color-text-muted);
    }

    .feedback-buttons {
      display: flex;
      gap: 4px;
    }

    .feedback-btn {
      background: none;
      border: 1px solid var(--color-border);
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
      color: var(--color-text-secondary);
      transition: all 0.2s;
    }

    .feedback-btn:hover {
      background: var(--color-bg-subtle);
      border-color: var(--color-brand);
    }

    .feedback-btn.active {
      background: var(--color-brand);
      border-color: var(--color-brand);
      color: white;
    }

    .feedback-btn.positive:hover,
    .feedback-btn.positive.active {
      background: var(--color-success-500);
      border-color: var(--color-success-500);
      color: white;
    }

    .feedback-btn.negative:hover,
    .feedback-btn.negative.active {
      background: var(--color-error-500);
      border-color: var(--color-error-500);
      color: white;
    }

    .feedback-expand {
      background: none;
      border: none;
      color: var(--color-text-muted);
      cursor: pointer;
      font-size: 12px;
      padding: 4px;
    }

    .feedback-expand:hover {
      color: var(--color-brand);
    }

    .feedback-form {
      display: none;
      margin-top: 8px;
      padding: 12px;
      background: var(--color-bg-subtle);
      border-radius: 8px;
    }

    .feedback-form.visible {
      display: block;
    }

    .feedback-form label {
      display: block;
      font-size: 12px;
      color: var(--color-text-secondary);
      margin-bottom: 4px;
    }

    .feedback-form select,
    .feedback-form textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      font-size: 13px;
      font-family: inherit;
      background: var(--color-bg-card);
      color: var(--color-text);
      margin-bottom: 8px;
    }

    .feedback-form textarea {
      resize: vertical;
      min-height: 60px;
    }

    .feedback-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 8px;
    }

    .feedback-tag {
      font-size: 11px;
      padding: 4px 8px;
      border: 1px solid var(--color-border);
      border-radius: 12px;
      cursor: pointer;
      background: var(--color-bg-card);
      color: var(--color-text-secondary);
      transition: all 0.2s;
    }

    .feedback-tag:hover {
      border-color: var(--color-brand);
    }

    .feedback-tag.selected {
      background: var(--color-primary-100);
      border-color: var(--color-brand);
      color: var(--color-brand);
    }

    .feedback-submit {
      background: var(--color-brand);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .feedback-submit:hover {
      background: var(--color-brand-hover);
    }

    .feedback-submit:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .feedback-success {
      color: var(--color-success-600);
      font-size: 12px;
      padding: 4px 0;
    }

    /* Session-level feedback prompt */
    .session-feedback {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 12px 16px;
      margin: 16px 24px;
      background: var(--color-bg-subtle);
      border: 1px solid var(--color-border);
      border-radius: 10px;
      font-size: 13px;
      color: var(--color-text-secondary);
      animation: fadeInUp 0.3s ease-out;
    }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .session-feedback-label {
      color: var(--color-text-secondary);
    }

    .session-feedback-buttons {
      display: flex;
      gap: 6px;
    }

    .session-feedback-btn {
      background: var(--color-bg-card);
      border: 1px solid var(--color-border);
      border-radius: 6px;
      padding: 6px 14px;
      cursor: pointer;
      font-size: 13px;
      color: var(--color-text-secondary);
      transition: all 0.2s;
    }

    .session-feedback-btn:hover {
      border-color: var(--color-brand);
      background: var(--color-bg-subtle);
    }

    .session-feedback-btn.positive:hover {
      background: var(--color-success-500);
      border-color: var(--color-success-500);
      color: white;
    }

    .session-feedback-btn.negative:hover {
      background: var(--color-error-500);
      border-color: var(--color-error-500);
      color: white;
    }

    .session-feedback-dismiss {
      background: none;
      border: none;
      color: var(--color-text-muted);
      cursor: pointer;
      font-size: 16px;
      padding: 0 4px;
      line-height: 1;
    }

    .session-feedback-dismiss:hover {
      color: var(--color-text-secondary);
    }

    .session-feedback--success {
      justify-content: center;
      color: var(--color-success-600);
      border-color: var(--color-success-500);
      background: var(--color-success-50, var(--color-bg-subtle));
    }

    /* SI Agent CTA Buttons */
    .si-cta-container {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--color-border);
    }

    .si-cta-button {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: var(--color-brand);
      color: white;
      border: none;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .si-cta-button:hover:not(:disabled) {
      background: var(--color-brand-hover);
      transform: translateY(-1px);
    }

    .si-cta-button:disabled {
      opacity: 0.7;
      cursor: not-allowed;
    }

    .si-cta-icon {
      font-size: 14px;
    }

    /* Responsive */
    @media (max-width: 600px) {
      .message-content {
        max-width: 85%;
      }

      .chat-header h1 {
        font-size: 20px;
      }
    }

    /* Chat Sidebar - Vertical Tab Layout */
    .page-layout {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .chat-sidebar {
      width: 280px;
      border-right: 1px solid var(--color-border);
      background: var(--color-bg-card);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      height: 100%;
      transition: width 0.2s ease;
      position: relative;
    }

    /* Hide sidebar for unauthenticated users */
    .chat-sidebar:not(.visible) {
      display: none;
    }

    /* Collapsed sidebar state */
    .chat-sidebar.collapsed {
      width: 56px;
    }

    .chat-sidebar.collapsed .sidebar-nav {
      padding: 8px;
    }

    .chat-sidebar.collapsed .sidebar-tab {
      justify-content: center;
      padding: 10px;
    }

    .chat-sidebar.collapsed .sidebar-tab-text {
      display: none;
    }

    .chat-sidebar.collapsed .sidebar-section,
    .chat-sidebar.collapsed .sidebar-history {
      display: none;
    }

    .chat-sidebar.collapsed .sidebar-collapse-btn svg {
      transform: rotate(180deg);
    }

    /* Sidebar collapse button */
    .sidebar-collapse-btn {
      position: absolute;
      top: var(--space-2);
      right: calc(-1 * var(--space-4));
      width: var(--space-8);
      height: var(--space-8);
      border-radius: 50%;
      background: var(--color-bg-card);
      border: 1px solid var(--color-border);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      box-shadow: var(--shadow-sm);
      transition: background var(--duration-fast, 0.15s);
    }

    .sidebar-collapse-btn:hover {
      background: var(--color-bg-subtle);
    }

    .sidebar-collapse-btn:focus-visible {
      outline: 2px solid var(--color-brand);
      outline-offset: 2px;
    }

    .sidebar-collapse-btn:focus:not(:focus-visible) {
      outline: none;
    }

    .sidebar-collapse-btn svg {
      width: 16px;
      height: 16px;
      color: var(--color-text-muted);
      transition: transform var(--duration-normal, 0.2s);
    }

    /* Sidebar navigation tabs */
    .sidebar-nav {
      padding: 12px;
      border-bottom: 1px solid var(--color-border);
    }

    .sidebar-tab {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border: none;
      border-radius: var(--radius-lg);
      background: transparent;
      color: var(--color-text-secondary);
      font-size: 14px;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.15s;
      text-align: left;
    }

    .sidebar-tab:hover {
      background: var(--color-bg-subtle);
      color: var(--color-text);
    }

    .sidebar-tab.active {
      background: var(--color-primary-50);
      color: var(--color-brand);
      font-weight: 500;
    }

    .sidebar-tab svg {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }

    .sidebar-tab--new {
      background: var(--color-brand);
      color: white;
      margin-top: 8px;
    }

    .sidebar-tab--new:hover {
      background: var(--color-brand-hover);
      color: white;
    }

    /* Sidebar sections */
    .sidebar-section {
      display: flex;
      flex-direction: column;
    }

    .sidebar-section-header {
      padding: 12px 16px 8px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--color-text-muted);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .sidebar-section-header button {
      background: none;
      border: none;
      padding: 0;
      cursor: pointer;
      color: var(--color-text-muted);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .sidebar-section-header button:hover {
      color: var(--color-text);
    }

    .sidebar-section-header .badge {
      background: var(--color-bg-subtle);
      color: var(--color-text-muted);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 500;
    }

    .sidebar-section-header svg {
      width: 14px;
      height: 14px;
      transition: transform 0.2s;
    }

    .sidebar-section--collapsed .sidebar-section-header svg {
      transform: rotate(-90deg);
    }

    .sidebar-section--collapsed .sidebar-section-content {
      display: none;
    }

    /* Active tabs list */
    .sidebar-active-list {
      padding: 0 8px 8px;
    }

    .sidebar-active-list:empty::after {
      content: 'No active chats';
      display: block;
      padding: 12px 8px;
      text-align: center;
      color: var(--color-text-muted);
      font-size: 12px;
    }

    /* Tab items in sidebar */
    .tab-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: var(--radius-lg);
      cursor: pointer;
      transition: background 0.15s;
      position: relative;
    }

    .tab-item:hover {
      background: var(--color-bg-subtle);
    }

    .tab-item.active {
      background: var(--color-primary-50);
    }

    .tab-item-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .tab-item-indicator--thinking {
      background: var(--color-warning-500);
      animation: pulse 1.5s ease-in-out infinite;
    }

    .tab-item-indicator--ready {
      background: var(--color-success-500);
    }

    .tab-item-indicator--idle {
      background: var(--color-gray-300);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(0.85); }
    }

    .tab-item-content {
      flex: 1;
      min-width: 0;
    }

    .tab-item-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--color-text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .tab-item-meta {
      font-size: 11px;
      color: var(--color-text-muted);
      margin-top: 2px;
    }

    .tab-item-close {
      width: 20px;
      height: 20px;
      border: none;
      background: transparent;
      color: var(--color-text-muted);
      cursor: pointer;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.15s, background 0.15s;
    }

    .tab-item:hover .tab-item-close {
      opacity: 1;
    }

    .tab-item-close:hover {
      background: var(--color-bg-subtle);
      color: var(--color-text);
    }

    .tab-item-close svg {
      width: 14px;
      height: 14px;
    }

    .tab-item-badge {
      position: absolute;
      top: 6px;
      right: 6px;
      min-width: 18px;
      height: 18px;
      background: var(--color-brand);
      color: white;
      font-size: 10px;
      font-weight: 600;
      border-radius: 9px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 5px;
    }

    /* History section */
    .sidebar-history {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      border-top: 1px solid var(--color-border);
    }

    .sidebar-history-list {
      flex: 1;
      overflow-y: auto;
      padding: 0 8px 8px;
    }

    .history-item {
      padding: 10px 12px;
      border-radius: var(--radius-lg);
      cursor: pointer;
      transition: background 0.15s;
    }

    .history-item:hover {
      background: var(--color-bg-subtle);
    }

    .history-item-title {
      font-size: 13px;
      color: var(--color-text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .history-item-meta {
      font-size: 11px;
      color: var(--color-text-muted);
      margin-top: 2px;
      display: flex;
      justify-content: space-between;
    }

    /* Branded SI chat history items */
    .history-item.si-branded {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 12px;
      border-left: 3px solid var(--si-item-color, var(--color-brand));
      background: linear-gradient(90deg, color-mix(in srgb, var(--si-item-color, var(--color-brand)) 8%, transparent) 0%, transparent 100%);
    }

    .history-item.si-branded:hover {
      background: linear-gradient(90deg, color-mix(in srgb, var(--si-item-color, var(--color-brand)) 15%, transparent) 0%, var(--color-bg-subtle) 100%);
    }

    .si-brand-avatar {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      background: var(--si-item-color, var(--color-brand));
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
      flex-shrink: 0;
      overflow: hidden;
    }

    .si-brand-avatar img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .history-item.si-branded .history-item-content {
      flex: 1;
      min-width: 0;
    }

    .history-item.si-branded .history-item-title {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .si-brand-name {
      font-weight: 500;
      color: var(--color-text);
    }

    .si-brand-badge {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 2px 5px;
      border-radius: 3px;
      background: var(--si-item-color, var(--color-brand));
      color: white;
      opacity: 0.9;
    }

    .thread-channel-badge {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      background: var(--color-bg-subtle);
      color: var(--color-text-muted);
      vertical-align: middle;
    }

    .thread-channel-badge.slack {
      background: #4A154B15;
      color: #4A154B;
    }

    .thread-channel-badge svg {
      width: 10px;
      height: 10px;
    }

    .history-empty {
      text-align: center;
      padding: 24px 16px;
      color: var(--color-text-muted);
      font-size: 13px;
    }

    /* Mobile sidebar toggle */
    .sidebar-toggle-btn {
      position: fixed;
      left: 16px;
      bottom: calc(100px + env(safe-area-inset-bottom, 0px));
      background: var(--color-bg-card);
      border: 1px solid var(--color-border);
      border-radius: 8px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 13px;
      color: var(--color-text-secondary);
      display: none;
      align-items: center;
      gap: 6px;
      z-index: 100;
      box-shadow: var(--shadow-sm);
    }

    body.native-app .sidebar-toggle-btn {
      bottom: calc(80px + env(safe-area-inset-bottom, 0px));
    }

    .sidebar-toggle-btn:hover {
      background: var(--color-bg-subtle);
      border-color: var(--color-brand);
    }

    .sidebar-toggle-btn .badge {
      background: var(--color-brand);
      color: white;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 600;
    }

    /* Mobile: use drawer overlay pattern on very small screens */
    @media (max-width: 500px) {
      .chat-sidebar.visible {
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        z-index: 1000;
        box-shadow: var(--shadow-lg);
        width: 280px;
      }

      .chat-sidebar.visible:not(.mobile-open) {
        display: none;
      }

      .chat-sidebar.visible.mobile-open {
        display: flex;
      }

      .chat-sidebar.visible .sidebar-collapse-btn {
        display: none;
      }

      .sidebar-toggle-btn.visible {
        display: flex;
      }

      .sidebar-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.3);
        z-index: 999;
        display: none;
      }

      .sidebar-overlay.visible {
        display: block;
      }
    }

    /* Tablet and up: always show sidebar (expanded or collapsed) */
    @media (min-width: 501px) {
      .chat-sidebar.visible {
        display: flex;
      }

      .sidebar-toggle-btn {
        display: none !important;
      }
    }

    /* Native app mode - hide site nav, chat header, and status indicator (app provides its own) */
    body.native-app #adcp-nav,
    body.native-app .chat-header,
    body.native-app .status-indicator {
      display: none !important;
    }

    body.native-app .chat-container {
      padding-top: 0;
    }

    body.native-app .messages-container {
      padding-top: 16px;
    }

    /* Native app mode - sidebar adjustments for safe areas */
    body.native-app .chat-sidebar {
      padding-top: env(safe-area-inset-top, 0px);
      padding-bottom: env(safe-area-inset-bottom, 0px);
    }

    body.native-app .chat-sidebar .sidebar-nav {
      padding-top: calc(12px + env(safe-area-inset-top, 0px));
    }

    /* Native app uses same collapsible pattern as web */
    body.native-app .chat-sidebar.visible {
      display: flex;
    }

    body.native-app .sidebar-toggle-btn {
      display: none !important;
    }

    /* Native app mode - adjust input area for safe areas */
    body.native-app .input-container {
      padding-bottom: calc(16px + env(safe-area-inset-bottom, 0px));
    }

    /* ===================================================================
       SI (Sponsored Intelligence) Chat Modal
       =================================================================== */

    .si-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: var(--z-overlay, 40);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      backdrop-filter: blur(2px);
    }

    .si-modal-overlay.visible,
    .si-modal-overlay.active {
      display: flex;
    }

    .si-modal {
      background: var(--color-bg-card);
      border-radius: var(--radius-xl, 16px);
      width: 100%;
      max-width: 520px;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow-lg, 0 25px 50px -12px rgba(0, 0, 0, 0.25));
      animation: siModalIn 0.2s ease-out;
      overflow: hidden;
    }

    @keyframes siModalIn {
      from {
        opacity: 0;
        transform: scale(0.95) translateY(10px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .si-modal-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      border-bottom: 1px solid var(--color-border);
      background: var(--si-brand-color, var(--color-brand));
      color: white;
    }

    .si-modal-header-icon {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      flex-shrink: 0;
    }

    .si-modal-header-icon img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 8px;
    }

    .si-modal-header-info {
      flex: 1;
      min-width: 0;
    }

    .si-modal-header-title {
      font-size: 16px;
      font-weight: 600;
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .si-modal-header-tagline {
      font-size: 12px;
      opacity: 0.9;
      margin: 2px 0 0 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .si-modal-sponsored {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.8;
      background: rgba(255, 255, 255, 0.2);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .si-modal-close {
      width: 32px;
      height: 32px;
      border: none;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s;
      flex-shrink: 0;
    }

    .si-modal-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .si-modal-close svg {
      width: 18px;
      height: 18px;
    }

    .si-modal-messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 200px;
      max-height: 400px;
    }

    .si-message {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      animation: fadeIn 0.2s ease;
    }

    .si-message.user {
      flex-direction: row-reverse;
    }

    .si-message-content {
      max-width: 80%;
      padding: 10px 14px;
      border-radius: 12px;
      line-height: 1.5;
      font-size: 14px;
    }

    .si-message.assistant .si-message-content {
      background: var(--color-bg-subtle);
      border: 1px solid var(--color-border);
      border-radius: 12px 12px 12px 4px;
    }

    .si-message.user .si-message-content {
      background: var(--si-brand-color, var(--color-brand));
      color: white;
      border-radius: 12px 12px 4px 12px;
    }

    .si-message-content p {
      margin: 0 0 8px 0;
    }

    .si-message-content p:last-child {
      margin-bottom: 0;
    }

    .si-modal-input-container {
      display: flex;
      gap: 8px;
      padding: 12px 16px 16px;
      border-top: 1px solid var(--color-border);
      background: var(--color-bg-card);
    }

    .si-modal-input {
      flex: 1;
      padding: 10px 14px;
      border: 1px solid var(--color-border);
      border-radius: 12px;
      font-size: 14px;
      font-family: inherit;
      resize: none;
      background: var(--color-bg-page);
      color: var(--color-text);
      transition: border-color 0.15s;
    }

    .si-modal-input:focus {
      outline: none;
      border-color: var(--si-brand-color, var(--color-brand));
    }

    .si-modal-input::placeholder {
      color: var(--color-text-muted);
    }

    .si-modal-send {
      width: 40px;
      height: 40px;
      border: none;
      background: var(--si-brand-color, var(--color-brand));
      color: white;
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.15s;
      flex-shrink: 0;
    }

    .si-modal-send:hover:not(:disabled) {
      opacity: 0.9;
    }

    .si-modal-send:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .si-modal-send svg {
      width: 18px;
      height: 18px;
    }

    .si-typing-indicator .si-message-content {
      display: flex;
      gap: 4px;
      padding: 12px 14px;
    }

    .si-typing-dot {
      width: 6px;
      height: 6px;
      background: var(--color-text-muted);
      border-radius: 50%;
      animation: siTyping 1.4s infinite ease-in-out;
    }

    .si-typing-dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .si-typing-dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes siTyping {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.5; }
      30% { transform: translateY(-4px); opacity: 1; }
    }

    /* UI Elements */
    .si-ui-elements {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
      flex-basis: 100%;
    }

    .si-ui-button {
      padding: 8px 16px;
      background: var(--si-brand-color, var(--color-brand));
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: opacity 0.15s;
    }

    .si-ui-button:hover {
      opacity: 0.9;
    }

    .si-ui-link {
      color: var(--si-brand-color, var(--color-brand));
      text-decoration: none;
      font-size: 13px;
      font-weight: 500;
    }

    .si-ui-link:hover {
      text-decoration: underline;
    }

    .si-product-card {
      display: flex;
      gap: 12px;
      padding: 12px;
      background: var(--color-bg-page);
      border: 1px solid var(--color-border);
      border-radius: 10px;
      margin-top: 8px;
    }

    .si-product-image {
      width: 60px;
      height: 60px;
      object-fit: cover;
      border-radius: 6px;
    }

    .si-product-info {
      flex: 1;
      min-width: 0;
    }

    .si-product-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .si-product-price {
      color: var(--si-brand-color, var(--color-brand));
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .si-product-description {
      font-size: 12px;
      color: var(--color-text-muted);
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }

    .si-product-badge {
      display: inline-block;
      background: var(--si-brand-color, var(--color-brand));
      color: white;
      font-size: 10px;
      font-weight: 600;
      padding: 2px 6px;
      border-radius: 4px;
      margin-bottom: 4px;
    }

    .si-product-cta {
      margin-top: 8px;
    }

    .si-product-cta button {
      padding: 6px 12px;
      background: var(--si-brand-color, var(--color-brand));
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: opacity 0.15s;
    }

    .si-product-cta button:hover {
      opacity: 0.9;
    }

    /* Carousel */
    .si-carousel {
      width: 100%;
      margin-top: 8px;
    }

    .si-carousel-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 10px;
      color: var(--color-text);
    }

    .si-carousel-track {
      display: flex;
      gap: 12px;
      overflow-x: auto;
      scroll-snap-type: x mandatory;
      scrollbar-width: thin;
      padding-bottom: 8px;
    }

    .si-carousel-track::-webkit-scrollbar {
      height: 6px;
    }

    .si-carousel-track::-webkit-scrollbar-track {
      background: var(--color-bg-subtle);
      border-radius: 3px;
    }

    .si-carousel-track::-webkit-scrollbar-thumb {
      background: var(--color-border);
      border-radius: 3px;
    }

    .si-carousel-item {
      flex: 0 0 auto;
      width: 200px;
      scroll-snap-align: start;
      background: var(--color-bg-page);
      border: 1px solid var(--color-border);
      border-radius: 10px;
      overflow: hidden;
      cursor: pointer;
      transition: border-color 0.15s, transform 0.15s;
    }

    .si-carousel-item:hover {
      border-color: var(--si-brand-color, var(--color-brand));
      transform: translateY(-2px);
    }

    .si-carousel-item-image {
      width: 100%;
      height: 120px;
      object-fit: cover;
      background: var(--color-bg-subtle);
    }

    .si-carousel-item-content {
      padding: 10px;
    }

    .si-carousel-item-title {
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .si-carousel-item-subtitle {
      font-size: 11px;
      color: var(--color-text-muted);
      margin-bottom: 4px;
    }

    .si-carousel-item-price {
      color: var(--si-brand-color, var(--color-brand));
      font-weight: 600;
      font-size: 13px;
    }

    /* Image element */
    .si-image {
      margin-top: 8px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--color-border);
    }

    .si-image img {
      width: 100%;
      max-height: 250px;
      object-fit: cover;
      display: block;
    }

    .si-image-caption {
      padding: 8px 10px;
      font-size: 12px;
      color: var(--color-text-muted);
      background: var(--color-bg-subtle);
    }

    /* Action buttons */
    .si-action-button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      background: var(--si-brand-color, var(--color-brand));
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: opacity 0.15s, transform 0.15s;
    }

    .si-action-button:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    .si-action-button.secondary {
      background: transparent;
      color: var(--si-brand-color, var(--color-brand));
      border: 1px solid var(--si-brand-color, var(--color-brand));
    }

    .si-action-button.secondary:hover {
      background: var(--si-brand-color, var(--color-brand));
      color: white;
    }

    .si-action-button svg {
      width: 16px;
      height: 16px;
    }

    /* MCP/A2A integration buttons */
    .si-integration-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--color-border);
    }

    .si-integration-button {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: var(--color-bg-page);
      border: 1px solid var(--color-border);
      border-radius: 6px;
      font-size: 12px;
      color: var(--color-text);
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
    }

    .si-integration-button:hover {
      border-color: var(--si-brand-color, var(--color-brand));
      background: var(--color-bg-subtle);
    }

    .si-integration-button svg {
      width: 14px;
      height: 14px;
      opacity: 0.7;
    }

    .si-integration-button.highlighted {
      background: linear-gradient(135deg, var(--si-brand-color, var(--color-brand)) 0%, color-mix(in srgb, var(--si-brand-color, var(--color-brand)) 80%, purple) 100%);
      color: white;
      border-color: transparent;
    }

    .si-integration-button.highlighted svg {
      opacity: 1;
    }

    /* A2UI Surface Styles */
    .si-a2ui-surface {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .si-a2ui-text {
      font-size: 14px;
      line-height: 1.5;
      color: var(--color-text);
    }

    .si-a2ui-text.variant-heading {
      font-size: 16px;
      font-weight: 600;
      color: var(--color-text-heading);
    }

    .si-a2ui-text.variant-caption {
      font-size: 12px;
      color: var(--color-text-muted);
    }

    .si-a2ui-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .si-a2ui-list.horizontal {
      flex-direction: row;
      overflow-x: auto;
      padding-bottom: 8px;
    }

    .si-a2ui-list.horizontal > * {
      flex-shrink: 0;
      min-width: 150px;
      max-width: 200px;
    }

    .si-a2ui-list.grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
    }

    .si-a2ui-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .si-a2ui-column {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* Mobile responsive */
    @media (max-width: 640px) {
      .si-modal-overlay {
        padding: 0;
        align-items: flex-end;
      }

      .si-modal {
        max-width: 100%;
        max-height: 90vh;
        border-radius: var(--radius-xl, 16px) var(--radius-xl, 16px) 0 0;
      }

      .si-modal-messages {
        max-height: 50vh;
      }

      .si-modal-input-container {
        padding-bottom: calc(16px + env(safe-area-inset-bottom, 0px));
      }
    }
  </style>
</head>
<body>
  <div id="impersonation-banner" class="impersonation-banner"></div>
  <div id="adcp-nav"></div>

  <!-- SI (Sponsored Intelligence) Chat Modal -->
  <div id="siModalOverlay" class="si-modal-overlay">
    <div class="si-modal" id="siModal">
      <div class="si-modal-header" id="siModalHeader">
        <div class="si-modal-header-icon" id="siModalIcon">
          <span id="siModalIconEmoji">üè¢</span>
        </div>
        <div class="si-modal-header-info">
          <h2 class="si-modal-header-title" id="siModalTitle">Brand Agent</h2>
          <p class="si-modal-header-tagline" id="siModalTagline"></p>
        </div>
        <span class="si-modal-sponsored">Sponsored</span>
        <button class="si-modal-close" id="siModalClose" title="End conversation">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 6L6 18M6 6l12 12"/>
          </svg>
        </button>
      </div>
      <div class="si-modal-messages" id="siModalMessages">
        <!-- Messages will be inserted here -->
      </div>
      <div class="si-modal-input-container">
        <textarea
          id="siModalInput"
          class="si-modal-input"
          placeholder="Type a message..."
          rows="1"
        ></textarea>
        <button class="si-modal-send" id="siModalSend" title="Send">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Mobile sidebar toggle button -->
  <button class="sidebar-toggle-btn" id="sidebarToggleBtn" title="Show chats">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
    </svg>
    Chats
    <span class="badge" id="sidebarBadge" style="display: none;">0</span>
  </button>

  <!-- Mobile overlay -->
  <div class="sidebar-overlay" id="sidebarOverlay"></div>

  <div class="page-layout">
    <!-- Chat Sidebar -->
    <div class="chat-sidebar" id="chatSidebar">
      <!-- Navigation tabs -->
      <div class="sidebar-nav">
        <!-- Collapse toggle button -->
        <button class="sidebar-collapse-btn" id="sidebarCollapseBtn"
                title="Collapse sidebar"
                aria-label="Collapse sidebar"
                aria-expanded="true"
                aria-controls="chatSidebar">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="15 18 9 12 15 6"/>
          </svg>
        </button>
        <button class="sidebar-tab active" id="homeTab">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
            <polyline points="9 22 9 12 15 12 15 22"/>
          </svg>
          <span class="sidebar-tab-text">Home</span>
        </button>
        <button class="sidebar-tab sidebar-tab--new" id="newChatBtn">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="12" y1="5" x2="12" y2="19"/>
            <line x1="5" y1="12" x2="19" y2="12"/>
          </svg>
          <span class="sidebar-tab-text">New Chat</span>
        </button>
      </div>

      <!-- Active chats section -->
      <div class="sidebar-section">
        <div class="sidebar-section-header">Active</div>
        <div class="sidebar-active-list" id="activeTabsList"></div>
      </div>

      <!-- History section -->
      <div class="sidebar-history" id="historySection">
        <div class="sidebar-section-header">
          <button id="historyToggle">
            History
            <span class="badge" id="historyCount">0</span>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="6 9 12 15 18 9"/>
            </svg>
          </button>
        </div>
        <div class="sidebar-section-content">
          <div class="sidebar-history-list" id="historyList">
            <div class="history-empty">Loading...</div>
          </div>
        </div>
      </div>
    </div>

    <div class="chat-container">
      <div class="chat-header">
        <h1>
          <span class="addie-avatar">A</span>
          Chat with Addie
        </h1>
        <p>Your AI assistant for AdCP and Agentic Advertising</p>
      </div>

      <div class="messages-container" id="messagesContainer">
        <!-- Addie Home (shown for authenticated users) -->
        <div class="addie-home-container" id="addieHomeContainer">
          <div class="addie-home-loading" id="addieHomeLoading">Loading your dashboard...</div>
          <div id="addieHomeContent"></div>
          <style id="addieHomeStyles"></style>
        </div>

        <div class="welcome-message" id="welcomeMessage">
          <h2>Hi! I'm Addie</h2>
          <p>I'm here to help you learn about AdCP, the Advertising Context Protocol, and agentic advertising. Ask me anything!</p>
          <div class="suggested-prompts" id="suggestedPrompts">
            <button class="suggested-prompt" data-prompt="What can you do? What kinds of things can I ask you about?">What can you help me with?</button>
            <button class="suggested-prompt" data-prompt="What is AdCP and how does it work?">Learn about AdCP</button>
            <button class="suggested-prompt" data-prompt="How do I set up a sales agent with AdCP?">Get started building</button>
            <button class="suggested-prompt" data-prompt="How is agentic advertising different from programmatic, and why is it better for sustainability?">AdCP vs programmatic</button>
          </div>
        </div>
      </div>

      <div class="chat-input-container">
        <div class="chat-input-wrapper">
          <textarea
            class="chat-input"
            id="chatInput"
            placeholder="Ask Addie anything..."
            rows="1"
          ></textarea>
          <button class="send-button" id="sendButton" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
              <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
            </svg>
          </button>
        </div>
        <div class="status-indicator" id="statusIndicator">
          <span class="status-dot" id="statusDot"></span>
          <span id="statusText">Connecting...</span>
        </div>
      </div>
    </div>
  </div>

  <script src="/nav.js"></script>
  <script>
    (function() {
      'use strict';

      // Elements
      const messagesContainer = document.getElementById('messagesContainer');
      const welcomeMessage = document.getElementById('welcomeMessage');
      const chatInput = document.getElementById('chatInput');
      const sendButton = document.getElementById('sendButton');
      const suggestedPrompts = document.getElementById('suggestedPrompts');
      const statusDot = document.getElementById('statusDot');
      const statusText = document.getElementById('statusText');
      const addieHomeContainer = document.getElementById('addieHomeContainer');
      const addieHomeContent = document.getElementById('addieHomeContent');
      const addieHomeLoading = document.getElementById('addieHomeLoading');
      const addieHomeStyles = document.getElementById('addieHomeStyles');
      const chatSidebar = document.getElementById('chatSidebar');
      const homeTab = document.getElementById('homeTab');
      const newChatBtn = document.getElementById('newChatBtn');
      const activeTabsList = document.getElementById('activeTabsList');
      const historyList = document.getElementById('historyList');
      const historyCount = document.getElementById('historyCount');
      const historyToggle = document.getElementById('historyToggle');
      const historySection = document.getElementById('historySection');
      const sidebarToggleBtn = document.getElementById('sidebarToggleBtn');
      const sidebarOverlay = document.getElementById('sidebarOverlay');
      const sidebarBadge = document.getElementById('sidebarBadge');
      const sidebarCollapseBtn = document.getElementById('sidebarCollapseBtn');

      // SI Modal Elements
      const siModalOverlay = document.getElementById('siModalOverlay');
      const siModal = document.getElementById('siModal');
      const siModalHeader = document.getElementById('siModalHeader');
      const siModalIcon = document.getElementById('siModalIcon');
      const siModalIconEmoji = document.getElementById('siModalIconEmoji');
      const siModalTitle = document.getElementById('siModalTitle');
      const siModalTagline = document.getElementById('siModalTagline');
      const siModalClose = document.getElementById('siModalClose');
      const siModalMessages = document.getElementById('siModalMessages');
      const siModalInput = document.getElementById('siModalInput');
      const siModalSend = document.getElementById('siModalSend');

      // State
      let conversationId = null;
      let isLoading = false;
      let isReady = false;
      let impersonationInfo = null;
      let isAuthenticated = false;
      let threads = [];
      let mobileMenuOpen = false;
      let sidebarCollapsed = false;
      try {
        sidebarCollapsed = localStorage.getItem('addie-sidebar-collapsed') === 'true';
      } catch (e) {
        // localStorage may be unavailable in private browsing
      }

      // Tab state - persisted to localStorage
      let activeTabs = []; // [{id, title, channel, isLoading, unreadCount}]
      let currentTabId = 'home'; // 'home' or conversation_id

      // Event delegation for member card clicks (more secure than inline onclick)
      messagesContainer.addEventListener('click', function(e) {
        const card = e.target.closest('.member-card');
        if (card) {
          const slug = card.dataset.slug;
          const sessionId = card.dataset.sessionId || null;
          if (slug) {
            trackMemberClick(slug, sessionId);
          }
        }
      });
      const originalTitle = document.title;

      // SI (Sponsored Intelligence) Modal State
      let siSessionId = null;
      let siBrandName = null;
      let siBrandInfo = null;
      let siIsLoading = false;

      // Native app auth token (from URL hash, e.g., #token=xxx)
      let nativeAuthToken = null;

      // Extract token from URL hash for native apps (Tauri, Capacitor)
      function extractNativeToken() {
        const hash = window.location.hash;
        if (hash && hash.includes('token=')) {
          const params = new URLSearchParams(hash.slice(1));
          const token = params.get('token');
          if (token) {
            nativeAuthToken = token;
            // Mark body as native app mode to hide nav/header via CSS
            document.body.classList.add('native-app');
            // Clear hash from URL for cleaner appearance
            history.replaceState(null, '', window.location.pathname + window.location.search);
            console.log('Native auth token detected');
          }
        }

        // Also detect if we're inside a Tauri webview (backup detection)
        // Tauri injects __TAURI__ global, but this may not be available in iframe
        // Check for window.self !== window.top (we're in an iframe)
        if (window.self !== window.top) {
          document.body.classList.add('native-app');
          console.log('Running inside iframe, enabling native-app mode');
        }
      }

      // Helper for authenticated API requests (works for both web cookies and native tokens)
      function authFetch(url, options = {}) {
        const headers = { ...options.headers };
        if (nativeAuthToken) {
          headers['Authorization'] = `Bearer ${nativeAuthToken}`;
        }
        return fetch(url, { ...options, headers, credentials: 'include' });
      }

      // Check for impersonation and authentication
      async function checkImpersonation() {
        try {
          const response = await authFetch('/api/me');
          if (!response.ok) return; // Not authenticated

          const data = await response.json();
          isAuthenticated = true;

          if (data.impersonation && data.impersonation.active) {
            impersonationInfo = data.impersonation;
            const banner = document.getElementById('impersonation-banner');
            const reason = impersonationInfo.reason
              ? ` <span class="reason">"${impersonationInfo.reason}"</span>`
              : '';
            banner.innerHTML = `
              <strong>Impersonation Active</strong> -
              Viewing as <strong>${data.user.email}</strong>
              (impersonated by ${impersonationInfo.impersonator_email})${reason}
            `;
            banner.classList.add('active');
          }

          // Load Addie Home for authenticated users
          loadAddieHome();

          // Show sidebar and load threads for authenticated users
          chatSidebar.classList.add('visible');
          sidebarToggleBtn.classList.add('visible');
          loadActiveTabs(); // Restore from localStorage
          loadThreads();
        } catch (error) {
          // Silently ignore - user may not be authenticated
        }
      }

      // SI sessions state (for branded chat history)
      let siSessions = [];

      // Load user's conversation threads and SI sessions
      async function loadThreads() {
        if (!isAuthenticated) return;

        try {
          // Load regular threads and SI sessions in parallel
          const [threadsResponse, siResponse] = await Promise.all([
            authFetch('/api/addie/chat/threads'),
            authFetch('/api/si/sessions/user').catch(() => ({ ok: false }))
          ]);

          if (threadsResponse.ok) {
            const data = await threadsResponse.json();
            threads = data.conversations || [];
          }

          if (siResponse.ok) {
            const siData = await siResponse.json();
            siSessions = siData.sessions || [];
          }

          renderHistoryList();
          renderActiveTabs();
        } catch (error) {
          console.error('Failed to load threads:', error);
        }
      }

      // Helper to render channel badge
      function getChannelBadge(channel) {
        if (channel === 'slack') {
          return `<span class="thread-channel-badge slack">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M5.042 15.165a2.528 2.528 0 0 1-2.52 2.523A2.528 2.528 0 0 1 0 15.165a2.527 2.527 0 0 1 2.522-2.52h2.52v2.52zM6.313 15.165a2.527 2.527 0 0 1 2.521-2.52 2.527 2.527 0 0 1 2.521 2.52v6.313A2.528 2.528 0 0 1 8.834 24a2.528 2.528 0 0 1-2.521-2.522v-6.313zM8.834 5.042a2.528 2.528 0 0 1-2.521-2.52A2.528 2.528 0 0 1 8.834 0a2.528 2.528 0 0 1 2.521 2.522v2.52H8.834zM8.834 6.313a2.528 2.528 0 0 1 2.521 2.521 2.528 2.528 0 0 1-2.521 2.521H2.522A2.528 2.528 0 0 1 0 8.834a2.528 2.528 0 0 1 2.522-2.521h6.312zM18.956 8.834a2.528 2.528 0 0 1 2.522-2.521A2.528 2.528 0 0 1 24 8.834a2.528 2.528 0 0 1-2.522 2.521h-2.522V8.834zM17.688 8.834a2.528 2.528 0 0 1-2.523 2.521 2.527 2.527 0 0 1-2.52-2.521V2.522A2.527 2.527 0 0 1 15.165 0a2.528 2.528 0 0 1 2.523 2.522v6.312zM15.165 18.956a2.528 2.528 0 0 1 2.523 2.522A2.528 2.528 0 0 1 15.165 24a2.527 2.527 0 0 1-2.52-2.522v-2.522h2.52zM15.165 17.688a2.527 2.527 0 0 1-2.52-2.523 2.526 2.526 0 0 1 2.52-2.52h6.313A2.527 2.527 0 0 1 24 15.165a2.528 2.528 0 0 1-2.522 2.523h-6.313z"/>
            </svg>
            Slack
          </span>`;
        }
        return '';
      }

      // === Tab Management Functions ===

      // Clear only chat messages from the container (preserves static elements like home/welcome)
      function clearChatMessages() {
        const messages = messagesContainer.querySelectorAll('.message, .session-feedback');
        messages.forEach(msg => msg.remove());
      }

      // Debounced thread refresh (avoids excessive API calls when sending multiple messages)
      let loadThreadsTimer = null;
      function scheduleLoadThreads() {
        if (loadThreadsTimer) clearTimeout(loadThreadsTimer);
        loadThreadsTimer = setTimeout(() => {
          if (isAuthenticated) loadThreads();
        }, 1000);
      }

      // Load active tabs from localStorage
      function loadActiveTabs() {
        try {
          const saved = localStorage.getItem('addie_active_tabs');
          if (saved) {
            const parsed = JSON.parse(saved);
            // Validate data structure
            if (Array.isArray(parsed)) {
              activeTabs = parsed.filter(tab =>
                tab && typeof tab.id === 'string' && typeof tab.title === 'string'
              );
              // Reset loading states on page load
              activeTabs.forEach(tab => { tab.isLoading = false; });
            }
          }
        } catch (e) {
          activeTabs = [];
        }
      }

      // Save active tabs to localStorage
      function saveActiveTabs() {
        try {
          localStorage.setItem('addie_active_tabs', JSON.stringify(activeTabs));
        } catch (e) {
          console.warn('Failed to save tabs to localStorage');
        }
      }

      // Add a conversation to active tabs
      function addActiveTab(id, title, channel = 'web') {
        // Check if already in active tabs
        if (activeTabs.some(t => t.id === id)) return;

        // Limit to 7 active tabs
        if (activeTabs.length >= 7) {
          activeTabs.shift(); // Remove oldest
        }

        activeTabs.push({
          id,
          title: title || 'New Chat',
          channel,
          isLoading: false,
          unreadCount: 0
        });
        saveActiveTabs();
        renderActiveTabs();
        renderHistoryList(); // Update history to remove from list
      }

      // Remove a conversation from active tabs
      function removeActiveTab(id) {
        activeTabs = activeTabs.filter(t => t.id !== id);
        saveActiveTabs();
        renderActiveTabs();
        renderHistoryList();

        // If we removed the current tab, switch to home
        if (currentTabId === id) {
          switchToHome();
        }
      }

      // Update a tab's state (loading, unread)
      function updateTabState(id, updates) {
        const tab = activeTabs.find(t => t.id === id);
        if (tab) {
          Object.assign(tab, updates);
          saveActiveTabs();
          renderActiveTabs();
          updateUnreadBadges();
        }
      }

      // Get total unread count across all tabs
      function getTotalUnread() {
        return activeTabs.reduce((sum, t) => sum + (t.unreadCount || 0), 0);
      }

      // Update document title and mobile badge with unread count
      function updateUnreadBadges() {
        const total = getTotalUnread();
        if (total > 0) {
          document.title = `(${total}) ${originalTitle}`;
          sidebarBadge.textContent = total;
          sidebarBadge.style.display = 'inline-flex';
        } else {
          document.title = originalTitle;
          sidebarBadge.style.display = 'none';
        }
      }

      // Render the active tabs list
      function renderActiveTabs() {
        if (activeTabs.length === 0) {
          activeTabsList.innerHTML = '';
          return;
        }

        activeTabsList.innerHTML = activeTabs.map(tab => {
          const indicatorClass = tab.isLoading ? 'tab-item-indicator--thinking' :
                                 tab.unreadCount > 0 ? 'tab-item-indicator--ready' :
                                 'tab-item-indicator--idle';
          const isActive = currentTabId === tab.id;

          return `
            <div class="tab-item ${isActive ? 'active' : ''}" data-tab-id="${tab.id}" data-channel="${tab.channel}">
              <span class="tab-item-indicator ${indicatorClass}"></span>
              <div class="tab-item-content">
                <div class="tab-item-title">${escapeHtml(tab.title)}</div>
              </div>
              ${tab.unreadCount > 0 ? `<span class="tab-item-badge">${tab.unreadCount}</span>` : ''}
              <button class="tab-item-close" data-tab-id="${tab.id}" title="Close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="18" y1="6" x2="6" y2="18"/>
                  <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
              </button>
            </div>
          `;
        }).join('');
      }

      // Render the history list (threads not in active tabs)
      function renderHistoryList() {
        const activeIds = new Set(activeTabs.map(t => t.id));
        const historyThreads = threads.filter(t => !activeIds.has(t.conversation_id));

        // Combine regular threads and SI sessions, sorted by most recent
        const allItems = [
          ...historyThreads.map(t => ({ ...t, type: 'thread' })),
          ...siSessions.map(s => ({
            ...s,
            type: 'si_session',
            id: s.session_id,
            title: `Chat with ${s.brand_name}`,
            last_message_at: s.last_activity_at
          }))
        ].sort((a, b) => new Date(b.last_message_at) - new Date(a.last_message_at));

        historyCount.textContent = allItems.length;

        if (allItems.length === 0) {
          historyList.innerHTML = '<div class="history-empty">No conversation history</div>';
          return;
        }

        historyList.innerHTML = allItems.map(item => {
          if (item.type === 'si_session') {
            // Branded SI session item
            const brandColor = item.brand_color || '#667eea';
            const logoUrl = item.brand_logo_url;
            const initial = (item.brand_name || 'B').charAt(0).toUpperCase();
            return `
              <div class="history-item si-branded"
                   data-si-session-id="${item.session_id}"
                   data-brand-name="${escapeHtml(item.brand_name)}"
                   style="--si-item-color: ${brandColor}">
                <div class="si-brand-avatar">
                  ${logoUrl ? `<img src="${escapeHtml(logoUrl)}" alt="${escapeHtml(item.brand_name)}">` : initial}
                </div>
                <div class="history-item-content">
                  <div class="history-item-title">
                    <span class="si-brand-name">${escapeHtml(item.brand_name)}</span>
                    <span class="si-brand-badge">Sponsored</span>
                  </div>
                  <div class="history-item-meta">
                    <span>${item.message_count || 0} msgs</span>
                    <span>${formatRelativeTime(item.last_message_at)}</span>
                  </div>
                </div>
              </div>
            `;
          } else {
            // Regular thread item
            return `
              <div class="history-item" data-conversation-id="${item.conversation_id}" data-channel="${item.channel || 'web'}">
                <div class="history-item-title">
                  ${escapeHtml(item.title)}
                  ${getChannelBadge(item.channel)}
                </div>
                <div class="history-item-meta">
                  <span>${item.message_count} msgs</span>
                  <span>${formatRelativeTime(item.last_message_at)}</span>
                </div>
              </div>
            `;
          }
        }).join('');
      }

      // Switch to home tab
      function switchToHome() {
        currentTabId = 'home';
        conversationId = null;
        currentChannel = 'web';
        lastAssistantMessageId = null;
        clearSessionFeedbackTimer();

        // Update UI
        homeTab.classList.add('active');
        renderActiveTabs();

        // Show home content
        clearChatMessages();
        if (isAuthenticated) {
          addieHomeContainer.classList.add('visible');
          welcomeMessage.style.display = 'none';
          loadAddieHome();
        } else {
          addieHomeContainer.classList.remove('visible');
          welcomeMessage.style.display = 'block';
        }

        setReadOnlyMode(false);
        closeMobileSidebar();
        chatInput.focus();
      }

      // Toggle history section collapse
      function toggleHistorySection() {
        historySection.classList.toggle('sidebar-section--collapsed');
      }

      // Mobile sidebar functions
      function openMobileSidebar() {
        mobileMenuOpen = true;
        chatSidebar.classList.add('mobile-open');
        sidebarOverlay.classList.add('visible');
      }

      function closeMobileSidebar() {
        mobileMenuOpen = false;
        chatSidebar.classList.remove('mobile-open');
        sidebarOverlay.classList.remove('visible');
      }

      function toggleMobileSidebar() {
        if (mobileMenuOpen) {
          closeMobileSidebar();
        } else {
          openMobileSidebar();
        }
      }

      // Sidebar collapse/expand functions
      function toggleSidebarCollapse() {
        sidebarCollapsed = !sidebarCollapsed;
        chatSidebar.classList.toggle('collapsed', sidebarCollapsed);
        const label = sidebarCollapsed ? 'Expand sidebar' : 'Collapse sidebar';
        sidebarCollapseBtn.title = label;
        sidebarCollapseBtn.setAttribute('aria-label', label);
        sidebarCollapseBtn.setAttribute('aria-expanded', !sidebarCollapsed);
        try {
          localStorage.setItem('addie-sidebar-collapsed', sidebarCollapsed);
        } catch (e) {
          // localStorage may be unavailable in private browsing
        }
      }

      // Apply initial sidebar collapsed state
      function applySidebarCollapsedState() {
        if (sidebarCollapsed) {
          chatSidebar.classList.add('collapsed');
          sidebarCollapseBtn.title = 'Expand sidebar';
          sidebarCollapseBtn.setAttribute('aria-label', 'Expand sidebar');
          sidebarCollapseBtn.setAttribute('aria-expanded', 'false');
        }
      }

      // Format relative time (e.g., "2 hours ago")
      function formatRelativeTime(dateStr) {
        const date = new Date(dateStr);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
      }

      // Escape HTML for safe rendering
      function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Current conversation channel (web or slack)
      let currentChannel = 'web';

      // Switch to a different conversation
      async function switchToConversation(newConversationId, channel = 'web') {
        if (newConversationId === conversationId && channel === currentChannel) return;

        conversationId = newConversationId;
        currentChannel = channel;
        currentTabId = newConversationId;

        // Update home tab state
        homeTab.classList.remove('active');

        // Clear unread count for this tab
        const tab = activeTabs.find(t => t.id === newConversationId);
        if (tab && tab.unreadCount > 0) {
          updateTabState(newConversationId, { unreadCount: 0 });
        }

        // Update active tabs UI
        renderActiveTabs();

        // Clear current messages and hide static content
        clearChatMessages();
        welcomeMessage.style.display = 'none';
        addieHomeContainer.classList.remove('visible');

        // Load conversation history
        try {
          const url = `/api/addie/chat/${encodeURIComponent(conversationId)}${channel === 'slack' ? '?channel=slack' : ''}`;
          const response = await authFetch(url);
          if (!response.ok) throw new Error('Failed to load conversation');

          const data = await response.json();

          // Render messages and track last assistant message
          lastAssistantMessageId = null;
          clearSessionFeedbackTimer();
          data.messages.forEach(msg => {
            addMessage(msg.content, msg.role, msg.message_id);
            if (msg.role === 'assistant' && msg.message_id) {
              lastAssistantMessageId = msg.message_id;
            }
          });

          // Handle read-only mode for Slack threads
          if (data.read_only) {
            setReadOnlyMode(true);
          } else {
            setReadOnlyMode(false);
          }
        } catch (error) {
          console.error('Failed to load conversation:', error);
          showError('Failed to load conversation');
        }

        // Close sidebar on mobile
        closeMobileSidebar();
      }

      // Set read-only mode for the chat input
      function setReadOnlyMode(readOnly) {
        if (readOnly) {
          chatInput.disabled = true;
          chatInput.placeholder = 'This is a Slack conversation - reply in Slack to continue';
          sendButton.disabled = true;
          sendButton.style.opacity = '0.5';
        } else {
          chatInput.disabled = false;
          chatInput.placeholder = 'Ask Addie anything...';
          sendButton.disabled = false;
          sendButton.style.opacity = '1';
        }
      }

      // Start a new conversation
      function startNewConversation() {
        conversationId = null;
        currentChannel = 'web';
        currentTabId = 'home'; // New chat starts from home
        lastAssistantMessageId = null;
        clearSessionFeedbackTimer();

        // Clear messages and show home
        clearChatMessages();

        // Show welcome or Addie Home based on auth
        if (isAuthenticated) {
          addieHomeContainer.classList.add('visible');
          welcomeMessage.style.display = 'none';
          loadAddieHome();
        } else {
          addieHomeContainer.classList.remove('visible');
          welcomeMessage.style.display = 'block';
        }

        // Update sidebar UI
        homeTab.classList.add('active');
        renderActiveTabs();

        // Reset read-only mode
        setReadOnlyMode(false);

        // Close sidebar on mobile
        closeMobileSidebar();

        chatInput.focus();
      }

      // Load Addie Home content
      async function loadAddieHome() {
        if (!isAuthenticated) return;

        addieHomeContainer.classList.add('visible');
        addieHomeLoading.style.display = 'block';
        addieHomeContent.innerHTML = '';

        try {
          const response = await authFetch('/api/me/addie-home?format=html');
          if (!response.ok) {
            throw new Error('Failed to load home content');
          }

          const data = await response.json();

          // Inject CSS
          addieHomeStyles.textContent = data.css;

          // Inject HTML
          addieHomeContent.innerHTML = data.html;
          addieHomeLoading.style.display = 'none';

          // Hide the generic welcome message since we have personalized content
          welcomeMessage.style.display = 'none';

          // Wire up action buttons
          setupHomeActions();
        } catch (error) {
          console.error('Failed to load Addie Home:', error);
          addieHomeLoading.style.display = 'none';
          addieHomeContent.innerHTML = '<div class="addie-home-error">Failed to load your dashboard</div>';
        }
      }

      // Setup click handlers for Addie Home action buttons
      function setupHomeActions() {
        // Handle quick action buttons
        addieHomeContent.querySelectorAll('.addie-home-action').forEach(button => {
          button.addEventListener('click', () => {
            const actionId = button.dataset.action;
            handleHomeAction(actionId);
          });
        });

        // Handle alert action buttons
        addieHomeContent.querySelectorAll('.addie-home-alert-action[data-action]').forEach(button => {
          button.addEventListener('click', () => {
            const actionId = button.dataset.action;
            handleHomeAction(actionId);
          });
        });
      }

      // Valid action IDs to prevent injection
      const VALID_HOME_ACTIONS = new Set([
        'addie_home_ask_addie',
        'addie_home_update_profile',
        'addie_home_browse_groups',
        'addie_home_view_flagged',
        'addie_home_pay_invoice',
        'addie_home_complete_profile',
        'addie_home_link_account',
      ]);

      // Handle Addie Home actions by starting a conversation
      function handleHomeAction(actionId) {
        // Validate action ID against whitelist
        if (!VALID_HOME_ACTIONS.has(actionId)) {
          console.warn('Invalid action ID:', actionId);
          return;
        }

        let prompt = '';

        switch (actionId) {
          case 'addie_home_ask_addie':
            // Just focus the input
            chatInput.focus();
            return;
          case 'addie_home_update_profile':
            prompt = 'Help me update my profile';
            break;
          case 'addie_home_browse_groups':
            prompt = 'Show me working groups I can join';
            break;
          case 'addie_home_view_flagged':
            prompt = 'Show me flagged conversations';
            break;
          case 'addie_home_pay_invoice':
            prompt = 'Help me pay my pending invoice';
            break;
          case 'addie_home_complete_profile':
            prompt = 'Help me complete my profile';
            break;
          case 'addie_home_link_account':
            prompt = 'Help me link my Slack account';
            break;
        }

        // Send the prompt as a message
        chatInput.value = prompt;
        autoResize();
        updateSendButton();
        sendMessage();
      }

      // Check Addie status
      async function checkStatus() {
        try {
          const response = await fetch('/api/addie/chat/status');
          const data = await response.json();
          isReady = data.ready;
          updateStatusIndicator();
        } catch (error) {
          isReady = false;
          updateStatusIndicator();
        }
      }

      function updateStatusIndicator() {
        if (isReady) {
          statusDot.classList.remove('status-dot--offline');
          statusText.textContent = 'Addie is online';
        } else {
          statusDot.classList.add('status-dot--offline');
          statusText.textContent = 'Addie is offline';
        }
        updateSendButton();
      }

      // Auto-resize textarea
      function autoResize() {
        chatInput.style.height = 'auto';
        chatInput.style.height = Math.min(chatInput.scrollHeight, 200) + 'px';
      }

      // Update send button state
      function updateSendButton() {
        const hasText = chatInput.value.trim().length > 0;
        sendButton.disabled = !hasText || isLoading || !isReady;
      }

      // Track member card clicks for analytics
      function trackMemberClick(slug, searchSessionId) {
        // Fire-and-forget analytics tracking
        fetch(`/api/members/${encodeURIComponent(slug)}/click`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ search_session_id: searchSessionId }),
          credentials: 'include',
        }).catch(() => {
          // Ignore errors - analytics shouldn't block navigation
        });
      }

      // Render member search results as cards
      function renderMemberCards(data) {
        const searchSessionId = data.search_session_id || null;
        const offeringLabels = {
          buyer_agent: 'Buyer Agent',
          sales_agent: 'Sales Agent',
          creative_agent: 'Creative Agent',
          signals_agent: 'Signals Agent',
          publisher: 'Publisher',
          consulting: 'Consulting',
          managed_services: 'Managed Services',
          implementation: 'Implementation',
          other: 'Other',
        };

        const escapeHtml = (str) => {
          if (!str) return '';
          return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
        };

        const cards = data.results.map(member => {
          const logoHtml = member.logo_url
            ? `<img class="member-card-logo" src="${escapeHtml(member.logo_url)}" alt="${escapeHtml(member.display_name)}" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'"><div class="member-card-logo-placeholder" style="display:none">${escapeHtml(member.display_name.charAt(0))}</div>`
            : `<div class="member-card-logo-placeholder">${escapeHtml(member.display_name.charAt(0))}</div>`;

          const taglineHtml = member.tagline
            ? `<p class="member-card-tagline">${escapeHtml(member.tagline)}</p>`
            : '';

          const descriptionHtml = member.description
            ? `<p class="member-card-description">${escapeHtml(member.description)}</p>`
            : '';

          const offeringsHtml = member.offerings && member.offerings.length > 0
            ? `<div class="member-card-offerings">${member.offerings.slice(0, 3).map(o =>
                `<span class="member-card-offering">${escapeHtml(offeringLabels[o] || o)}</span>`
              ).join('')}</div>`
            : '';

          const locationHtml = member.headquarters
            ? `<span class="member-card-location">üìç ${escapeHtml(member.headquarters)}</span>`
            : '<span></span>';

          // Add onclick handler to track clicks
          const sessionIdAttr = searchSessionId ? `data-session-id="${escapeHtml(searchSessionId)}"` : '';

          return `
            <a href="/members/${escapeHtml(member.slug)}" class="member-card" target="_blank" data-slug="${escapeHtml(member.slug)}" ${sessionIdAttr}>
              <div class="member-card-header">
                ${logoHtml}
                <div class="member-card-title">
                  <p class="member-card-name">${escapeHtml(member.display_name)}</p>
                  ${taglineHtml}
                </div>
              </div>
              ${descriptionHtml}
              ${offeringsHtml}
              <div class="member-card-footer">
                ${locationHtml}
                <span class="member-card-cta">View Profile ‚Üí</span>
              </div>
            </a>
          `;
        }).join('');

        return `<div class="member-cards-container">${cards}</div>`;
      }

      // Render markdown using marked library
      function renderMessage(text) {
        // Configure marked for security and compatibility
        marked.setOptions({
          breaks: true, // Convert \n to <br>
          gfm: true, // GitHub flavored markdown
        });

        // Helper to escape HTML attribute values
        const escapeAttr = (str) => str
          .replace(/&/g, '&amp;')
          .replace(/"/g, '&quot;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');

        // Check for embedded ADDIE_DATA blocks and extract them
        const dataBlockRegex = /<!--ADDIE_DATA:([\s\S]*?):ADDIE_DATA-->/g;
        const dataBlocks = [];
        let processedText = text.replace(dataBlockRegex, (match, jsonStr) => {
          try {
            const data = JSON.parse(jsonStr);
            const placeholder = `__ADDIE_DATA_PLACEHOLDER_${dataBlocks.length}__`;
            dataBlocks.push(data);
            return placeholder;
          } catch (e) {
            console.warn('Failed to parse ADDIE_DATA block:', e);
            return ''; // Remove invalid blocks
          }
        });

        // Use marked's built-in renderer with custom link and image handling
        const renderer = new marked.Renderer();
        renderer.link = function(href, title, text) {
          // Handle marked v17+ which passes an object
          if (typeof href === 'object') {
            const link = href;
            href = link.href;
            title = link.title;
            text = link.text;
          }
          // Validate URL scheme - only allow safe protocols
          const safeHref = /^(https?:\/\/|mailto:|#|\/)/i.test(href) ? href : '#';
          const titleAttr = title ? ` title="${escapeAttr(title)}"` : '';
          // Use target="_blank" only for external links
          const isExternal = /^https?:\/\//i.test(href);
          const targetAttr = isExternal ? ' target="_blank" rel="noopener noreferrer"' : '';
          return `<a href="${escapeAttr(safeHref)}"${titleAttr}${targetAttr}>${text}</a>`;
        };

        // Custom image renderer
        renderer.image = function(href, title, text) {
          // Handle marked v17+ which passes an object
          if (typeof href === 'object') {
            const img = href;
            href = img.href;
            title = img.title;
            text = img.text;
          }
          // Validate URL scheme - only allow safe protocols
          const safeHref = /^(https?:\/\/|data:image\/)/i.test(href) ? escapeAttr(href) : '';
          if (!safeHref) return '';
          const titleAttr = title ? ` title="${escapeAttr(title)}"` : '';
          const altAttr = text ? ` alt="${escapeAttr(text)}"` : ' alt="Image"';
          // Make images clickable to open in new tab
          return `<a href="${safeHref}" target="_blank" rel="noopener noreferrer"><img src="${safeHref}"${altAttr}${titleAttr} loading="lazy"></a>`;
        };

        let html = DOMPurify.sanitize(marked.parse(processedText, { renderer }));

        // Replace placeholders with rendered components
        dataBlocks.forEach((data, index) => {
          const placeholder = `__ADDIE_DATA_PLACEHOLDER_${index}__`;
          let replacement = '';

          if (data.type === 'member_search_results') {
            replacement = renderMemberCards(data);
          }
          // Add more types here as needed

          html = html.replace(placeholder, replacement);
        });

        return html;
      }

      // Render creative preview (iframe or HTML)
      function renderCreativePreview(previewUrl, label) {
        if (!previewUrl) return '';
        // Validate URL scheme - only allow https
        if (!/^https?:\/\//i.test(previewUrl)) return '';
        const safeUrl = previewUrl.replace(/"/g, '&quot;');
        const safeLabel = label ? label.replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'Creative Preview';
        return `
          <div class="creative-preview-container">
            <iframe src="${safeUrl}" sandbox="allow-scripts allow-same-origin" loading="lazy"></iframe>
            <div class="creative-preview-label">${safeLabel}</div>
          </div>
        `;
      }

      // Render inline HTML creative (sandboxed for security)
      function renderCreativeHtml(html, label) {
        if (!html) return '';
        // Use srcdoc with sandbox for isolation - encode for attribute
        const encodedHtml = html.replace(/"/g, '&quot;');
        return `
          <div class="creative-html-container">
            <iframe srcdoc="${encodedHtml}" sandbox="allow-scripts" loading="lazy"></iframe>
          </div>
        `;
      }

      // Add message to chat
      function addMessage(content, role, messageId = null) {
        // Hide welcome/home content when showing messages
        if (welcomeMessage) {
          welcomeMessage.style.display = 'none';
        }
        addieHomeContainer.classList.remove('visible');

        const messageDiv = document.createElement('div');
        messageDiv.className = `message message--${role}`;

        const avatarDiv = document.createElement('div');
        avatarDiv.className = 'message-avatar';
        avatarDiv.textContent = role === 'assistant' ? 'A' : '';

        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.innerHTML = renderMessage(content);

        // Add feedback controls for assistant messages
        if (role === 'assistant' && messageId) {
          const feedbackDiv = createFeedbackUI(messageId);
          contentDiv.appendChild(feedbackDiv);
        }

        messageDiv.appendChild(avatarDiv);
        messageDiv.appendChild(contentDiv);
        messagesContainer.appendChild(messageDiv);

        // Scroll to bottom
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        return messageDiv;
      }

      // Create feedback UI for a message
      function createFeedbackUI(messageId) {
        const container = document.createElement('div');
        container.className = 'message-feedback';
        container.innerHTML = `
          <span class="feedback-label">Was this helpful?</span>
          <div class="feedback-buttons">
            <button class="feedback-btn positive" data-rating="5" title="Helpful">&#128077;</button>
            <button class="feedback-btn negative" data-rating="1" title="Not helpful">&#128078;</button>
          </div>
          <button class="feedback-expand" title="Add more feedback">More...</button>
          <div class="feedback-form">
            <label>What could be better?</label>
            <select class="feedback-category">
              <option value="">Select category</option>
              <option value="accuracy">Accuracy - Information was wrong</option>
              <option value="completeness">Completeness - Missing important info</option>
              <option value="helpfulness">Helpfulness - Didn't solve my problem</option>
              <option value="clarity">Clarity - Hard to understand</option>
              <option value="tone">Tone - Response style</option>
            </select>
            <label>Tags (click to select)</label>
            <div class="feedback-tags">
              <span class="feedback-tag" data-tag="wrong_answer">Wrong answer</span>
              <span class="feedback-tag" data-tag="missing_info">Missing info</span>
              <span class="feedback-tag" data-tag="too_long">Too long</span>
              <span class="feedback-tag" data-tag="too_short">Too short</span>
              <span class="feedback-tag" data-tag="outdated">Outdated</span>
              <span class="feedback-tag" data-tag="off_topic">Off topic</span>
            </div>
            <label>How could we improve? (optional)</label>
            <textarea class="feedback-suggestion" placeholder="Tell us what would make this answer better..."></textarea>
            <button class="feedback-submit" disabled>Submit Feedback</button>
            <div class="feedback-success" style="display:none;">Thank you for your feedback!</div>
          </div>
        `;

        let selectedRating = null;
        const selectedTags = new Set();

        // Quick rating buttons
        container.querySelectorAll('.feedback-btn').forEach(btn => {
          btn.addEventListener('click', async () => {
            selectedRating = parseInt(btn.dataset.rating);
            container.querySelectorAll('.feedback-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            container.querySelector('.feedback-submit').disabled = false;

            // Auto-submit simple thumbs up/down
            if (selectedRating === 5) {
              await submitFeedback(messageId, selectedRating, null, [], null);
              showFeedbackSuccess(container);
            }
          });
        });

        // Expand to show full form
        container.querySelector('.feedback-expand').addEventListener('click', () => {
          container.querySelector('.feedback-form').classList.toggle('visible');
        });

        // Tag selection
        container.querySelectorAll('.feedback-tag').forEach(tag => {
          tag.addEventListener('click', () => {
            const tagValue = tag.dataset.tag;
            if (selectedTags.has(tagValue)) {
              selectedTags.delete(tagValue);
              tag.classList.remove('selected');
            } else {
              selectedTags.add(tagValue);
              tag.classList.add('selected');
            }
          });
        });

        // Submit full feedback
        container.querySelector('.feedback-submit').addEventListener('click', async () => {
          const category = container.querySelector('.feedback-category').value || null;
          const suggestion = container.querySelector('.feedback-suggestion').value.trim() || null;

          await submitFeedback(messageId, selectedRating || 3, category, Array.from(selectedTags), suggestion);
          showFeedbackSuccess(container);
        });

        return container;
      }

      function showFeedbackSuccess(container) {
        container.querySelector('.feedback-form').classList.remove('visible');
        container.querySelector('.feedback-buttons').style.display = 'none';
        container.querySelector('.feedback-expand').style.display = 'none';
        container.querySelector('.feedback-label').textContent = 'Thanks for your feedback!';
        container.querySelector('.feedback-label').style.color = 'var(--color-success-600)';
      }

      async function submitFeedback(messageId, rating, category, tags, suggestion) {
        try {
          await authFetch(`/api/addie/chat/${conversationId}/feedback`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              message_id: messageId,
              rating: rating,
              rating_category: category,
              feedback_tags: tags.length > 0 ? tags : null,
              improvement_suggestion: suggestion
            })
          });
        } catch (error) {
          console.error('Failed to submit feedback:', error);
        }
      }

      // === Session-level feedback ===
      let sessionFeedbackTimer = null;
      let lastAssistantMessageId = null;
      const sessionFeedbackShown = new Set(); // Track per conversation

      function scheduleSessionFeedback() {
        clearSessionFeedbackTimer();
        if (!conversationId || sessionFeedbackShown.has(conversationId)) return;
        if (!lastAssistantMessageId) return;

        // Count assistant messages in current view
        const assistantMessages = messagesContainer.querySelectorAll('.message--assistant');
        if (assistantMessages.length < 3) return;

        sessionFeedbackTimer = setTimeout(() => {
          showSessionFeedback();
        }, 45000); // 45 seconds of idle
      }

      function clearSessionFeedbackTimer() {
        if (sessionFeedbackTimer) {
          clearTimeout(sessionFeedbackTimer);
          sessionFeedbackTimer = null;
        }
      }

      function showSessionFeedback() {
        if (!conversationId || sessionFeedbackShown.has(conversationId)) return;
        sessionFeedbackShown.add(conversationId);

        const prompt = document.createElement('div');
        prompt.className = 'session-feedback';
        prompt.innerHTML = `
          <span class="session-feedback-label">How was this conversation?</span>
          <div class="session-feedback-buttons">
            <button class="session-feedback-btn positive" data-rating="5">&#128077; Helpful</button>
            <button class="session-feedback-btn negative" data-rating="1">&#128078; Not helpful</button>
          </div>
          <button class="session-feedback-dismiss" title="Dismiss">&times;</button>
        `;

        prompt.querySelector('.session-feedback-dismiss').addEventListener('click', () => {
          prompt.remove();
        });

        const feedbackMessageId = lastAssistantMessageId;
        prompt.querySelectorAll('.session-feedback-btn').forEach(btn => {
          btn.addEventListener('click', async () => {
            const rating = parseInt(btn.dataset.rating);
            try {
              await authFetch(`/api/addie/chat/${conversationId}/feedback`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  message_id: feedbackMessageId,
                  rating: rating,
                  rating_category: 'session',
                  feedback_tags: null,
                  improvement_suggestion: null
                })
              });
            } catch (e) {
              console.error('Session feedback failed:', e);
            }
            prompt.innerHTML = '<span>Thanks for the feedback!</span>';
            prompt.className = 'session-feedback session-feedback--success';
            setTimeout(() => prompt.remove(), 3000);
          });
        });

        messagesContainer.appendChild(prompt);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      // Add typing indicator
      function addTypingIndicator() {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message message--assistant';
        messageDiv.id = 'typingIndicator';

        const avatarDiv = document.createElement('div');
        avatarDiv.className = 'message-avatar';
        avatarDiv.textContent = 'A';

        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';

        messageDiv.appendChild(avatarDiv);
        messageDiv.appendChild(contentDiv);
        messagesContainer.appendChild(messageDiv);

        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      // Remove typing indicator
      function removeTypingIndicator() {
        const indicator = document.getElementById('typingIndicator');
        if (indicator) {
          indicator.remove();
        }
      }

      // Create a streaming message element that can be updated
      function createStreamingMessage() {
        // Hide welcome/home content when showing messages
        if (welcomeMessage) {
          welcomeMessage.style.display = 'none';
        }
        addieHomeContainer.classList.remove('visible');

        const messageDiv = document.createElement('div');
        messageDiv.className = 'message message--assistant';
        messageDiv.id = 'streamingMessage';

        const avatarDiv = document.createElement('div');
        avatarDiv.className = 'message-avatar';
        avatarDiv.textContent = 'A';

        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.innerHTML = '<span class="streaming-cursor">|</span>';

        messageDiv.appendChild(avatarDiv);
        messageDiv.appendChild(contentDiv);
        messagesContainer.appendChild(messageDiv);

        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        return { messageDiv, contentDiv };
      }

      // Check if text has balanced markdown markers
      // Uses arithmetic instead of lookbehind regex for Safari compatibility
      function hasBalancedMarkdown(text) {
        // Count bold markers (**)
        const boldCount = (text.match(/\*\*/g) || []).length;
        // Calculate italic: total asterisks minus those used in bold
        const allAsterisks = (text.match(/\*/g) || []).length;
        const italicCount = allAsterisks - (boldCount * 2);

        // Count code block markers (```) first, then calculate inline code
        const codeBlockCount = (text.match(/```/g) || []).length;
        const allBackticks = (text.match(/`/g) || []).length;
        const inlineCodeCount = allBackticks - (codeBlockCount * 3);

        // Count link brackets - check for unmatched link syntax
        const openBrackets = (text.match(/\[/g) || []).length;
        const closeBrackets = (text.match(/\]/g) || []).length;
        // Count ]( which indicates a complete link opening
        const linkOpens = (text.match(/\]\(/g) || []).length;

        return boldCount % 2 === 0 &&
               italicCount % 2 === 0 &&
               inlineCodeCount % 2 === 0 &&
               codeBlockCount % 2 === 0 &&
               openBrackets === closeBrackets;
      }

      // Strip markdown markers for plain text display during streaming
      function stripMarkdownMarkers(text) {
        return text
          .replace(/\*\*/g, '')      // Bold **
          .replace(/\*/g, '')        // Italic *
          .replace(/`{3}[^\n]*\n?/g, '') // Code blocks ```
          .replace(/`/g, '')         // Inline code `
          .replace(/^#{1,6}\s*/gm, '') // Headers #
          .replace(/^\s*[-*+]\s+/gm, '‚Ä¢ ') // List items
          .replace(/^\s*\d+\.\s+/gm, '‚Ä¢ ') // Numbered lists
          .replace(/~~([^~]+)~~/g, '$1') // Strikethrough
          .replace(/^\s*>\s*/gm, '')  // Blockquotes
          .replace(/!?\[([^\]]*)\]\([^)]*\)/g, '$1') // Links and images - keep text
          .replace(/^[-*_]{3,}\s*$/gm, ''); // Horizontal rules
      }

      // Append text to streaming message
      // Strategy: Split into paragraphs, render complete ones with balanced markdown,
      // show the incomplete trailing paragraph as plain text (with markers stripped)
      function appendToStreamingMessage(contentDiv, text, fullContent) {
        // Split on paragraph breaks (double newline)
        const paragraphs = fullContent.split(/\n\n/);

        if (paragraphs.length === 1) {
          // No complete paragraphs yet - show as plain text with markers stripped
          const stripped = stripMarkdownMarkers(fullContent);
          const escaped = stripped
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/\n/g, '<br>');
          contentDiv.innerHTML = escaped + '<span class="streaming-cursor">|</span>';
        } else {
          // Process each paragraph individually
          const completeParagraphs = paragraphs.slice(0, -1);
          const remainder = paragraphs[paragraphs.length - 1];

          // Render each complete paragraph - if it has balanced markdown, render it;
          // otherwise show as plain text with markers stripped
          const renderedParagraphs = completeParagraphs.map(para => {
            if (hasBalancedMarkdown(para)) {
              return renderMessage(para);
            } else {
              // Unbalanced - strip markers and escape
              const stripped = stripMarkdownMarkers(para);
              const escaped = stripped
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>');
              return '<p>' + escaped + '</p>';
            }
          });

          // Strip markers from remainder (incomplete paragraph)
          const strippedRemainder = stripMarkdownMarkers(remainder);
          const escapedRemainder = strippedRemainder
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/\n/g, '<br>');

          contentDiv.innerHTML = renderedParagraphs.join('') +
            (escapedRemainder ? '<p>' + escapedRemainder + '<span class="streaming-cursor">|</span></p>' : '<span class="streaming-cursor">|</span>');
        }
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      // Finalize streaming message with feedback UI
      function finalizeStreamingMessage(messageDiv, contentDiv, fullContent, messageId) {
        // Remove cursor and render final content
        contentDiv.innerHTML = renderMessage(fullContent);

        // Add feedback controls
        if (messageId) {
          const feedbackDiv = createFeedbackUI(messageId);
          contentDiv.appendChild(feedbackDiv);
        }

        // Remove streaming ID
        messageDiv.removeAttribute('id');
      }

      // Render CTA buttons for available SI agents
      function renderSiAgentCtas(contentDiv, siAgents) {
        const ctaContainer = document.createElement('div');
        ctaContainer.className = 'si-cta-container';

        for (const agent of siAgents) {
          const btn = document.createElement('button');
          btn.className = 'si-cta-button';
          btn.innerHTML = `<span class="si-cta-icon">&#128172;</span> Chat with ${escapeHtml(agent.display_name)}`;
          btn.title = agent.tagline || `Connect with ${agent.display_name}`;

          btn.addEventListener('click', async () => {
            // Disable button and show loading
            btn.disabled = true;
            btn.innerHTML = `<span class="si-cta-icon">&#8987;</span> Connecting...`;

            // Send message to Addie to connect to this agent
            const connectMessage = `Connect me to ${agent.display_name}`;
            chatInput.value = connectMessage;
            await sendMessage();
          });

          ctaContainer.appendChild(btn);
        }

        // Insert before feedback div (if exists) or at the end
        const feedbackDiv = contentDiv.querySelector('.message-feedback');
        if (feedbackDiv) {
          contentDiv.insertBefore(ctaContainer, feedbackDiv);
        } else {
          contentDiv.appendChild(ctaContainer);
        }
      }

      // Show error toast
      function showError(message) {
        const toast = document.createElement('div');
        toast.className = 'error-toast';
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
          toast.remove();
        }, 5000);
      }

      // === Browser Notifications ===

      // Request notification permission (opt-in)
      async function requestNotificationPermission() {
        if ('Notification' in window &&
            Notification.permission === 'default' &&
            typeof Notification.requestPermission === 'function') {
          await Notification.requestPermission();
        }
      }

      // Show browser notification
      function notifyUser(title, body, tabId) {
        if ('Notification' in window &&
            Notification.permission === 'granted' &&
            document.hidden &&
            typeof Notification === 'function') {
          try {
            const notification = new Notification(title, {
              body: body.slice(0, 100) + (body.length > 100 ? '...' : ''),
              icon: '/AAo.svg',
              tag: tabId // Prevents duplicate notifications
            });
            notification.onclick = () => {
              window.focus();
              if (tabId && tabId !== 'home') {
                const tab = activeTabs.find(t => t.id === tabId);
                if (tab) {
                  switchToConversation(tabId, tab.channel);
                }
              }
              notification.close();
            };
          } catch {
            // Notifications are non-critical, silently fail
          }
        }
      }

      // Send message with streaming
      async function sendMessage() {
        const message = chatInput.value.trim();
        if (!message || isLoading || !isReady) return;

        isLoading = true;
        updateSendButton();
        clearSessionFeedbackTimer();

        // Remove any visible session feedback prompt
        const existingPrompt = messagesContainer.querySelector('.session-feedback');
        if (existingPrompt) existingPrompt.remove();

        // Request notification permission on first message
        requestNotificationPermission();

        // Add user message
        addMessage(message, 'user');

        // Clear input
        chatInput.value = '';
        autoResize();

        // Track if this is a new conversation
        const isNewConversation = !conversationId;

        // Create streaming message element
        const { messageDiv, contentDiv } = createStreamingMessage();
        let fullContent = '';
        let messageId = null;
        let pendingSiSession = null;
        let pendingSiAgents = null;

        try {
          const response = await authFetch('/api/addie/chat/stream', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              message,
              conversation_id: conversationId,
            }),
          });

          if (!response.ok) {
            throw new Error('Failed to send message');
          }

          // Read the SSE stream
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          let currentEventType = '';
          let newConversationId = null;

          // Helper to process SSE lines (uses closure for currentEventType)
          const processLines = (lines) => {
            for (const line of lines) {
              if (line.startsWith('event: ')) {
                currentEventType = line.slice(7);
              } else if (line.startsWith('data: ') && currentEventType) {
                try {
                  const data = JSON.parse(line.slice(6));

                  if (currentEventType === 'text') {
                    fullContent += data.text;
                    appendToStreamingMessage(contentDiv, data.text, fullContent);
                  } else if (currentEventType === 'meta') {
                    newConversationId = data.conversation_id;
                    conversationId = data.conversation_id;

                    // For new conversations, add to active tabs and update currentTabId
                    if (isNewConversation && newConversationId) {
                      const title = message.slice(0, 50) + (message.length > 50 ? '...' : '');
                      addActiveTab(newConversationId, title, 'web');
                      currentTabId = newConversationId;
                      homeTab.classList.remove('active');

                      // Mark as loading
                      updateTabState(newConversationId, { isLoading: true });
                    } else if (conversationId) {
                      // Existing conversation - mark as loading
                      updateTabState(conversationId, { isLoading: true });
                    }
                  } else if (currentEventType === 'done') {
                    messageId = data.message_id;
                    conversationId = data.conversation_id;

                    // Store SI session data - will open modal after stream is completely done
                    if (data.si_session && data.si_session.session_id) {
                      console.log('SI session detected, will open modal after stream completes:', data.si_session);
                      pendingSiSession = data.si_session;
                    }

                    // Store available SI agents for CTA buttons
                    if (data.si_agents && data.si_agents.length > 0) {
                      console.log('SI agents available for CTA:', data.si_agents);
                      pendingSiAgents = data.si_agents;
                    }
                  } else if (currentEventType === 'error') {
                    throw new Error(data.error || 'Unknown error');
                  }
                  // tool_start and tool_end events are informational, could show status
                } catch (parseError) {
                  console.warn('Failed to parse SSE data:', parseError);
                }
                currentEventType = '';
              }
            }
          };

          while (true) {
            const { done, value } = await reader.read();

            if (done) {
              // Flush the decoder to handle any remaining multi-byte characters
              buffer += decoder.decode();
              // Process any remaining complete events
              if (buffer.trim()) {
                const lines = buffer.split('\n');
                processLines(lines);
              }
              break;
            }

            buffer += decoder.decode(value, { stream: true });

            // Process complete events in the buffer
            const lines = buffer.split('\n');
            buffer = lines.pop() || ''; // Keep incomplete line in buffer

            processLines(lines);
          }

          // Finalize the message with feedback UI
          finalizeStreamingMessage(messageDiv, contentDiv, fullContent, messageId);
          if (messageId) lastAssistantMessageId = messageId;

          // Open SI modal if a brand agent session was created
          // This must happen AFTER the stream is completely done to avoid race conditions
          if (pendingSiSession) {
            console.log('Stream complete, opening SI modal:', pendingSiSession);
            // Small delay to ensure DOM is fully settled
            setTimeout(async () => {
              try {
                await siOpenModal(pendingSiSession);
                console.log('SI modal opened successfully');
              } catch (err) {
                console.error('Error opening SI modal:', err);
              }
            }, 100);
          }

          // Render SI agent CTA buttons if available (but no session started)
          if (pendingSiAgents && pendingSiAgents.length > 0 && !pendingSiSession) {
            renderSiAgentCtas(contentDiv, pendingSiAgents);
          }

          // Update tab state - mark as not loading
          if (conversationId) {
            // If user switched away, increment unread and notify
            if (currentTabId !== conversationId) {
              const tab = activeTabs.find(t => t.id === conversationId);
              if (tab) {
                updateTabState(conversationId, {
                  isLoading: false,
                  unreadCount: (tab.unreadCount || 0) + 1
                });
                notifyUser('Addie replied', fullContent, conversationId);
              }
            } else {
              updateTabState(conversationId, { isLoading: false });
            }
          }

          // Schedule session-level feedback prompt after idle
          scheduleSessionFeedback();

          // Refresh thread list to show new/updated conversation (debounced)
          scheduleLoadThreads();

        } catch (error) {
          console.error('Error sending message:', error);
          // Remove the streaming message and show error
          if (messageDiv.parentNode) {
            messageDiv.remove();
          }
          showError('Failed to send message. Please try again.');

          // Clear loading state on error
          if (conversationId) {
            updateTabState(conversationId, { isLoading: false });
          }
        } finally {
          isLoading = false;
          updateSendButton();
        }
      }

      // Event listeners
      chatInput.addEventListener('input', () => {
        autoResize();
        updateSendButton();
        clearSessionFeedbackTimer(); // Reset idle timer when user types
      });

      chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });

      sendButton.addEventListener('click', sendMessage);

      // Suggested prompts
      suggestedPrompts.addEventListener('click', (e) => {
        if (e.target.classList.contains('suggested-prompt')) {
          const prompt = e.target.dataset.prompt;
          chatInput.value = prompt;
          autoResize();
          updateSendButton();
          sendMessage();
        }
      });

      // Sidebar event listeners
      sidebarToggleBtn.addEventListener('click', toggleMobileSidebar);
      sidebarOverlay.addEventListener('click', closeMobileSidebar);
      sidebarCollapseBtn.addEventListener('click', toggleSidebarCollapse);
      newChatBtn.addEventListener('click', startNewConversation);
      homeTab.addEventListener('click', switchToHome);
      historyToggle.addEventListener('click', toggleHistorySection);

      // Event delegation for active tabs (avoids adding listeners on each render)
      activeTabsList.addEventListener('click', (e) => {
        const closeBtn = e.target.closest('.tab-item-close');
        if (closeBtn) {
          e.stopPropagation();
          removeActiveTab(closeBtn.dataset.tabId);
          return;
        }
        const tabItem = e.target.closest('.tab-item');
        if (tabItem) {
          switchToConversation(tabItem.dataset.tabId, tabItem.dataset.channel);
        }
      });

      // Event delegation for history list
      historyList.addEventListener('click', (e) => {
        const historyItem = e.target.closest('.history-item');
        if (historyItem) {
          // Check if this is an SI session
          const siSessionId = historyItem.dataset.siSessionId;
          if (siSessionId) {
            // Open SI session in modal
            const brandName = historyItem.dataset.brandName;
            resumeSiSession(siSessionId, brandName);
            return;
          }

          // Regular thread
          const id = historyItem.dataset.conversationId;
          const channel = historyItem.dataset.channel;
          const thread = threads.find(t => t.conversation_id === id);
          if (thread) {
            addActiveTab(id, thread.title, channel);
          }
          switchToConversation(id, channel);
        }
      });

      // Resume an existing SI session from history
      async function resumeSiSession(sessionId, brandName) {
        try {
          // Fetch session details including messages
          const response = await authFetch(`/api/si/sessions/${sessionId}`);
          if (!response.ok) {
            console.error('Failed to load SI session');
            return;
          }

          const data = await response.json();

          // Set up modal state
          siSessionId = sessionId;
          siBrandName = brandName;
          siBrandInfo = data.brand || null;

          // Update modal header
          siModalTitle.textContent = data.brand?.name || brandName;
          siModalTagline.textContent = data.brand?.tagline || '';

          // Apply brand color if available
          if (data.brand?.brand_color) {
            siModalHeader.style.setProperty('--si-brand-color', data.brand.brand_color);
          }

          // Update icon
          if (data.brand?.logo_url) {
            siModalIconEmoji.innerHTML = `<img src="${data.brand.logo_url}" alt="${data.brand.name}" style="width:100%;height:100%;object-fit:contain;border-radius:inherit;">`;
          } else {
            siModalIconEmoji.textContent = (brandName || 'B').charAt(0).toUpperCase();
          }

          // Clear and populate messages
          siModalMessages.innerHTML = '';
          if (data.messages && data.messages.length > 0) {
            for (const msg of data.messages) {
              const role = msg.role === 'user' ? 'user' : 'assistant';
              siAddMessage(role, msg.content, msg.ui_elements, msg.surface);
            }
          }

          // Show the modal
          siModalOverlay.classList.add('active');
          document.body.style.overflow = 'hidden';

          // Focus input
          setTimeout(() => siModalInput.focus(), 100);

          // Close mobile sidebar if open
          closeMobileSidebar();
        } catch (error) {
          console.error('Failed to resume SI session:', error);
        }
      }

      // Check for prompt in query string (e.g., ?prompt=Try%20AdCP)
      function checkQueryPrompt() {
        const params = new URLSearchParams(window.location.search);
        const prompt = params.get('prompt');
        if (prompt && prompt.trim()) {
          // Wait for Addie to be ready before sending
          const waitForReady = setInterval(() => {
            if (isReady) {
              clearInterval(waitForReady);
              chatInput.value = prompt.trim();
              autoResize();
              updateSendButton();
              sendMessage();
              // Clean URL without reloading
              window.history.replaceState({}, '', window.location.pathname);
            }
          }, 100);
          // Timeout after 10 seconds
          setTimeout(() => clearInterval(waitForReady), 10000);
        }
      }

      // === SI (Sponsored Intelligence) Modal Functions ===

      // Open SI modal with brand info and initial response
      async function siOpenModal(sessionData) {
        siSessionId = sessionData.session_id;
        siBrandName = sessionData.brand_name;

        // Update modal header
        siModalTitle.textContent = siBrandName || 'Brand Agent';
        siModalTagline.textContent = '';

        // Clear previous messages
        siModalMessages.innerHTML = '';

        // Fetch full session data including messages and brand info
        let messagesLoaded = false;
        try {
          const response = await authFetch(`/api/si/sessions/${siSessionId}`);
          if (response.ok) {
            const data = await response.json();

            // Apply brand styling
            if (data.brand) {
              siBrandInfo = data.brand;
              siModalTitle.textContent = data.brand.name || siBrandName;
              if (data.brand.tagline) {
                siModalTagline.textContent = data.brand.tagline;
              }
              // Apply brand color if available
              if (data.brand.brand_color) {
                siModalHeader.style.setProperty('--si-brand-color', data.brand.brand_color);
              }
              // Update icon with logo or first letter
              if (data.brand.logo_url) {
                siModalIconEmoji.innerHTML = `<img src="${data.brand.logo_url}" alt="${data.brand.name}" style="width:100%;height:100%;object-fit:contain;border-radius:inherit;">`;
              } else {
                siModalIconEmoji.textContent = (data.brand.name || siBrandName || 'B').charAt(0).toUpperCase();
              }
            }

            // Load messages from API (includes UI elements and surfaces)
            if (data.messages && data.messages.length > 0) {
              for (const msg of data.messages) {
                const role = msg.role === 'user' ? 'user' : 'assistant';
                siAddMessage(role, msg.content, msg.ui_elements, msg.surface);
              }
              messagesLoaded = true;
            }
          }
        } catch (error) {
          console.warn('Failed to fetch SI session data:', error);
        }

        // Fallback: use brand_response from SSE if API didn't return messages
        if (!messagesLoaded && sessionData.brand_response) {
          const response = sessionData.brand_response;
          if (typeof response === 'string') {
            siAddMessage('assistant', response);
          } else if (response.message) {
            siAddMessage('assistant', response.message, response.ui_elements, response.surface);
          }
        }

        // Show the modal
        siModalOverlay.classList.add('active');
        document.body.style.overflow = 'hidden';

        // Focus the input
        setTimeout(() => siModalInput.focus(), 100);
      }

      // Close SI modal
      async function siCloseModal(endSession = true) {
        // End the session if requested
        if (endSession && siSessionId) {
          try {
            await authFetch(`/api/si/sessions/${siSessionId}`, {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ reason: 'user_exit' })
            });
          } catch (error) {
            console.warn('Failed to end SI session:', error);
          }
        }

        // Hide modal
        siModalOverlay.classList.remove('active');
        document.body.style.overflow = '';

        // Reset state
        siSessionId = null;
        siBrandName = null;
        siBrandInfo = null;
        siIsLoading = false;

        // Reset header styling
        siModalHeader.style.removeProperty('--si-brand-color');
        siModalIconEmoji.textContent = 'üè¢';
      }

      // Add a message to the SI modal
      function siAddMessage(role, content, uiElements = null, surface = null) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `si-message ${role}`;

        const contentDiv = document.createElement('div');
        contentDiv.className = 'si-message-content';

        // Parse markdown for assistant messages
        if (role === 'assistant' && window.marked) {
          contentDiv.innerHTML = DOMPurify.sanitize(marked.parse(content || ''));
        } else {
          contentDiv.textContent = content || '';
        }

        messageDiv.appendChild(contentDiv);

        // Prefer A2UI surface if present, fall back to legacy ui_elements
        if (surface && surface.components && surface.components.length > 0) {
          const uiContainer = document.createElement('div');
          uiContainer.className = 'si-ui-elements si-a2ui-surface';
          siRenderA2UISurface(uiContainer, surface);
          messageDiv.appendChild(uiContainer);
        } else if (uiElements && Array.isArray(uiElements) && uiElements.length > 0) {
          const uiContainer = document.createElement('div');
          uiContainer.className = 'si-ui-elements';
          siRenderUiElements(uiContainer, uiElements);
          messageDiv.appendChild(uiContainer);
        }

        siModalMessages.appendChild(messageDiv);

        // Scroll to bottom
        siModalMessages.scrollTop = siModalMessages.scrollHeight;
      }

      // Render UI elements from SI response
      function siRenderUiElements(container, uiElements) {
        for (const element of uiElements) {
          // Normalize element data - handle both {type, data} format and flat format
          const data = element.data || element;
          const type = element.type;

          if (type === 'button' || type === 'action_button') {
            const btn = document.createElement('button');
            btn.className = 'si-action-button';
            if (data.variant === 'secondary') btn.classList.add('secondary');

            // Add icon if specified
            if (data.icon) {
              btn.innerHTML = getSiIcon(data.icon) + ' ';
            }
            btn.innerHTML += escapeHtml(data.label || data.text || 'Continue');

            btn.addEventListener('click', () => {
              if (data.action === 'send_message' && data.value) {
                siModalInput.value = data.value;
                siSendMessage();
              } else if (data.action === 'add_mcp_tool' || data.action === 'mcp_handoff') {
                siHandleMcpHandoff(data);
              } else if (data.action === 'a2a_handoff') {
                siHandleA2aHandoff(data);
              } else if (data.action === 'checkout' || data.action === 'acp_checkout') {
                siHandleCheckout(data);
              } else if (data.url) {
                window.open(data.url, '_blank');
              } else if (data.action) {
                // Generic action - send to SI agent
                siSendAction(data.action, data.payload);
              }
            });
            container.appendChild(btn);
          } else if (type === 'link') {
            const link = document.createElement('a');
            link.className = 'si-ui-link';
            link.href = data.url || '#';
            link.target = '_blank';
            link.textContent = data.text || data.label || data.url;
            container.appendChild(link);
          } else if (type === 'image') {
            const imageDiv = document.createElement('div');
            imageDiv.className = 'si-image';
            imageDiv.innerHTML = `
              <img src="${escapeHtml(data.url || data.image_url)}" alt="${escapeHtml(data.alt || '')}">
              ${data.caption ? `<div class="si-image-caption">${escapeHtml(data.caption)}</div>` : ''}
            `;
            container.appendChild(imageDiv);
          } else if (type === 'product_card') {
            const card = document.createElement('div');
            card.className = 'si-product-card';
            const imageUrl = data.image || data.image_url;
            const hasAction = data.cta && data.cta.action;
            card.innerHTML = `
              ${imageUrl ? `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(data.title || '')}" class="si-product-image">` : ''}
              <div class="si-product-info">
                ${data.badge ? `<div class="si-product-badge">${escapeHtml(data.badge)}</div>` : ''}
                <div class="si-product-title">${escapeHtml(data.title || '')}</div>
                ${data.subtitle ? `<div class="si-product-subtitle" style="font-size:11px;color:var(--color-text-muted);margin-bottom:4px;">${escapeHtml(data.subtitle)}</div>` : ''}
                ${data.price ? `<div class="si-product-price">${escapeHtml(data.price)}</div>` : ''}
                ${data.description ? `<div class="si-product-description">${escapeHtml(data.description)}</div>` : ''}
              </div>
            `;
            // Add CTA button if present
            if (data.cta) {
              const ctaDiv = document.createElement('div');
              ctaDiv.className = 'si-product-cta';
              const ctaBtn = document.createElement('button');
              ctaBtn.textContent = data.cta.label || 'Select';
              ctaBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (data.cta.action === 'checkout' || data.cta.action === 'acp_checkout') {
                  siHandleCheckout({ ...data.cta, product: data });
                } else if (data.cta.action) {
                  siSendAction(data.cta.action, { ...data.cta.payload, product: data });
                }
              });
              ctaDiv.appendChild(ctaBtn);
              card.querySelector('.si-product-info').appendChild(ctaDiv);
            }
            container.appendChild(card);
          } else if (type === 'carousel') {
            const carousel = document.createElement('div');
            carousel.className = 'si-carousel';
            if (data.title) {
              carousel.innerHTML = `<div class="si-carousel-title">${escapeHtml(data.title)}</div>`;
            }
            const track = document.createElement('div');
            track.className = 'si-carousel-track';

            const items = data.items || [];
            for (const item of items) {
              const itemDiv = document.createElement('div');
              itemDiv.className = 'si-carousel-item';
              const itemImageUrl = item.image || item.image_url;
              itemDiv.innerHTML = `
                ${itemImageUrl ? `<img src="${escapeHtml(itemImageUrl)}" alt="${escapeHtml(item.title || '')}" class="si-carousel-item-image">` : '<div class="si-carousel-item-image"></div>'}
                <div class="si-carousel-item-content">
                  <div class="si-carousel-item-title">${escapeHtml(item.title || '')}</div>
                  ${item.subtitle ? `<div class="si-carousel-item-subtitle">${escapeHtml(item.subtitle)}</div>` : ''}
                  ${item.price ? `<div class="si-carousel-item-price">${escapeHtml(item.price)}</div>` : ''}
                </div>
              `;
              itemDiv.addEventListener('click', () => {
                if (item.action) {
                  siSendAction(item.action, { item });
                } else if (item.url) {
                  window.open(item.url, '_blank');
                } else {
                  // Default: select this item
                  siSendAction('select_item', { item });
                }
              });
              track.appendChild(itemDiv);
            }
            carousel.appendChild(track);
            container.appendChild(carousel);
          } else if (type === 'integration_actions') {
            // MCP/A2A handoff options
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'si-integration-actions';

            const actions = data.actions || [
              { type: 'mcp', label: 'Add as MCP Tool', highlighted: true },
              { type: 'a2a', label: 'Connect via A2A' }
            ];

            for (const action of actions) {
              const btn = document.createElement('button');
              btn.className = 'si-integration-button';
              if (action.highlighted) btn.classList.add('highlighted');

              const icon = action.type === 'mcp' ? getSiIcon('plug') : getSiIcon('link');
              btn.innerHTML = icon + ' ' + escapeHtml(action.label);

              btn.addEventListener('click', () => {
                if (action.type === 'mcp') {
                  siHandleMcpHandoff(action);
                } else if (action.type === 'a2a') {
                  siHandleA2aHandoff(action);
                }
              });
              actionsDiv.appendChild(btn);
            }
            container.appendChild(actionsDiv);
          }
        }
      }

      // =======================================================================
      // A2UI Surface Rendering
      // =======================================================================

      /**
       * Resolve a BoundValue to its actual value
       * @param {Object} boundValue - A2UI BoundValue (literalString, literalNumber, literalBoolean, or path)
       * @param {Object} dataModel - The surface's data model
       * @param {Object} itemContext - Current item context for list templates (optional)
       */
      function siResolveBoundValue(boundValue, dataModel, itemContext = null) {
        if (!boundValue) return null;

        // Literal values
        if ('literalString' in boundValue) return boundValue.literalString;
        if ('literalNumber' in boundValue) return boundValue.literalNumber;
        if ('literalBoolean' in boundValue) return boundValue.literalBoolean;

        // Path resolution
        if ('path' in boundValue) {
          const path = boundValue.path;

          // Item-relative paths (for list templates)
          if (path.startsWith('/item/') && itemContext) {
            const itemPath = path.slice(6); // Remove '/item/'
            return siGetValueByPath(itemContext, itemPath);
          }

          // Absolute paths from dataModel
          if (path.startsWith('/') && dataModel) {
            return siGetValueByPath(dataModel, path.slice(1));
          }

          return null;
        }

        // If it's a plain string/number/boolean, return as-is
        if (typeof boundValue === 'string' || typeof boundValue === 'number' || typeof boundValue === 'boolean') {
          return boundValue;
        }

        return null;
      }

      /**
       * Get value from object by dot/slash path
       */
      function siGetValueByPath(obj, path) {
        const parts = path.split('/').filter(Boolean);
        let current = obj;
        for (const part of parts) {
          if (current === null || current === undefined) return null;
          current = current[part];
        }
        return current;
      }

      /**
       * Render an A2UI surface
       * @param {HTMLElement} container - Container to render into
       * @param {Object} surface - A2UI surface object
       */
      function siRenderA2UISurface(container, surface) {
        if (!surface || !surface.components) return;

        const dataModel = surface.dataModel || {};
        const componentMap = new Map();

        // Index components by ID
        for (const comp of surface.components) {
          componentMap.set(comp.id, comp);
        }

        // Find root components (no parentId or parentId not in componentMap)
        const rootComponents = surface.components.filter(
          comp => !comp.parentId || !componentMap.has(comp.parentId)
        );

        // Render each root component
        for (const comp of rootComponents) {
          const el = siRenderA2UIComponent(comp, componentMap, dataModel, null);
          if (el) container.appendChild(el);
        }
      }

      /**
       * Render a single A2UI component
       */
      function siRenderA2UIComponent(comp, componentMap, dataModel, itemContext) {
        if (!comp || !comp.component) return null;

        // Get component type and props
        const [type, props] = Object.entries(comp.component)[0];

        switch (type) {
          case 'Text':
            return siRenderA2UIText(props, dataModel, itemContext);

          case 'Button':
            return siRenderA2UIButton(props, dataModel, itemContext);

          case 'Link':
            return siRenderA2UILink(props, dataModel, itemContext);

          case 'Image':
            return siRenderA2UIImage(props, dataModel, itemContext);

          case 'ProductCard':
            return siRenderA2UIProductCard(props, dataModel, itemContext);

          case 'List':
            return siRenderA2UIList(props, componentMap, dataModel);

          case 'Row':
            return siRenderA2UIRow(props, componentMap, dataModel, itemContext);

          case 'Column':
            return siRenderA2UIColumn(props, componentMap, dataModel, itemContext);

          case 'IntegrationAction':
            return siRenderA2UIIntegrationAction(props, dataModel, itemContext);

          case 'Card':
            return siRenderA2UICard(props, dataModel, itemContext);

          default:
            console.warn('Unknown A2UI component type:', type);
            return null;
        }
      }

      function siRenderA2UIText(props, dataModel, itemContext) {
        const el = document.createElement('div');
        el.className = 'si-a2ui-text';
        if (props.variant) el.classList.add(`variant-${props.variant}`);
        el.textContent = siResolveBoundValue(props.text, dataModel, itemContext) || '';
        return el;
      }

      function siRenderA2UIButton(props, dataModel, itemContext) {
        const btn = document.createElement('button');
        btn.className = 'si-action-button';
        if (props.variant === 'secondary') btn.classList.add('secondary');
        if (props.variant === 'text') btn.classList.add('text-only');

        btn.textContent = siResolveBoundValue(props.label, dataModel, itemContext) || 'Button';

        if (props.action) {
          btn.addEventListener('click', () => {
            const actionContext = {};
            if (props.action.context) {
              for (const [key, value] of Object.entries(props.action.context)) {
                actionContext[key] = siResolveBoundValue(value, dataModel, itemContext);
              }
            }
            siSendAction(props.action.name, actionContext);
          });
        }

        return btn;
      }

      function siRenderA2UILink(props, dataModel, itemContext) {
        const link = document.createElement('a');
        link.className = 'si-ui-link';
        link.href = siResolveBoundValue(props.url, dataModel, itemContext) || '#';
        if (props.external !== false) link.target = '_blank';
        link.textContent = siResolveBoundValue(props.label, dataModel, itemContext) || link.href;
        return link;
      }

      function siRenderA2UIImage(props, dataModel, itemContext) {
        const container = document.createElement('div');
        container.className = 'si-image';

        const img = document.createElement('img');
        img.src = siResolveBoundValue(props.url, dataModel, itemContext) || '';
        img.alt = siResolveBoundValue(props.alt, dataModel, itemContext) || '';
        container.appendChild(img);

        const caption = siResolveBoundValue(props.caption, dataModel, itemContext);
        if (caption) {
          const captionEl = document.createElement('div');
          captionEl.className = 'si-image-caption';
          captionEl.textContent = caption;
          container.appendChild(captionEl);
        }

        return container;
      }

      function siRenderA2UIProductCard(props, dataModel, itemContext) {
        const card = document.createElement('div');
        card.className = 'si-product-card';

        const imageUrl = siResolveBoundValue(props.image, dataModel, itemContext);
        const title = siResolveBoundValue(props.title, dataModel, itemContext);
        const price = siResolveBoundValue(props.price, dataModel, itemContext);
        const description = siResolveBoundValue(props.description, dataModel, itemContext);
        const badge = siResolveBoundValue(props.badge, dataModel, itemContext);
        const ctaLabel = siResolveBoundValue(props.ctaLabel, dataModel, itemContext);

        card.innerHTML = `
          ${imageUrl ? `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(title || '')}" class="si-product-image">` : ''}
          <div class="si-product-info">
            ${badge ? `<div class="si-product-badge">${escapeHtml(badge)}</div>` : ''}
            <div class="si-product-title">${escapeHtml(title || '')}</div>
            ${price ? `<div class="si-product-price">${escapeHtml(price)}</div>` : ''}
            ${description ? `<div class="si-product-description">${escapeHtml(description)}</div>` : ''}
          </div>
        `;

        // Add action handler
        if (props.action) {
          const ctaDiv = document.createElement('div');
          ctaDiv.className = 'si-product-cta';
          const ctaBtn = document.createElement('button');
          ctaBtn.textContent = ctaLabel || 'Select';
          ctaBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const actionContext = {};
            if (props.action.context) {
              for (const [key, value] of Object.entries(props.action.context)) {
                actionContext[key] = siResolveBoundValue(value, dataModel, itemContext);
              }
            }
            siSendAction(props.action.name, actionContext);
          });
          ctaDiv.appendChild(ctaBtn);
          card.querySelector('.si-product-info').appendChild(ctaDiv);
        }

        return card;
      }

      function siRenderA2UIList(props, componentMap, dataModel) {
        const container = document.createElement('div');
        container.className = 'si-a2ui-list';

        const layout = props.layout || 'vertical';
        if (layout === 'horizontal') {
          container.classList.add('horizontal');
        } else if (layout === 'grid') {
          container.classList.add('grid');
        }

        // Get items from dataModel
        const items = siResolveBoundValue(props.items, dataModel, null) || [];
        const templateId = props.template?.componentId;
        const templateComp = templateId ? componentMap.get(templateId) : null;

        for (const item of items) {
          if (templateComp) {
            const el = siRenderA2UIComponent(templateComp, componentMap, dataModel, item);
            if (el) container.appendChild(el);
          }
        }

        return container;
      }

      function siRenderA2UIRow(props, componentMap, dataModel, itemContext) {
        const container = document.createElement('div');
        container.className = 'si-a2ui-row';
        if (props.gap) container.style.gap = props.gap;

        const children = props.children || [];
        for (const childId of children) {
          const childComp = componentMap.get(childId);
          if (childComp) {
            const el = siRenderA2UIComponent(childComp, componentMap, dataModel, itemContext);
            if (el) container.appendChild(el);
          }
        }

        return container;
      }

      function siRenderA2UIColumn(props, componentMap, dataModel, itemContext) {
        const container = document.createElement('div');
        container.className = 'si-a2ui-column';
        if (props.gap) container.style.gap = props.gap;

        const children = props.children || [];
        for (const childId of children) {
          const childComp = componentMap.get(childId);
          if (childComp) {
            const el = siRenderA2UIComponent(childComp, componentMap, dataModel, itemContext);
            if (el) container.appendChild(el);
          }
        }

        return container;
      }

      function siRenderA2UIIntegrationAction(props, dataModel, itemContext) {
        const btn = document.createElement('button');
        btn.className = 'si-integration-button';
        if (props.highlighted) btn.classList.add('highlighted');

        const icon = props.type === 'mcp' ? getSiIcon('plug') : getSiIcon('link');
        const label = siResolveBoundValue(props.label, dataModel, itemContext) || '';
        btn.innerHTML = icon + ' ' + escapeHtml(label);

        btn.addEventListener('click', () => {
          const url = siResolveBoundValue(props.url, dataModel, itemContext);
          if (props.type === 'mcp') {
            siHandleMcpHandoff({ endpoint: url });
          } else if (props.type === 'a2a') {
            siHandleA2aHandoff({ url });
          }
        });

        return btn;
      }

      function siRenderA2UICard(props, dataModel, itemContext) {
        const card = document.createElement('div');
        card.className = 'si-product-card';

        const title = siResolveBoundValue(props.title, dataModel, itemContext);
        const subtitle = siResolveBoundValue(props.subtitle, dataModel, itemContext);
        const image = siResolveBoundValue(props.image, dataModel, itemContext);

        card.innerHTML = `
          ${image ? `<img src="${escapeHtml(image)}" alt="${escapeHtml(title || '')}" class="si-product-image">` : ''}
          <div class="si-product-info">
            <div class="si-product-title">${escapeHtml(title || '')}</div>
            ${subtitle ? `<div class="si-product-subtitle">${escapeHtml(subtitle)}</div>` : ''}
          </div>
        `;

        if (props.action) {
          card.style.cursor = 'pointer';
          card.addEventListener('click', () => {
            const actionContext = {};
            if (props.action.context) {
              for (const [key, value] of Object.entries(props.action.context)) {
                actionContext[key] = siResolveBoundValue(value, dataModel, itemContext);
              }
            }
            siSendAction(props.action.name, actionContext);
          });
        }

        return card;
      }

      // Get SVG icon for SI components
      function getSiIcon(name) {
        const icons = {
          plug: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v10m0 0a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm-6-2h12M8 2v4m8-4v4"/></svg>',
          link: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>',
          cart: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="9" cy="21" r="1"/><circle cx="20" cy="21" r="1"/><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"/></svg>',
          check: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>',
          arrow: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>'
        };
        return icons[name] || '';
      }

      // Handle MCP tool handoff
      async function siHandleMcpHandoff(data) {
        const brandName = siBrandInfo?.name || siBrandName;
        const endpoint = siBrandInfo?.si_endpoint_url || data.endpoint;

        // Show confirmation in the chat
        siAddMessage('assistant', `Great choice! To add ${brandName} as an MCP tool, you can configure your AI assistant with this endpoint:\n\n\`${endpoint || 'https://' + (siBrandInfo?.slug || brandName.toLowerCase()) + '.example.com/mcp'}\`\n\nThis will give your AI assistant direct access to ${brandName}'s capabilities.`, [
          {
            type: 'action_button',
            data: {
              label: 'Copy MCP Config',
              action: 'copy_mcp_config',
              icon: 'check',
              variant: 'secondary'
            }
          }
        ]);

        // Also notify the SI agent about the interest
        try {
          await authFetch(`/api/si/sessions/${siSessionId}/messages`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action_response: {
                action: 'mcp_interest',
                payload: { requested: true }
              }
            })
          });
        } catch (error) {
          console.warn('Failed to notify SI agent of MCP interest:', error);
        }
      }

      // Handle A2A handoff
      async function siHandleA2aHandoff(data) {
        const brandName = siBrandInfo?.name || siBrandName;

        siAddMessage('assistant', `${brandName} supports the Agent-to-Agent (A2A) protocol. Your AI can communicate directly with ${brandName}'s agent for seamless collaboration.\n\nA2A enables richer, more contextual interactions than traditional API calls.`, [
          {
            type: 'action_button',
            data: {
              label: 'Learn More About A2A',
              url: 'https://a2a.protocol.io',
              variant: 'secondary'
            }
          }
        ]);
      }

      // Handle checkout/transaction handoff
      function siHandleCheckout(data) {
        const brandName = siBrandInfo?.name || siBrandName;
        siAddMessage('assistant', `Ready to complete your purchase! I'll hand you off to ${brandName}'s secure checkout.`);

        // Signal handoff to SI agent
        siSendAction('handoff_transaction', { checkout_data: data });
      }

      // Send an action to the SI agent
      async function siSendAction(action, payload = {}) {
        if (siIsLoading || !siSessionId) return;

        siIsLoading = true;
        siShowTyping();

        try {
          const response = await authFetch(`/api/si/sessions/${siSessionId}/messages`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action_response: { action, payload }
            })
          });

          siHideTyping();

          if (!response.ok) {
            throw new Error('Failed to send action');
          }

          const data = await response.json();

          if (data.response) {
            siAddMessage('assistant', data.response.message, data.response.ui_elements, data.response.surface);

            if (data.response.session_status === 'completed' || data.response.handoff) {
              setTimeout(() => siCloseModal(false), 2000);
            }
          }
        } catch (error) {
          siHideTyping();
          console.error('SI action error:', error);
        } finally {
          siIsLoading = false;
        }
      }

      // Add typing indicator
      function siShowTyping() {
        const typingDiv = document.createElement('div');
        typingDiv.className = 'si-message assistant si-typing-indicator';
        typingDiv.id = 'siTypingIndicator';
        typingDiv.innerHTML = `
          <div class="si-message-content">
            <span class="si-typing-dot"></span>
            <span class="si-typing-dot"></span>
            <span class="si-typing-dot"></span>
          </div>
        `;
        siModalMessages.appendChild(typingDiv);
        siModalMessages.scrollTop = siModalMessages.scrollHeight;
      }

      // Remove typing indicator
      function siHideTyping() {
        const typing = document.getElementById('siTypingIndicator');
        if (typing) typing.remove();
      }

      // Send message through SI API with streaming
      async function siSendMessage() {
        const message = siModalInput.value.trim();
        if (!message || siIsLoading || !siSessionId) return;

        siIsLoading = true;
        siModalInput.value = '';
        siModalSend.disabled = true;

        // Add user message
        siAddMessage('user', message);

        // Create placeholder for streaming response
        const messageDiv = document.createElement('div');
        messageDiv.className = 'si-message assistant';
        const contentDiv = document.createElement('div');
        contentDiv.className = 'si-message-content';
        messageDiv.appendChild(contentDiv);
        siModalMessages.appendChild(messageDiv);

        let streamedText = '';
        let uiElements = null;
        let surface = null;
        let sessionStatus = 'active';
        let hasHandoff = false;

        try {
          // Get auth headers
          const headers = { 'Content-Type': 'application/json' };
          const token = localStorage.getItem('jwt');
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
          }

          const response = await fetch(`/api/si/sessions/${siSessionId}/messages/stream`, {
            method: 'POST',
            headers,
            body: JSON.stringify({ message })
          });

          if (!response.ok) {
            throw new Error('Failed to send message');
          }

          // Process SSE stream
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });

            // Process complete SSE events from buffer
            const lines = buffer.split('\n');
            buffer = lines.pop() || ''; // Keep incomplete line in buffer

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const event = JSON.parse(line.slice(6));

                  if (event.type === 'text') {
                    streamedText += event.text;
                    // Update content with markdown parsing
                    if (window.marked) {
                      contentDiv.innerHTML = DOMPurify.sanitize(marked.parse(streamedText));
                    } else {
                      contentDiv.textContent = streamedText;
                    }
                    siModalMessages.scrollTop = siModalMessages.scrollHeight;
                  } else if (event.type === 'done') {
                    // Store UI elements, surface, and session info for final render
                    uiElements = event.response?.ui_elements;
                    surface = event.response?.surface;
                    sessionStatus = event.response?.session_status;
                    hasHandoff = !!event.response?.handoff;
                  } else if (event.type === 'error') {
                    streamedText = event.error || 'Sorry, there was an error processing your message.';
                    contentDiv.textContent = streamedText;
                  }
                } catch (parseError) {
                  console.warn('SI stream parse error:', parseError);
                }
              }
            }
          }

          // Render A2UI surface or legacy UI elements after stream completes
          // Prefer surface if present
          if (surface && surface.components && surface.components.length > 0) {
            const uiContainer = document.createElement('div');
            uiContainer.className = 'si-ui-elements si-a2ui-surface';
            siRenderA2UISurface(uiContainer, surface);
            messageDiv.appendChild(uiContainer);
          } else if (uiElements && Array.isArray(uiElements) && uiElements.length > 0) {
            const uiContainer = document.createElement('div');
            uiContainer.className = 'si-ui-elements';
            siRenderUiElements(uiContainer, uiElements);
            messageDiv.appendChild(uiContainer);
          }

          // Check if session should be closed
          if (sessionStatus === 'completed' || hasHandoff) {
            setTimeout(() => {
              siCloseModal(false);
            }, 2000);
          }
        } catch (error) {
          contentDiv.textContent = 'Sorry, there was an error processing your message. Please try again.';
          console.error('SI message error:', error);
        } finally {
          siIsLoading = false;
          siModalSend.disabled = false;
          siModalInput.focus();
        }
      }

      // SI Modal Event Listeners
      siModalClose.addEventListener('click', () => siCloseModal());

      siModalOverlay.addEventListener('click', (e) => {
        if (e.target === siModalOverlay) {
          siCloseModal();
        }
      });

      siModalSend.addEventListener('click', siSendMessage);

      siModalInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          siSendMessage();
        }
      });

      // Auto-resize SI input
      siModalInput.addEventListener('input', () => {
        siModalInput.style.height = 'auto';
        siModalInput.style.height = Math.min(siModalInput.scrollHeight, 120) + 'px';
      });

      // Close on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && siModalOverlay.classList.contains('active')) {
          siCloseModal();
        }
      });

      // Initialize
      extractNativeToken(); // Check for native app auth token in URL hash
      applySidebarCollapsedState(); // Restore sidebar collapsed state from localStorage
      checkStatus();
      checkImpersonation();
      // Check for prompt in URL after status check
      setTimeout(checkQueryPrompt, 500);
      // Check status periodically
      setInterval(checkStatus, 30000);

    })();
  </script>
</body>
</html>
