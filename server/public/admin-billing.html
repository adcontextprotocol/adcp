<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="/AAo.svg" type="image/svg+xml">
  <title>Billing - Admin</title>
  <link rel="stylesheet" href="/design-system.css">
  <script src="/nav.js"></script>
  <script src="/admin-sidebar.js"></script>
  <style>
    body {
      background: var(--color-bg-page);
      min-height: 100vh;
    }
    .container {
      max-width: var(--container-wide);
      margin: var(--space-8) auto;
      padding: 0 var(--space-5);
    }
    h1 { margin-bottom: var(--space-2); color: var(--color-text-heading); }
    .subtitle { color: var(--color-text-secondary); margin-bottom: var(--space-6); }

    .stats-row {
      display: flex;
      gap: var(--space-4);
      margin-bottom: var(--space-6);
    }
    .stat-card {
      background: var(--color-bg-card);
      border-radius: var(--radius-md);
      padding: var(--space-5);
      flex: 1;
      box-shadow: var(--shadow-xs);
    }
    .stat-label {
      font-size: var(--text-sm);
      color: var(--color-text-secondary);
      margin-bottom: var(--space-1);
    }
    .stat-value {
      font-size: var(--text-2xl);
      font-weight: var(--font-bold);
      color: var(--color-text-heading);
    }
    .stat-value.warning { color: var(--color-warning-600); }
    .stat-value.success { color: var(--color-success-600); }
    .stat-value.error { color: var(--color-error-600); }

    .card {
      background: var(--color-bg-card);
      border-radius: var(--radius-md);
      padding: var(--space-6);
      box-shadow: var(--shadow-xs);
      margin-bottom: var(--space-5);
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-5);
    }
    .card-title {
      font-size: var(--text-lg);
      font-weight: var(--font-semibold);
      color: var(--color-text-heading);
    }

    .customers-table {
      width: 100%;
      border-collapse: collapse;
    }
    .customers-table th {
      background: var(--color-gray-50);
      padding: var(--space-3) var(--space-4);
      text-align: left;
      font-size: var(--text-sm);
      font-weight: var(--font-semibold);
      color: var(--color-text-heading);
      border-bottom: var(--border-1) solid var(--color-border);
    }
    .customers-table td {
      padding: var(--space-3) var(--space-4);
      border-bottom: var(--border-1) solid var(--color-border);
      font-size: var(--text-sm);
      color: var(--color-text-heading);
    }
    .customers-table tr:hover {
      background: var(--color-gray-50);
    }
    .customers-table tr.linked {
      opacity: 0.6;
    }
    .customers-table tr.unlinked-with-payments {
      background: var(--color-warning-50);
    }
    .customers-table tr.unlinked-with-payments:hover {
      background: var(--color-warning-100);
    }

    .badge {
      display: inline-block;
      padding: var(--space-0.5) var(--space-2);
      border-radius: var(--radius-full);
      font-size: var(--text-xs);
      font-weight: var(--font-medium);
    }
    .badge-success {
      background: var(--color-success-100);
      color: var(--color-success-800);
    }
    .badge-warning {
      background: var(--color-warning-100);
      color: var(--color-warning-800);
    }
    .badge-gray {
      background: var(--color-gray-100);
      color: var(--color-gray-700);
    }

    .link-form {
      display: flex;
      gap: var(--space-2);
      align-items: center;
    }
    .link-form input {
      padding: var(--space-1.5) var(--space-2);
      border: var(--border-1) solid var(--color-gray-300);
      border-radius: var(--radius-sm);
      font-size: var(--text-sm);
      width: 200px;
    }
    .link-form input:focus {
      outline: none;
      border-color: var(--color-brand);
      box-shadow: 0 0 0 2px var(--color-primary-100);
    }

    .btn {
      padding: var(--space-1.5) var(--space-3);
      border: none;
      border-radius: var(--radius-sm);
      font-size: var(--text-sm);
      cursor: pointer;
      transition: var(--transition-all);
    }
    .btn-primary {
      background: var(--color-brand);
      color: white;
    }
    .btn-primary:hover {
      background: var(--color-primary-700);
    }
    .btn-primary:disabled {
      background: var(--color-gray-300);
      cursor: not-allowed;
    }
    .btn-secondary {
      background: var(--color-gray-200);
      color: var(--color-text-heading);
    }
    .btn-secondary:hover {
      background: var(--color-gray-300);
    }
    .btn-danger {
      background: var(--color-error-100);
      color: var(--color-error-700);
    }
    .btn-danger:hover {
      background: var(--color-error-200);
    }
    .btn-danger:disabled {
      background: var(--color-gray-100);
      color: var(--color-gray-400);
      cursor: not-allowed;
    }

    .search-dropdown {
      position: relative;
    }
    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--color-bg-card);
      border: var(--border-1) solid var(--color-gray-200);
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow-lg);
      max-height: 200px;
      overflow-y: auto;
      z-index: 100;
      display: none;
    }
    .search-results.show {
      display: block;
    }
    .search-result-item {
      padding: var(--space-2) var(--space-3);
      cursor: pointer;
      border-bottom: var(--border-1) solid var(--color-gray-100);
    }
    .search-result-item:hover {
      background: var(--color-gray-50);
    }
    .search-result-item:last-child {
      border-bottom: none;
    }
    .search-result-name {
      font-weight: var(--font-medium);
      color: var(--color-text-heading);
    }
    .search-result-domain {
      font-size: var(--text-xs);
      color: var(--color-text-secondary);
    }
    .search-result-linked {
      font-size: var(--text-xs);
      color: var(--color-warning-600);
    }

    .loading {
      text-align: center;
      padding: var(--space-10);
      color: var(--color-text-secondary);
    }
    .loading-spinner {
      display: inline-block;
      width: 24px;
      height: 24px;
      border: 3px solid var(--color-gray-200);
      border-top-color: var(--color-brand);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .error-message {
      background: var(--color-error-50);
      color: var(--color-error-800);
      padding: var(--space-4);
      border-radius: var(--radius-md);
      margin-bottom: var(--space-5);
    }
    .success-message {
      background: var(--color-success-50);
      color: var(--color-success-800);
      padding: var(--space-4);
      border-radius: var(--radius-md);
      margin-bottom: var(--space-5);
    }

    .filter-toggle {
      display: flex;
      gap: var(--space-2);
      margin-bottom: var(--space-4);
    }
    .filter-btn {
      padding: var(--space-2) var(--space-4);
      border: var(--border-1) solid var(--color-gray-200);
      background: var(--color-bg-card);
      border-radius: var(--radius-md);
      font-size: var(--text-sm);
      cursor: pointer;
      transition: var(--transition-all);
    }
    .filter-btn:hover {
      background: var(--color-gray-50);
    }
    .filter-btn.active {
      background: var(--color-brand);
      color: white;
      border-color: var(--color-brand);
    }

    /* Conflicts section */
    .conflicts-card {
      border: var(--border-1) solid var(--color-error-200);
      background: var(--color-error-50);
    }
    .conflicts-card .card-title {
      color: var(--color-error-700);
    }
    .conflicts-table {
      width: 100%;
      border-collapse: collapse;
    }
    .conflicts-table th {
      background: var(--color-gray-50);
      padding: var(--space-3) var(--space-4);
      text-align: left;
      font-size: var(--text-sm);
      font-weight: var(--font-semibold);
      color: var(--color-text-heading);
      border-bottom: var(--border-1) solid var(--color-border);
    }
    .conflicts-table td {
      padding: var(--space-3) var(--space-4);
      border-bottom: var(--border-1) solid var(--color-border);
      font-size: var(--text-sm);
      color: var(--color-text-heading);
      background: white;
    }
    .conflicts-table tr:hover td {
      background: var(--color-gray-50);
    }
    .conflict-choice {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2);
      background: var(--color-gray-50);
      border-radius: var(--radius-sm);
    }
    .conflict-choice-info {
      flex: 1;
    }
    .conflict-choice-name {
      font-weight: var(--font-medium);
      color: var(--color-text-heading);
    }
    .conflict-choice-id {
      font-size: var(--text-xs);
      color: var(--color-text-secondary);
    }
    .conflict-info-box {
      background: var(--color-primary-50);
      border: var(--border-1) solid var(--color-primary-200);
      border-radius: var(--radius-md);
      padding: var(--space-3);
      margin-bottom: var(--space-4);
      font-size: var(--text-sm);
      color: var(--color-primary-800);
    }
    .btn-sm {
      padding: var(--space-1) var(--space-2);
      font-size: var(--text-xs);
    }
  </style>
</head>
<body>
  <div id="adcp-nav"></div>

  <div class="container">
    <h1>Stripe Customer Linking</h1>
    <p class="subtitle">Link Stripe customers to organizations for revenue tracking</p>

    <div id="error-message" class="error-message" style="display: none;"></div>
    <div id="success-message" class="success-message" style="display: none;"></div>

    <div class="stats-row" id="stats-row">
      <div class="stat-card">
        <div class="stat-label">Total Customers</div>
        <div class="stat-value" id="stat-total">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Linked</div>
        <div class="stat-value success" id="stat-linked">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Unlinked</div>
        <div class="stat-value" id="stat-unlinked">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Unlinked with Payments</div>
        <div class="stat-value warning" id="stat-unlinked-payments">-</div>
      </div>
      <div class="stat-card" id="conflicts-stat-card" style="display: none;">
        <div class="stat-label">Conflicts</div>
        <div class="stat-value error" id="stat-conflicts">0</div>
      </div>
      <div class="stat-card" id="mismatches-stat-card" style="display: none;">
        <div class="stat-label">Mismatches</div>
        <div class="stat-value warning" id="stat-mismatches">0</div>
      </div>
    </div>

    <!-- Mismatches Section (only shown when mismatches exist) -->
    <div class="card conflicts-card" id="mismatches-section" style="display: none;">
      <div class="card-header">
        <div class="card-title">Stripe Customer Mismatches</div>
        <button class="btn btn-secondary" id="auto-resolve-btn" style="display: none;" onclick="autoResolveAll()">Auto-Resolve Safe</button>
      </div>
      <div class="conflict-info-box">
        A mismatch occurs when an organization has a Stripe customer in our database, but a <strong>different</strong> Stripe customer's metadata claims to belong to that same organization. This typically means the org has multiple Stripe customers (duplicate accounts).<br><br>
        <strong>Auto-resolve:</strong> If only one customer has activity (invoices/subscriptions), the inactive one can be safely archived.
      </div>
      <table class="conflicts-table">
        <thead>
          <tr>
            <th>Organization</th>
            <th>DB Customer</th>
            <th>Metadata Customer</th>
            <th>Suggested Action</th>
          </tr>
        </thead>
        <tbody id="mismatches-body">
        </tbody>
      </table>
    </div>

    <!-- Conflicts Section (only shown when conflicts exist) -->
    <div class="card conflicts-card" id="conflicts-section" style="display: none;">
      <div class="card-header">
        <div class="card-title">Stripe Metadata Conflicts</div>
      </div>
      <div class="conflict-info-box">
        A conflict occurs when a Stripe customer's metadata says it belongs to Organization A, but our database has it linked to Organization B. Choose which organization should own the customer.
      </div>
      <table class="conflicts-table">
        <thead>
          <tr>
            <th>Stripe Customer</th>
            <th>Stripe Says (metadata)</th>
            <th>Database Has</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="conflicts-body">
        </tbody>
      </table>
    </div>

    <div class="card">
      <div class="card-header">
        <div class="card-title">Stripe Customers</div>
        <button class="btn btn-secondary" onclick="loadCustomers()">Refresh</button>
      </div>

      <div class="filter-toggle">
        <button class="filter-btn active" data-filter="all" onclick="setFilter('all', this)">All</button>
        <button class="filter-btn" data-filter="unlinked" onclick="setFilter('unlinked', this)">Unlinked Only</button>
        <button class="filter-btn" data-filter="unlinked-payments" onclick="setFilter('unlinked-payments', this)">Unlinked with Payments</button>
      </div>

      <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <p>Loading Stripe customers...</p>
      </div>

      <table class="customers-table" id="customers-table" style="display: none;">
        <thead>
          <tr>
            <th>Customer</th>
            <th>Email</th>
            <th>Billing Info</th>
            <th>Total Paid</th>
            <th>Linked To</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="customers-body">
        </tbody>
      </table>
    </div>
  </div>

  <script>
    let allCustomers = [];
    let allConflicts = [];
    let allMismatches = [];
    let currentFilter = 'all';

    const formatCurrency = (cents) => {
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
      }).format(cents / 100);
    };

    const formatDate = (timestamp) => {
      return new Date(timestamp * 1000).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
      });
    };

    function showError(message) {
      const el = document.getElementById('error-message');
      el.textContent = message;
      el.style.display = 'block';
      setTimeout(() => { el.style.display = 'none'; }, 5000);
    }

    function showSuccess(message) {
      const el = document.getElementById('success-message');
      el.textContent = message;
      el.style.display = 'block';
      setTimeout(() => { el.style.display = 'none'; }, 5000);
    }

    function setFilter(filter, btn) {
      currentFilter = filter;
      document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      renderCustomers();
    }

    function getFilteredCustomers() {
      switch (currentFilter) {
        case 'unlinked':
          return allCustomers.filter(c => !c.linked_org);
        case 'unlinked-payments':
          return allCustomers.filter(c => !c.linked_org && c.total_paid > 0);
        default:
          return allCustomers;
      }
    }

    function renderCustomers() {
      const tbody = document.getElementById('customers-body');
      const customers = getFilteredCustomers();

      tbody.innerHTML = customers.map(customer => {
        const isLinked = !!customer.linked_org;
        const hasPayments = customer.total_paid > 0;
        const rowClass = isLinked ? 'linked' : (hasPayments ? 'unlinked-with-payments' : '');

        // Build billing info indicators
        const billingBadges = [];
        if (customer.open_invoice_count > 0) {
          billingBadges.push(`<span class="badge badge-warning" title="Open invoices: ${formatCurrency(customer.open_invoice_total)}">${customer.open_invoice_count} open</span>`);
        }
        if (customer.has_payment_method) {
          billingBadges.push('<span class="badge badge-success" title="Has payment method on file">Card</span>');
        }
        if (customer.active_subscriptions > 0) {
          billingBadges.push(`<span class="badge badge-success" title="Active subscriptions">${customer.active_subscriptions} sub${customer.active_subscriptions > 1 ? 's' : ''}</span>`);
        }
        if (customer.invoice_count > 0) {
          billingBadges.push(`<span class="badge badge-gray" title="Paid invoices">${customer.invoice_count} paid</span>`);
        }

        return `
          <tr class="${rowClass}" data-customer-id="${customer.id}">
            <td>
              <div><strong>${customer.name || 'No name'}</strong></div>
              <div style="font-size: 11px; color: var(--color-text-muted);">${customer.id}</div>
              <div style="font-size: 10px; color: var(--color-text-muted);">Created ${formatDate(customer.created)}</div>
            </td>
            <td>${customer.email || '-'}</td>
            <td style="white-space: nowrap;">
              ${billingBadges.length > 0 ? billingBadges.join(' ') : '<span style="color: var(--color-text-muted);">None</span>'}
            </td>
            <td>${hasPayments ? formatCurrency(customer.total_paid) : '-'}</td>
            <td>
              ${isLinked
                ? `<span class="badge badge-success">${customer.linked_org.name}</span>`
                : '<span class="badge badge-warning">Not linked</span>'
              }
            </td>
            <td>
              ${isLinked
                ? `<button class="btn btn-secondary" onclick="unlinkCustomer('${customer.id}', '${(customer.linked_org.name || '').replace(/'/g, "\\'")}')">Unlink</button>`
                : `<div class="link-form">
                    <div class="search-dropdown">
                      <input type="text"
                             placeholder="Search org..."
                             id="search-${customer.id}"
                             oninput="searchOrgs('${customer.id}', this.value)"
                             onfocus="showSearchResults('${customer.id}')"
                      />
                      <div class="search-results" id="results-${customer.id}"></div>
                    </div>
                    <button class="btn btn-primary" id="link-btn-${customer.id}" disabled onclick="linkCustomer('${customer.id}')">Link</button>
                    <button class="btn btn-danger" onclick="deleteCustomer('${customer.id}', '${(customer.email || '').replace(/'/g, "\\'")}', ${customer.total_paid})" title="Delete from Stripe">Delete</button>
                  </div>`
              }
            </td>
          </tr>
        `;
      }).join('');
    }

    let searchTimeout = null;
    let selectedOrgs = {};

    function showSearchResults(customerId) {
      // Close other dropdowns
      document.querySelectorAll('.search-results').forEach(el => el.classList.remove('show'));
    }

    async function searchOrgs(customerId, query) {
      const resultsEl = document.getElementById(`results-${customerId}`);

      if (query.length < 2) {
        resultsEl.classList.remove('show');
        return;
      }

      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(async () => {
        try {
          const response = await fetch(`/api/admin/org-search?q=${encodeURIComponent(query)}`);
          const data = await response.json();

          if (data.organizations.length === 0) {
            resultsEl.innerHTML = '<div class="search-result-item" style="color: var(--color-text-muted);">No results</div>';
          } else {
            resultsEl.innerHTML = data.organizations.map(org => `
              <div class="search-result-item" onclick="selectOrg('${customerId}', '${org.workos_organization_id}', '${org.name.replace(/'/g, "\\'")}')">
                <div class="search-result-name">${org.name}</div>
                ${org.email_domain ? `<div class="search-result-domain">${org.email_domain}</div>` : ''}
                ${org.stripe_customer_id ? `<div class="search-result-linked">Already linked to another customer</div>` : ''}
              </div>
            `).join('');
          }
          resultsEl.classList.add('show');
        } catch (err) {
          console.error('Search error:', err);
        }
      }, 300);
    }

    function selectOrg(customerId, orgId, orgName) {
      selectedOrgs[customerId] = { id: orgId, name: orgName };
      document.getElementById(`search-${customerId}`).value = orgName;
      document.getElementById(`results-${customerId}`).classList.remove('show');
      document.getElementById(`link-btn-${customerId}`).disabled = false;
    }

    async function linkCustomer(customerId) {
      const selectedOrg = selectedOrgs[customerId];
      if (!selectedOrg) {
        showError('Please select an organization first');
        return;
      }

      const btn = document.getElementById(`link-btn-${customerId}`);
      btn.disabled = true;
      btn.textContent = 'Linking...';

      try {
        const response = await fetch(`/api/admin/stripe-customers/${customerId}/link`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ org_id: selectedOrg.id }),
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.message || data.error || 'Failed to link customer');
        }

        showSuccess(`Linked to "${selectedOrg.name}"`);
        delete selectedOrgs[customerId];

        // Update local data and re-render
        const customer = allCustomers.find(c => c.id === customerId);
        if (customer) {
          customer.linked_org = { id: selectedOrg.id, name: selectedOrg.name };
        }
        updateStats();
        renderCustomers();
      } catch (err) {
        showError(err.message);
        btn.disabled = false;
        btn.textContent = 'Link';
      }
    }

    async function deleteCustomer(customerId, email, totalPaid) {
      const warningMsg = totalPaid > 0
        ? `This customer (${email}) has ${formatCurrency(totalPaid)} in payments. Are you sure you want to delete them from Stripe?`
        : `Delete customer ${email} from Stripe?`;

      if (!confirm(warningMsg)) {
        return;
      }

      try {
        const response = await fetch(`/api/admin/stripe-customers/${customerId}`, {
          method: 'DELETE',
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.message || data.error || 'Failed to delete customer');
        }

        showSuccess(`Deleted customer ${email}`);

        // Remove from local data and re-render
        allCustomers = allCustomers.filter(c => c.id !== customerId);
        updateStats();
        renderCustomers();
      } catch (err) {
        showError(err.message);
      }
    }

    async function unlinkCustomer(customerId, orgName) {
      if (!confirm(`Unlink customer from "${orgName}"? You can re-link it to a different organization afterwards.`)) {
        return;
      }

      try {
        const response = await fetch(`/api/admin/stripe-customers/${customerId}/unlink`, {
          method: 'POST',
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.message || data.error || 'Failed to unlink customer');
        }

        showSuccess(`Unlinked customer from "${orgName}"`);

        // Update local data and re-render
        const customer = allCustomers.find(c => c.id === customerId);
        if (customer) {
          customer.linked_org = null;
        }
        updateStats();
        renderCustomers();
      } catch (err) {
        showError(err.message);
      }
    }

    function updateStats() {
      const total = allCustomers.length;
      const linked = allCustomers.filter(c => c.linked_org).length;
      const unlinked = total - linked;
      const unlinkedWithPayments = allCustomers.filter(c => !c.linked_org && c.total_paid > 0).length;

      document.getElementById('stat-total').textContent = total;
      document.getElementById('stat-linked').textContent = linked;
      document.getElementById('stat-unlinked').textContent = unlinked;
      document.getElementById('stat-unlinked-payments').textContent = unlinkedWithPayments;

      // Update conflicts stat
      const conflictsStatCard = document.getElementById('conflicts-stat-card');
      const conflictsSection = document.getElementById('conflicts-section');
      if (allConflicts.length > 0) {
        document.getElementById('stat-conflicts').textContent = allConflicts.length;
        conflictsStatCard.style.display = 'block';
        conflictsSection.style.display = 'block';
      } else {
        conflictsStatCard.style.display = 'none';
        conflictsSection.style.display = 'none';
      }

      // Update mismatches stat
      const mismatchesStatCard = document.getElementById('mismatches-stat-card');
      const mismatchesSection = document.getElementById('mismatches-section');
      if (allMismatches.length > 0) {
        document.getElementById('stat-mismatches').textContent = allMismatches.length;
        mismatchesStatCard.style.display = 'block';
        mismatchesSection.style.display = 'block';
      } else {
        mismatchesStatCard.style.display = 'none';
        mismatchesSection.style.display = 'none';
      }
    }

    function renderConflicts() {
      const tbody = document.getElementById('conflicts-body');
      tbody.innerHTML = allConflicts.map((conflict, index) => `
        <tr data-index="${index}">
          <td>
            <div><strong>${conflict.stripe_customer_id}</strong></div>
            <div style="font-size: 11px;">
              <a href="https://dashboard.stripe.com/customers/${conflict.stripe_customer_id}" target="_blank" rel="noopener" style="color: var(--color-brand);">
                View in Stripe &rarr;
              </a>
            </div>
          </td>
          <td>
            <div class="conflict-choice">
              <div class="conflict-choice-info">
                <div class="conflict-choice-name">${conflict.stripe_says_org_name || 'Unknown'}</div>
                <div class="conflict-choice-id">${conflict.stripe_says_org_id}</div>
                <span class="badge badge-gray">From Stripe metadata</span>
              </div>
              <button class="btn btn-primary btn-sm" onclick="resolveConflict(${index}, 'stripe')" title="Use Stripe's metadata as source of truth">
                Use This
              </button>
            </div>
          </td>
          <td>
            <div class="conflict-choice">
              <div class="conflict-choice-info">
                <div class="conflict-choice-name">${conflict.db_has_org_name}</div>
                <div class="conflict-choice-id">${conflict.db_has_org_id}</div>
                <span class="badge badge-warning">Currently in database</span>
              </div>
              <button class="btn btn-secondary btn-sm" onclick="resolveConflict(${index}, 'database')" title="Keep database record, update Stripe metadata">
                Keep This
              </button>
            </div>
          </td>
          <td>
            <button class="btn btn-danger btn-sm" onclick="unlinkConflict(${index})" title="Unlink from both and resolve manually">
              Unlink
            </button>
          </td>
        </tr>
      `).join('');
    }

    async function resolveConflict(index, choice) {
      const conflict = allConflicts[index];
      const keepOrgId = choice === 'stripe' ? conflict.stripe_says_org_id : conflict.db_has_org_id;
      const keepOrgName = choice === 'stripe' ? conflict.stripe_says_org_name : conflict.db_has_org_name;
      const action = choice === 'stripe' ? 'unlink_other' : 'update_stripe_metadata';

      if (!confirm(`Link Stripe customer ${conflict.stripe_customer_id} to "${keepOrgName}"?`)) {
        return;
      }

      try {
        const response = await fetch('/api/admin/stripe-conflicts/resolve', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            stripe_customer_id: conflict.stripe_customer_id,
            keep_org_id: keepOrgId,
            action: action,
          }),
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.message || data.error || 'Failed to resolve conflict');
        }

        showSuccess(`Resolved: ${conflict.stripe_customer_id} is now linked to "${keepOrgName}"`);

        // Remove from list and re-render
        allConflicts.splice(index, 1);
        updateStats();
        renderConflicts();
      } catch (err) {
        showError(err.message);
      }
    }

    async function unlinkConflict(index) {
      const conflict = allConflicts[index];

      if (!confirm(`Unlink Stripe customer ${conflict.stripe_customer_id} from "${conflict.db_has_org_name}"? You can then manually link it to the correct organization.`)) {
        return;
      }

      try {
        const response = await fetch('/api/admin/stripe-customer/unlink', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            org_id: conflict.db_has_org_id,
          }),
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.message || data.error || 'Failed to unlink customer');
        }

        showSuccess(`Unlinked ${conflict.stripe_customer_id}. You can now link it manually below.`);

        // Remove from list, refresh customers, and re-render
        allConflicts.splice(index, 1);
        updateStats();
        renderConflicts();
        loadCustomers(); // Refresh customers list to show the now-unlinked customer
      } catch (err) {
        showError(err.message);
      }
    }

    async function loadConflicts() {
      try {
        const response = await fetch('/api/admin/stripe-conflicts');
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.message || data.error || 'Failed to load conflicts');
        }

        allConflicts = data.conflicts || [];
        updateStats();
        renderConflicts();
      } catch (err) {
        console.error('Failed to load conflicts:', err);
        // Don't show error to user - conflicts are secondary to the main customer list
      }
    }

    function renderCustomerActivity(customer, isActive) {
      if (!customer) return '<span style="color: var(--color-text-muted);">Unable to fetch</span>';
      const badges = [];
      if (customer.active_subscriptions > 0) {
        badges.push(`<span class="badge badge-success">${customer.active_subscriptions} sub${customer.active_subscriptions > 1 ? 's' : ''}</span>`);
      }
      if (customer.open_invoice_count > 0) {
        badges.push(`<span class="badge badge-warning">${customer.open_invoice_count} open</span>`);
      }
      if (customer.paid_invoice_count > 0) {
        badges.push(`<span class="badge badge-gray">${customer.paid_invoice_count} paid (${formatCurrency(customer.total_paid)})</span>`);
      }
      if (customer.has_payment_method) {
        badges.push('<span class="badge badge-gray">Card</span>');
      }
      if (badges.length === 0) {
        badges.push('<span style="color: var(--color-success-600); font-size: 11px;">No activity - can delete</span>');
      }
      return badges.join(' ');
    }

    function renderMismatches() {
      const tbody = document.getElementById('mismatches-body');
      const autoResolvable = allMismatches.filter(m => m.can_auto_resolve).length;

      // Show/hide auto-resolve button
      const autoResolveBtn = document.getElementById('auto-resolve-btn');
      if (autoResolvable > 0) {
        autoResolveBtn.textContent = `Auto-Resolve Safe (${autoResolvable})`;
        autoResolveBtn.style.display = 'inline-block';
      } else {
        autoResolveBtn.style.display = 'none';
      }

      tbody.innerHTML = allMismatches.map((mismatch, index) => {
        const dbActivity = mismatch.db_customer;
        const metadataActivity = mismatch.metadata_customer;
        const suggestedAction = mismatch.suggested_action;
        const canAutoResolve = mismatch.can_auto_resolve;

        // Determine which customer should be highlighted as "keep" vs "remove"
        const dbIsKeep = suggestedAction === 'use_db';
        const metadataIsKeep = suggestedAction === 'use_stripe_metadata';
        const needsManualReview = suggestedAction === 'manual_review';

        let actionHtml = '';
        if (needsManualReview) {
          actionHtml = `
            <div style="color: var(--color-error-600); font-weight: 500; margin-bottom: 8px;">
              Manual review required
            </div>
            <div style="font-size: 11px; color: var(--color-text-muted); margin-bottom: 8px;">
              Both customers have activity. Review in Stripe to decide.
            </div>
            <button class="btn btn-secondary btn-sm" onclick="resolveMismatch(${index}, 'use_db', false)" title="Keep DB customer">
              Keep DB
            </button>
            <button class="btn btn-secondary btn-sm" onclick="resolveMismatch(${index}, 'use_stripe_metadata', false)" title="Keep Metadata customer">
              Keep Metadata
            </button>
          `;
        } else if (canAutoResolve) {
          const action = suggestedAction;
          const keepId = action === 'use_db' ? mismatch.db_customer_id : mismatch.stripe_metadata_customer_id;
          const deleteId = action === 'use_db' ? mismatch.stripe_metadata_customer_id : mismatch.db_customer_id;
          actionHtml = `
            <div style="color: var(--color-success-600); font-weight: 500; margin-bottom: 8px;">
              Safe to auto-resolve
            </div>
            <div style="font-size: 11px; color: var(--color-text-muted); margin-bottom: 8px;">
              Keep ${keepId.slice(-8)}, delete ${deleteId.slice(-8)}
            </div>
            <button class="btn btn-primary btn-sm" onclick="resolveMismatch(${index}, '${action}', true)" title="Keep active customer, delete inactive one">
              Resolve & Delete
            </button>
            <button class="btn btn-secondary btn-sm" onclick="resolveMismatch(${index}, '${action}', false)" title="Keep active customer, just clear metadata from other">
              Resolve Only
            </button>
          `;
        } else {
          actionHtml = `
            <div style="font-size: 11px; color: var(--color-text-muted);">
              Choose which customer to keep.
            </div>
          `;
        }

        return `
          <tr data-index="${index}" style="${canAutoResolve ? 'background: var(--color-success-50);' : needsManualReview ? 'background: var(--color-error-50);' : ''}">
            <td>
              <div><strong>${mismatch.org_name}</strong></div>
              <div style="font-size: 11px; color: var(--color-text-muted);">${mismatch.org_id}</div>
            </td>
            <td style="border-left: 3px solid ${dbIsKeep ? 'var(--color-success-500)' : 'var(--color-gray-200)'};">
              <div style="margin-bottom: 4px;">
                <strong>${mismatch.db_customer_id}</strong>
                <span class="badge badge-success">Linked</span>
                ${dbActivity?.has_activity ? '<span class="badge badge-warning">Has Activity</span>' : ''}
              </div>
              <div style="font-size: 11px; margin-bottom: 4px;">
                ${renderCustomerActivity(dbActivity, dbActivity?.has_activity)}
              </div>
              <div style="font-size: 11px;">
                <a href="https://dashboard.stripe.com/customers/${mismatch.db_customer_id}" target="_blank" rel="noopener" style="color: var(--color-brand);">
                  View in Stripe &rarr;
                </a>
              </div>
            </td>
            <td style="border-left: 3px solid ${metadataIsKeep ? 'var(--color-success-500)' : 'var(--color-gray-200)'};">
              <div style="margin-bottom: 4px;">
                <strong>${mismatch.stripe_metadata_customer_id}</strong>
                <span class="badge badge-gray">Metadata</span>
                ${metadataActivity?.has_activity ? '<span class="badge badge-warning">Has Activity</span>' : ''}
              </div>
              <div style="font-size: 11px; margin-bottom: 4px;">
                ${renderCustomerActivity(metadataActivity, metadataActivity?.has_activity)}
              </div>
              <div style="font-size: 11px;">
                <a href="https://dashboard.stripe.com/customers/${mismatch.stripe_metadata_customer_id}" target="_blank" rel="noopener" style="color: var(--color-brand);">
                  View in Stripe &rarr;
                </a>
              </div>
            </td>
            <td>
              ${actionHtml}
            </td>
          </tr>
        `;
      }).join('');
    }

    async function resolveMismatch(index, action, deleteInactive = false) {
      const mismatch = allMismatches[index];
      const keepCustomer = action === 'use_db' ? mismatch.db_customer_id : mismatch.stripe_metadata_customer_id;
      const removeCustomer = action === 'use_db' ? mismatch.stripe_metadata_customer_id : mismatch.db_customer_id;

      const confirmMsg = deleteInactive
        ? `Keep ${keepCustomer} for "${mismatch.org_name}"?\n\nThe inactive customer (${removeCustomer}) will be DELETED from Stripe.`
        : `Keep ${keepCustomer} for "${mismatch.org_name}"?\n\nThe other customer (${removeCustomer}) will have its metadata cleared but remain in Stripe.`;

      if (!confirm(confirmMsg)) {
        return;
      }

      try {
        const response = await fetch('/api/admin/stripe-mismatches/resolve', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            org_id: mismatch.org_id,
            action: action,
            delete_inactive: deleteInactive,
          }),
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.message || data.error || 'Failed to resolve mismatch');
        }

        const deletedMsg = data.deleted ? ` Deleted ${data.removed_customer}.` : ` Cleared metadata from ${data.removed_customer}.`;
        showSuccess(`Resolved: "${mismatch.org_name}" now uses ${data.kept_customer}.${deletedMsg}`);

        // Remove from list and re-render
        allMismatches.splice(index, 1);
        updateStats();
        renderMismatches();
        loadCustomers(); // Refresh to show any changes
      } catch (err) {
        showError(err.message);
      }
    }

    async function autoResolveAll() {
      const resolvable = allMismatches.filter(m => m.can_auto_resolve);
      if (resolvable.length === 0) {
        showError('No mismatches can be auto-resolved');
        return;
      }

      if (!confirm(`Auto-resolve ${resolvable.length} mismatch(es)?\n\nThis will keep the customer with activity and DELETE the inactive customer for each.`)) {
        return;
      }

      let resolved = 0;
      let failed = 0;

      for (const mismatch of resolvable) {
        try {
          const response = await fetch('/api/admin/stripe-mismatches/resolve', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              org_id: mismatch.org_id,
              action: mismatch.suggested_action,
              delete_inactive: true,
            }),
          });

          if (response.ok) {
            resolved++;
            // Remove from array
            const idx = allMismatches.findIndex(m => m.org_id === mismatch.org_id);
            if (idx !== -1) allMismatches.splice(idx, 1);
          } else {
            console.error('Auto-resolve failed for', mismatch.org_name, await response.text());
            failed++;
          }
        } catch (err) {
          console.error('Auto-resolve failed for', mismatch.org_name, err);
          failed++;
        }
      }

      updateStats();
      renderMismatches();
      loadCustomers();

      if (failed > 0) {
        showSuccess(`Auto-resolved ${resolved} mismatch(es). ${failed} failed.`);
      } else {
        showSuccess(`Auto-resolved ${resolved} mismatch(es).`);
      }
    }

    async function loadMismatches() {
      try {
        const response = await fetch('/api/admin/stripe-mismatches');
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.message || data.error || 'Failed to load mismatches');
        }

        allMismatches = data.mismatches || [];
        updateStats();
        renderMismatches();
      } catch (err) {
        console.error('Failed to load mismatches:', err);
        // Don't show error to user - mismatches are secondary to the main customer list
      }
    }

    async function loadCustomers() {
      document.getElementById('loading').style.display = 'block';
      document.getElementById('customers-table').style.display = 'none';

      try {
        const response = await fetch('/api/admin/stripe-customers');
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.message || data.error || 'Failed to load customers');
        }

        allCustomers = data.customers;
        updateStats();
        renderCustomers();

        document.getElementById('loading').style.display = 'none';
        document.getElementById('customers-table').style.display = 'table';
      } catch (err) {
        document.getElementById('loading').innerHTML = `<p style="color: var(--color-error-600);">Error: ${err.message}</p>`;
      }
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.search-dropdown')) {
        document.querySelectorAll('.search-results').forEach(el => el.classList.remove('show'));
      }
    });

    // Load on page load
    loadCustomers();
    loadConflicts();
    loadMismatches();
  </script>
</body>
</html>
